#![allow(unused_qualifications)]

use http::HeaderValue;
use validator::Validate;

// TODO this is a workaround for cargo error[E0412]: cannot find type `integer` in this scope
/// synonym of u32
type integer = u32;

#[cfg(feature = "server")]
use crate::header;
use crate::{models, types::*};


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerAttachLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerAttachLibpodQueryParams {
            /// keys to use for detaching from the container
                #[serde(rename = "detachKeys")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub detach_keys: Option<String>,
            /// Stream all logs from the container across the connection. Happens before streaming attach (if requested). At least one of logs or stream must be set
                #[serde(rename = "logs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub logs: Option<bool>,
            /// Attach to the container. If unset, and logs is set, only the container's logs will be sent. At least one of stream or logs must be set
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
            /// Attach to container STDOUT
                #[serde(rename = "stdout")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stdout: Option<bool>,
            /// Attach to container STDERR
                #[serde(rename = "stderr")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stderr: Option<bool>,
            /// Attach to container STDIN
                #[serde(rename = "stdin")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stdin: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerCheckpointLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerCheckpointLibpodQueryParams {
            /// keep all temporary checkpoint files
                #[serde(rename = "keep")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub keep: Option<bool>,
            /// leave the container running after writing checkpoint to disk
                #[serde(rename = "leaveRunning")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub leave_running: Option<bool>,
            /// checkpoint a container with established TCP connections
                #[serde(rename = "tcpEstablished")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tcp_established: Option<bool>,
            /// export the checkpoint image to a tar.gz
                #[serde(rename = "export")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub export: Option<bool>,
            /// do not include root file-system changes when exporting. can only be used with export
                #[serde(rename = "ignoreRootFS")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore_root_fs: Option<bool>,
            /// do not include associated volumes. can only be used with export
                #[serde(rename = "ignoreVolumes")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore_volumes: Option<bool>,
            /// dump the container's memory information only, leaving the container running. only works on runc 1.0-rc or higher
                #[serde(rename = "preCheckpoint")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pre_checkpoint: Option<bool>,
            /// check out the container with previous criu image files in pre-dump. only works on runc 1.0-rc or higher
                #[serde(rename = "withPrevious")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub with_previous: Option<bool>,
            /// checkpoint a container with filelocks
                #[serde(rename = "fileLocks")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub file_locks: Option<bool>,
            /// add checkpoint statistics to the returned CheckpointReport
                #[serde(rename = "printStats")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub print_stats: Option<bool>,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerDeleteLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerDeleteLibpodQueryParams {
            /// additionally remove containers that depend on the container to be removed
                #[serde(rename = "depend")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub depend: Option<bool>,
            /// force stop container if running
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
            /// ignore errors when the container to be removed does not existxo
                #[serde(rename = "ignore")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore: Option<bool>,
            /// number of seconds to wait before killing container when force removing
                #[serde(rename = "timeout")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub timeout: Option<i32>,
            /// delete volumes
                #[serde(rename = "v")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub v: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerExistsLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerExportLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerHealthcheckLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerInitLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerInspectLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerInspectLibpodQueryParams {
            /// display filesystem usage
                #[serde(rename = "size")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub size: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerKillLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerKillLibpodQueryParams {
            /// signal to be sent to container, either by integer or SIG_ name
                #[serde(rename = "signal")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub signal: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerListLibpodQueryParams {
            /// Return all containers. By default, only running containers are shown
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// Return this number of most recently created containers, including non-running ones.
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// Include namespace information
                #[serde(rename = "namespace")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub namespace: Option<bool>,
            /// Ignored. Previously included details on pod name and ID that are currently included by default.
                #[serde(rename = "pod")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pod: Option<bool>,
            /// Return the size of container as fields SizeRw and SizeRootFs.
                #[serde(rename = "size")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub size: Option<bool>,
            /// Sync container state with OCI runtime
                #[serde(rename = "sync")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub sync: Option<bool>,
            /// A JSON encoded value of the filters (a `map[string][]string`) to process on the containers list. Available filters: - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`) - `before`=(`<container id>` or `<container name>`) - `expose`=(`<port>[/<proto>]` or `<startport-endport>/[<proto>]`) - `exited=<int>` containers with exit code of `<int>` - `health`=(`starting`, `healthy`, `unhealthy` or `none`) - `id=<ID>` a container's ID - `is-task`=(`true` or `false`) - `label`=(`key` or `\"key=value\"`) of a container label - `name=<name>` a container's name - `network`=(`<network id>` or `<network name>`) - `pod`=(`<pod id>` or `<pod name>`) - `publish`=(`<port>[/<proto>]` or `<startport-endport>/[<proto>]`) - `since`=(`<container id>` or `<container name>`) - `status`=(`created`, `restarting`, `running`, `removing`, `paused`, `exited` or `dead`) - `volume`=(`<volume name>` or `<mount point destination>`)
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerLogsLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerLogsLibpodQueryParams {
            /// Keep connection after returning logs.
                #[serde(rename = "follow")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub follow: Option<bool>,
            /// Return logs from stdout
                #[serde(rename = "stdout")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stdout: Option<bool>,
            /// Return logs from stderr
                #[serde(rename = "stderr")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stderr: Option<bool>,
            /// Only return logs since this time, as a UNIX timestamp
                #[serde(rename = "since")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub since: Option<String>,
            /// Only return logs before this time, as a UNIX timestamp
                #[serde(rename = "until")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub until: Option<String>,
            /// Add timestamps to every log line
                #[serde(rename = "timestamps")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub timestamps: Option<bool>,
            /// Only return this number of log lines from the end of the logs
                #[serde(rename = "tail")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tail: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerMountLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerPauseLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerPruneLibpodQueryParams {
            /// Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters:  - `until=<timestamp>` Prune containers created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.  - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune containers with (or without, in case `label!=...` is used) the specified labels.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRenameLibpodPathParams {
            /// Full or partial ID or full name of the container to rename
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRenameLibpodQueryParams {
            /// New name for the container
                #[serde(rename = "name")]
                pub name2: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerResizeLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerResizeLibpodQueryParams {
            /// Height to set for the terminal, in characters
                #[serde(rename = "h")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub h: Option<i32>,
            /// Width to set for the terminal, in characters
                #[serde(rename = "w")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub w: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRestartLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRestartLibpodQueryParams {
            /// number of seconds to wait before killing container
                #[serde(rename = "t")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub t: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRestoreLibpodPathParams {
            /// the name or id of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRestoreLibpodQueryParams {
            /// the name of the container when restored from a tar. can only be used with import
                #[serde(rename = "name")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub name2: Option<String>,
            /// keep all temporary checkpoint files
                #[serde(rename = "keep")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub keep: Option<bool>,
            /// checkpoint a container with established TCP connections
                #[serde(rename = "tcpEstablished")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tcp_established: Option<bool>,
            /// import the restore from a checkpoint tar.gz
                #[serde(rename = "import")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub import: Option<bool>,
            /// do not include root file-system changes when exporting. can only be used with import
                #[serde(rename = "ignoreRootFS")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore_root_fs: Option<bool>,
            /// do not restore associated volumes. can only be used with import
                #[serde(rename = "ignoreVolumes")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore_volumes: Option<bool>,
            /// ignore IP address if set statically
                #[serde(rename = "ignoreStaticIP")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore_static_ip: Option<bool>,
            /// ignore MAC address if set statically
                #[serde(rename = "ignoreStaticMAC")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore_static_mac: Option<bool>,
            /// restore a container with file locks
                #[serde(rename = "fileLocks")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub file_locks: Option<bool>,
            /// add restore statistics to the returned RestoreReport
                #[serde(rename = "printStats")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub print_stats: Option<bool>,
            /// pod to restore into
                #[serde(rename = "pod")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pod: Option<String>,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStartLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStartLibpodQueryParams {
            /// Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-<value> where <value> is one of: a-z, @, ^, [, , or _.
                #[serde(rename = "detachKeys")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub detach_keys: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStatsLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStatsLibpodQueryParams {
            /// Stream the output
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStopLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStopLibpodQueryParams {
            /// number of seconds to wait before killing container
                #[serde(rename = "timeout")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub timeout: Option<i32>,
            /// do not return error if container is already stopped
                #[serde(rename = "Ignore")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerTopLibpodPathParams {
            /// Name of container to query for processes (As of version 1.xx)
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerTopLibpodQueryParams {
            /// when true, repeatedly stream the latest output (As of version 4.0)
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
            /// if streaming, delay in seconds between updates. Must be >1. (As of version 4.0)
                #[serde(rename = "delay")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub delay: Option<i32>,
            /// arguments to pass to ps such as aux.
                #[serde(rename = "ps_args")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ps_args: Option<Vec<String>>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerUnmountLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerUnpauseLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerUpdateLibpodPathParams {
            /// Full or partial ID or full name of the container to update
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerUpdateLibpodQueryParams {
            /// New restart policy for the container.
                #[serde(rename = "restartPolicy")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub restart_policy: Option<String>,
            /// New amount of retries for the container's restart policy. Only allowed if restartPolicy is set to on-failure
                #[serde(rename = "restartRetries")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub restart_retries: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerWaitLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerWaitLibpodQueryParams {
            /// Conditions to wait for. If no condition provided the 'exited' condition is assumed.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "condition")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub condition: Option<Vec<String>>,
            /// Time Interval to wait before polling for completion.
                #[serde(rename = "interval")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub interval: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainersStatsAllLibpodQueryParams {
            /// names or IDs of containers
                #[serde(rename = "containers")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub containers: Option<Vec<String>>,
            /// Stream the output
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
            /// Time in seconds between stats reports
                #[serde(rename = "interval")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub interval: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageCommitLibpodQueryParams {
            /// the name or ID of a container
                #[serde(rename = "container")]
                pub container: String,
            /// author of the image
                #[serde(rename = "author")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub author: Option<String>,
            /// instructions to apply while committing in Dockerfile format (i.e. \"CMD=/bin/foo\")
                #[serde(rename = "changes")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub changes: Option<Vec<String>>,
            /// commit message
                #[serde(rename = "comment")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub comment: Option<String>,
            /// format of the image manifest and metadata (default \"oci\")
                #[serde(rename = "format")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub format: Option<String>,
            /// pause the container before committing it
                #[serde(rename = "pause")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pause: Option<bool>,
            /// squash the container before committing it
                #[serde(rename = "squash")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub squash: Option<bool>,
            /// the repository name for the created image
                #[serde(rename = "repo")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub repo: Option<String>,
            /// output from commit process
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
            /// tag name for the created image
                #[serde(rename = "tag")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tag: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PutContainerArchiveLibpodPathParams {
            /// container name or id
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PutContainerArchiveLibpodQueryParams {
            /// Path to a directory in the container to extract
                #[serde(rename = "path")]
                pub path: String,
            /// pause the container while copying (defaults to true)
                #[serde(rename = "pause")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pause: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerArchivePathParams {
            /// container name or id
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerArchiveQueryParams {
            /// Path to a directory in the container to extract
                #[serde(rename = "path")]
                pub path: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerArchiveLibpodPathParams {
            /// container name or id
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerArchiveLibpodQueryParams {
            /// Path to a directory in the container to extract
                #[serde(rename = "path")]
                pub path: String,
            /// JSON encoded map[string]string to translate paths
                #[serde(rename = "rename")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub rename: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerAttachPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerAttachQueryParams {
            /// keys to use for detaching from the container
                #[serde(rename = "detachKeys")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub detach_keys: Option<String>,
            /// Stream all logs from the container across the connection. Happens before streaming attach (if requested). At least one of logs or stream must be set
                #[serde(rename = "logs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub logs: Option<bool>,
            /// Attach to the container. If unset, and logs is set, only the container's logs will be sent. At least one of stream or logs must be set
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
            /// Attach to container STDOUT
                #[serde(rename = "stdout")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stdout: Option<bool>,
            /// Attach to container STDERR
                #[serde(rename = "stderr")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stderr: Option<bool>,
            /// Attach to container STDIN
                #[serde(rename = "stdin")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stdin: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerCreateQueryParams {
            /// container name
                #[serde(rename = "name")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub name: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerDeletePathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerDeleteQueryParams {
            /// If the container is running, kill it before removing it.
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
            /// Remove the volumes associated with the container.
                #[serde(rename = "v")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub v: Option<bool>,
            /// not supported
                #[serde(rename = "link")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub link: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerExportPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerInspectPathParams {
            /// the name or id of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerInspectQueryParams {
            /// include the size of the container
                #[serde(rename = "size")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub size: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerKillPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerKillQueryParams {
            /// Send kill signal to all containers
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// signal to be sent to container
                #[serde(rename = "signal")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub signal: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerListQueryParams {
            /// Return all containers. By default, only running containers are shown
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// Return containers in storage not controlled by Podman
                #[serde(rename = "external")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub external: Option<bool>,
            /// Return this number of most recently created containers, including non-running ones.
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// Return the size of container as fields SizeRw and SizeRootFs.
                #[serde(rename = "size")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub size: Option<bool>,
            /// A JSON encoded value of the filters (a `map[string][]string`) to process on the containers list. Available filters: - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`) - `before`=(`<container id>` or `<container name>`) - `expose`=(`<port>[/<proto>]` or `<startport-endport>/[<proto>]`) - `exited=<int>` containers with exit code of `<int>` - `health`=(`starting`, `healthy`, `unhealthy` or `none`) - `id=<ID>` a container's ID - `is-task`=(`true` or `false`) - `label`=(`key` or `\"key=value\"`) of a container label - `name=<name>` a container's name - `network`=(`<network id>` or `<network name>`) - `publish`=(`<port>[/<proto>]` or `<startport-endport>/[<proto>]`) - `since`=(`<container id>` or `<container name>`) - `status`=(`created`, `restarting`, `running`, `removing`, `paused`, `exited` or `dead`) - `volume`=(`<volume name>` or `<mount point destination>`)
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerLogsPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerLogsQueryParams {
            /// Keep connection after returning logs.
                #[serde(rename = "follow")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub follow: Option<bool>,
            /// Return logs from stdout
                #[serde(rename = "stdout")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stdout: Option<bool>,
            /// Return logs from stderr
                #[serde(rename = "stderr")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stderr: Option<bool>,
            /// Only return logs since this time, as a UNIX timestamp
                #[serde(rename = "since")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub since: Option<String>,
            /// Only return logs before this time, as a UNIX timestamp
                #[serde(rename = "until")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub until: Option<String>,
            /// Add timestamps to every log line
                #[serde(rename = "timestamps")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub timestamps: Option<bool>,
            /// Only return this number of log lines from the end of the logs
                #[serde(rename = "tail")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tail: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerPausePathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerPruneQueryParams {
            /// Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters:  - `until=<timestamp>` Prune containers created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.  - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune containers with (or without, in case `label!=...` is used) the specified labels.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRenamePathParams {
            /// Full or partial ID or full name of the container to rename
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRenameQueryParams {
            /// New name for the container
                #[serde(rename = "name")]
                pub name2: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerResizePathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerResizeQueryParams {
            /// Height to set for the terminal, in characters
                #[serde(rename = "h")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub h: Option<i32>,
            /// Width to set for the terminal, in characters
                #[serde(rename = "w")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub w: Option<i32>,
            /// Ignore containers not running errors
                #[serde(rename = "running")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub running: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRestartPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerRestartQueryParams {
            /// timeout before sending kill signal to container
                #[serde(rename = "t")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub t: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStartPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStartQueryParams {
            /// Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-<value> where <value> is one of: a-z, @, ^, [, , or _.
                #[serde(rename = "detachKeys")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub detach_keys: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStatsPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStatsQueryParams {
            /// Stream the output
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
            /// Provide a one-shot response in which preCPU stats are blank, resulting in a single cycle return.
                #[serde(rename = "one-shot")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub one_shot: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStopPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerStopQueryParams {
            /// number of seconds to wait before killing container
                #[serde(rename = "t")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub t: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerTopPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerTopQueryParams {
            /// arguments to pass to ps such as aux.
                #[serde(rename = "ps_args")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ps_args: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerUnpausePathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerUpdatePathParams {
            /// Full or partial ID or full name of the container to rename
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerWaitPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerWaitQueryParams {
            /// wait until container is to a given condition. default is stopped. valid conditions are:   - configured   - created   - exited   - paused   - running   - stopped
                #[serde(rename = "condition")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub condition: Option<String>,
            /// Time Interval to wait before polling for completion.
                #[serde(rename = "interval")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub interval: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageCommitQueryParams {
            /// the name or ID of a container
                #[serde(rename = "container")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub container: Option<String>,
            /// the repository name for the created image
                #[serde(rename = "repo")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub repo: Option<String>,
            /// tag name for the created image
                #[serde(rename = "tag")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tag: Option<String>,
            /// commit message
                #[serde(rename = "comment")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub comment: Option<String>,
            /// author of the image
                #[serde(rename = "author")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub author: Option<String>,
            /// pause the container before committing it
                #[serde(rename = "pause")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pause: Option<bool>,
            /// instructions to apply while committing in Dockerfile format
                #[serde(rename = "changes")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub changes: Option<String>,
            /// squash newly built layers into a single new layer
                #[serde(rename = "squash")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub squash: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PutContainerArchivePathParams {
            /// container name or id
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PutContainerArchiveQueryParams {
            /// Path to a directory in the container to extract
                #[serde(rename = "path")]
                pub path: String,
            /// if unpacking the given content would cause an existing directory to be replaced with a non-directory and vice versa (1 or true)
                #[serde(rename = "noOverwriteDirNonDir")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub no_overwrite_dir_non_dir: Option<String>,
            /// copy UID/GID maps to the dest file or di (1 or true)
                #[serde(rename = "copyUIDGID")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub copy_uidgid: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerExecLibpodPathParams {
            /// name of container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ExecInspectLibpodPathParams {
            /// Exec instance ID
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ExecResizeLibpodPathParams {
            /// Exec instance ID
                pub id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ExecResizeLibpodQueryParams {
            /// Height of the TTY session in characters
                #[serde(rename = "h")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub h: Option<i32>,
            /// Width of the TTY session in characters
                #[serde(rename = "w")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub w: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ExecStartLibpodPathParams {
            /// Exec instance ID
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerExecPathParams {
            /// name of container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ExecInspectPathParams {
            /// Exec instance ID
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ExecResizePathParams {
            /// Exec instance ID
                pub id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ExecResizeQueryParams {
            /// Height of the TTY session in characters
                #[serde(rename = "h")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub h: Option<i32>,
            /// Width of the TTY session in characters
                #[serde(rename = "w")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub w: Option<i32>,
            /// Ignore containers not running errors
                #[serde(rename = "running")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub running: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ExecStartPathParams {
            /// Exec instance ID
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageBuildLibpodQueryParams {
            /// Path within the build context to the `Dockerfile`. This is ignored if remote is specified and points to an external `Dockerfile`.
                #[serde(rename = "dockerfile")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub dockerfile: Option<String>,
            /// A name and optional tag to apply to the image in the `name:tag` format.  If you omit the tag, the default latest value is assumed. You can provide several t parameters.
                #[serde(rename = "t")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub t: Option<String>,
            /// Instead of building for a set of platforms specified using the platform option, inspect the build's base images, and build for all of the platforms that are available.  Stages that use *scratch* as a starting point can not be inspected, so at least one non-*scratch* stage must be present for detection to work usefully.
                #[serde(rename = "allplatforms")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub allplatforms: Option<bool>,
            /// TBD Extra hosts to add to /etc/hosts (As of version 1.xx)
                #[serde(rename = "extrahosts")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub extrahosts: Option<String>,
            /// A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called Dockerfile and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the dockerfile parameter is also specified, there must be a file with the corresponding path inside the tarball. (As of version 1.xx)
                #[serde(rename = "remote")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub remote: Option<String>,
            /// Suppress verbose build output
                #[serde(rename = "q")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub q: Option<bool>,
            /// Do not use the cache when building the image (As of version 1.xx)
                #[serde(rename = "nocache")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub nocache: Option<bool>,
            /// JSON array of images used to build cache resolution (As of version 1.xx)
                #[serde(rename = "cachefrom")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cachefrom: Option<String>,
            /// Attempt to pull the image even if an older image exists locally (As of version 1.xx)
                #[serde(rename = "pull")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pull: Option<bool>,
            /// Remove intermediate containers after a successful build (As of version 1.xx)
                #[serde(rename = "rm")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub rm: Option<bool>,
            /// Always remove intermediate containers, even upon failure (As of version 1.xx)
                #[serde(rename = "forcerm")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub forcerm: Option<bool>,
            /// Memory is the upper limit (in bytes) on how much memory running containers can use (As of version 1.xx)
                #[serde(rename = "memory")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub memory: Option<i32>,
            /// MemorySwap limits the amount of memory and swap together (As of version 1.xx)
                #[serde(rename = "memswap")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub memswap: Option<i32>,
            /// CPUShares (relative weight (As of version 1.xx)
                #[serde(rename = "cpushares")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cpushares: Option<i32>,
            /// CPUSetCPUs in which to allow execution (0-3, 0,1) (As of version 1.xx)
                #[serde(rename = "cpusetcpus")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cpusetcpus: Option<String>,
            /// CPUPeriod limits the CPU CFS (Completely Fair Scheduler) period (As of version 1.xx)
                #[serde(rename = "cpuperiod")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cpuperiod: Option<i32>,
            /// CPUQuota limits the CPU CFS (Completely Fair Scheduler) quota (As of version 1.xx)
                #[serde(rename = "cpuquota")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cpuquota: Option<i32>,
            /// JSON map of string pairs denoting build-time variables. For example, the build argument `Foo` with the value of `bar` would be encoded in JSON as `[\"Foo\":\"bar\"]`.  For example, buildargs={\"Foo\":\"bar\"}.  Note(s): * This should not be used to pass secrets. * The value of buildargs should be URI component encoded before being passed to the API.  (As of version 1.xx)
                #[serde(rename = "buildargs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub buildargs: Option<String>,
            /// ShmSize is the \"size\" value to use when mounting an shmfs on the container's /dev/shm directory. Default is 64MB (As of version 1.xx)
                #[serde(rename = "shmsize")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub shmsize: Option<i32>,
            /// Silently ignored. Squash the resulting images layers into a single layer (As of version 1.xx)
                #[serde(rename = "squash")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub squash: Option<bool>,
            /// JSON map of key, value pairs to set as labels on the new image (As of version 1.xx)
                #[serde(rename = "labels")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub labels: Option<String>,
            /// Add an intermediate image *label* (e.g. label=*value*) to the intermediate image metadata.
                #[serde(rename = "layerLabel")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub layer_label: Option<Vec<String>>,
            /// Cache intermediate layers during build. (As of version 1.xx)
                #[serde(rename = "layers")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub layers: Option<bool>,
            /// Sets the networking mode for the run commands during build. Supported standard values are:   * `bridge` limited to containers within a single host, port mapping required for external access   * `host` no isolation between host and containers on this network   * `none` disable all networking for this container   * container:<nameOrID> share networking with given container   ---All other values are assumed to be a custom network's name (As of version 1.xx)
                #[serde(rename = "networkmode")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub networkmode: Option<String>,
            /// Platform format os[/arch[/variant]] (As of version 1.xx)
                #[serde(rename = "platform")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub platform: Option<String>,
            /// Target build stage (As of version 1.xx)
                #[serde(rename = "target")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub target: Option<String>,
            /// output configuration TBD (As of version 1.xx)
                #[serde(rename = "outputs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub outputs: Option<String>,
            /// Inject http proxy environment variables into container (As of version 2.0.0)
                #[serde(rename = "httpproxy")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub httpproxy: Option<bool>,
            /// Unset environment variables from the final image.
                #[serde(rename = "unsetenv")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub unsetenv: Option<Vec<String>>,
            /// Unset the image label, causing the label not to be inherited from the base image.
                #[serde(rename = "unsetlabel")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub unsetlabel: Option<Vec<String>>,
            /// Extra volumes that should be mounted in the build container.
                #[serde(rename = "volume")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub volume: Option<Vec<String>>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageChangesLibpodPathParams {
            /// the name or id of the image
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageChangesLibpodQueryParams {
            /// specify a second layer which is used to compare against it instead of the parent layer
                #[serde(rename = "parent")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub parent: Option<String>,
            /// select what you want to match, default is all
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "diffType")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub diff_type: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageDeleteAllLibpodQueryParams {
            /// Images IDs or names to remove.
                #[serde(rename = "images")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub images: Option<Vec<String>>,
            /// Remove all images.
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// Force image removal (including containers using the images).
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
            /// Ignore if a specified image does not exist and do not throw an error.
                #[serde(rename = "ignore")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ignore: Option<bool>,
            /// Resolves to manifest list instead of image.
                #[serde(rename = "lookupManifest")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub lookup_manifest: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageDeleteLibpodPathParams {
            /// name or ID of image to remove
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageDeleteLibpodQueryParams {
            /// remove the image even if used by containers or has other tags
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageExistsLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageExportLibpodQueryParams {
            /// format for exported image (only docker-archive is supported)
                #[serde(rename = "format")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub format: Option<String>,
            /// references to images to export
                #[serde(rename = "references")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub references: Option<Vec<String>>,
            /// use compression on image
                #[serde(rename = "compress")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub compress: Option<bool>,
            /// accept uncompressed layers when copying OCI images
                #[serde(rename = "ociAcceptUncompressedLayers")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub oci_accept_uncompressed_layers: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageGetLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageGetLibpodQueryParams {
            /// format for exported image
                #[serde(rename = "format")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub format: Option<String>,
            /// use compression on image
                #[serde(rename = "compress")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub compress: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageHistoryLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageImportLibpodHeaderParams {
        pub content_type: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageImportLibpodQueryParams {
            /// Apply the following possible instructions to the created image: CMD | ENTRYPOINT | ENV | EXPOSE | LABEL | STOPSIGNAL | USER | VOLUME | WORKDIR.  JSON encoded string
                #[serde(rename = "changes")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub changes: Option<Vec<String>>,
            /// Set commit message for imported image
                #[serde(rename = "message")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub message: Option<String>,
            /// Optional Name[:TAG] for the image
                #[serde(rename = "reference")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub reference: Option<String>,
            /// Load image from the specified URL
                #[serde(rename = "url")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub url: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageInspectLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageListLibpodQueryParams {
            /// Show all images. Only images from a final layer (no children) are shown by default.
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters: - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`) - `dangling=true` - `label=key` or `label=\"key=value\"` of an image label - `reference`=(`<image-name>[:<tag>]`) - `id`=(`<image-id>`) - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePruneLibpodQueryParams {
            /// Remove all images not in use by containers, not just dangling ones
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// Remove images even when they are used by external containers (e.g, by build containers)
                #[serde(rename = "external")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub external: Option<bool>,
            /// filters to apply to image pruning, encoded as JSON (map[string][]string). Available filters:   - `dangling=<boolean>` When set to `true` (or `1`), prune only      unused *and* untagged images. When set to `false`      (or `0`), all unused images are pruned.   - `until=<string>` Prune images created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.   - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune images with (or without, in case `label!=...` is used) the specified labels.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePullLibpodHeaderParams {
        pub x_registry_auth: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePullLibpodQueryParams {
            /// Mandatory reference to the image (e.g., quay.io/image/name:tag)
                #[serde(rename = "reference")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub reference: Option<String>,
            /// silences extra stream data on pull
                #[serde(rename = "quiet")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub quiet: Option<bool>,
            /// Return the same JSON payload as the Docker-compat endpoint.
                #[serde(rename = "compatMode")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub compat_mode: Option<bool>,
            /// Pull image for the specified architecture.
                #[serde(rename = "Arch")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub arch: Option<String>,
            /// Pull image for the specified operating system.
                #[serde(rename = "OS")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub os: Option<String>,
            /// Pull image for the specified variant.
                #[serde(rename = "Variant")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub variant: Option<String>,
            /// Pull policy, \"always\" (default), \"missing\", \"newer\", \"never\".
                #[serde(rename = "policy")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub policy: Option<String>,
            /// Require TLS verification.
                #[serde(rename = "tlsVerify")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tls_verify: Option<bool>,
            /// Pull all tagged images in the repository.
                #[serde(rename = "allTags")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all_tags: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePushLibpodHeaderParams {
        pub x_registry_auth: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePushLibpodPathParams {
            /// Name of image to push.
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePushLibpodQueryParams {
            /// Allows for pushing the image to a different destination than the image refers to.
                #[serde(rename = "destination")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub destination: Option<String>,
            /// Enforce compressing the layers with the specified --compression and do not reuse differently compressed blobs on the registry.
                #[serde(rename = "forceCompressionFormat")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force_compression_format: Option<bool>,
            /// Require TLS verification.
                #[serde(rename = "tlsVerify")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tls_verify: Option<bool>,
            /// silences extra stream data on push
                #[serde(rename = "quiet")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub quiet: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageResolveLibpodPathParams {
            /// the (short) name to resolve
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageScpLibpodPathParams {
            /// source connection/image
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageScpLibpodQueryParams {
            /// dest connection/image
                #[serde(rename = "destination")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub destination: Option<String>,
            /// quiet output
                #[serde(rename = "quiet")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub quiet: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageSearchLibpodQueryParams {
            /// term to search
                #[serde(rename = "term")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub term: Option<String>,
            /// maximum number of results
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters: - `is-automated=(true|false)` - `is-official=(true|false)` - `stars=<number>` Matches images that have at least 'number' stars.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
            /// Require HTTPS and verify signatures when contacting registries.
                #[serde(rename = "tlsVerify")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tls_verify: Option<bool>,
            /// list the available tags in the repository
                #[serde(rename = "listTags")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub list_tags: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageTagLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageTagLibpodQueryParams {
            /// the repository to tag in
                #[serde(rename = "repo")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub repo: Option<String>,
            /// the name of the new tag
                #[serde(rename = "tag")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tag: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageTreeLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageTreeLibpodQueryParams {
            /// show all child images and layers of the specified image
                #[serde(rename = "whatrequires")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub whatrequires: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageUntagLibpodPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageUntagLibpodQueryParams {
            /// the repository to untag
                #[serde(rename = "repo")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub repo: Option<String>,
            /// the name of the tag to untag
                #[serde(rename = "tag")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tag: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageBuildHeaderParams {
        pub content_type: Option<String>,
        pub x_registry_config: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageBuildQueryParams {
            /// Path within the build context to the `Dockerfile`. This is ignored if remote is specified and points to an external `Dockerfile`.
                #[serde(rename = "dockerfile")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub dockerfile: Option<String>,
            /// A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag, the default latest value is assumed. You can provide several t parameters.
                #[serde(rename = "t")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub t: Option<String>,
            /// TBD Extra hosts to add to /etc/hosts (As of version 1.xx)
                #[serde(rename = "extrahosts")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub extrahosts: Option<String>,
            /// A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called Dockerfile and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the dockerfile parameter is also specified, there must be a file with the corresponding path inside the tarball. (As of version 1.xx)
                #[serde(rename = "remote")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub remote: Option<String>,
            /// Suppress verbose build output
                #[serde(rename = "q")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub q: Option<bool>,
            /// Do not use the cache when building the image (As of version 1.xx)
                #[serde(rename = "nocache")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub nocache: Option<bool>,
            /// JSON array of images used to build cache resolution (As of version 1.xx)
                #[serde(rename = "cachefrom")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cachefrom: Option<String>,
            /// Attempt to pull the image even if an older image exists locally (As of version 1.xx)
                #[serde(rename = "pull")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pull: Option<bool>,
            /// Remove intermediate containers after a successful build (As of version 1.xx)
                #[serde(rename = "rm")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub rm: Option<bool>,
            /// Always remove intermediate containers, even upon failure (As of version 1.xx)
                #[serde(rename = "forcerm")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub forcerm: Option<bool>,
            /// Memory is the upper limit (in bytes) on how much memory running containers can use (As of version 1.xx)
                #[serde(rename = "memory")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub memory: Option<i32>,
            /// MemorySwap limits the amount of memory and swap together (As of version 1.xx)
                #[serde(rename = "memswap")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub memswap: Option<i32>,
            /// CPUShares (relative weight (As of version 1.xx)
                #[serde(rename = "cpushares")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cpushares: Option<i32>,
            /// CPUSetCPUs in which to allow execution (0-3, 0,1) (As of version 1.xx)
                #[serde(rename = "cpusetcpus")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cpusetcpus: Option<String>,
            /// CPUPeriod limits the CPU CFS (Completely Fair Scheduler) period (As of version 1.xx)
                #[serde(rename = "cpuperiod")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cpuperiod: Option<i32>,
            /// CPUQuota limits the CPU CFS (Completely Fair Scheduler) quota (As of version 1.xx)
                #[serde(rename = "cpuquota")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub cpuquota: Option<i32>,
            /// JSON map of string pairs denoting build-time variables. For example, the build argument `Foo` with the value of `bar` would be encoded in JSON as `[\"Foo\":\"bar\"]`.  For example, buildargs={\"Foo\":\"bar\"}.  Note(s): * This should not be used to pass secrets. * The value of buildargs should be URI component encoded before being passed to the API.  (As of version 1.xx)
                #[serde(rename = "buildargs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub buildargs: Option<String>,
            /// ShmSize is the \"size\" value to use when mounting an shmfs on the container's /dev/shm directory. Default is 64MB (As of version 1.xx)
                #[serde(rename = "shmsize")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub shmsize: Option<i32>,
            /// Silently ignored. Squash the resulting images layers into a single layer (As of version 1.xx)
                #[serde(rename = "squash")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub squash: Option<bool>,
            /// JSON map of key, value pairs to set as labels on the new image (As of version 1.xx)
                #[serde(rename = "labels")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub labels: Option<String>,
            /// Sets the networking mode for the run commands during build. Supported standard values are:   * `bridge` limited to containers within a single host, port mapping required for external access   * `host` no isolation between host and containers on this network   * `none` disable all networking for this container   * container:<nameOrID> share networking with given container   ---All other values are assumed to be a custom network's name (As of version 1.xx)
                #[serde(rename = "networkmode")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub networkmode: Option<String>,
            /// Platform format os[/arch[/variant]] (As of version 1.xx)
                #[serde(rename = "platform")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub platform: Option<String>,
            /// Target build stage (As of version 1.xx)
                #[serde(rename = "target")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub target: Option<String>,
            /// output configuration TBD (As of version 1.xx)
                #[serde(rename = "outputs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub outputs: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageCreateHeaderParams {
        pub x_registry_auth: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageCreateQueryParams {
            /// Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed.
                #[serde(rename = "fromImage")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub from_image: Option<String>,
            /// Source to import. The value may be a URL from which the image can be retrieved or - to read the image from the request body. This parameter may only be used when importing an image
                #[serde(rename = "fromSrc")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub from_src: Option<String>,
            /// Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image.
                #[serde(rename = "repo")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub repo: Option<String>,
            /// Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled.
                #[serde(rename = "tag")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tag: Option<String>,
            /// Set commit message for imported image.
                #[serde(rename = "message")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub message: Option<String>,
            /// Platform in the format os[/arch[/variant]]
                #[serde(rename = "platform")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub platform: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageDeletePathParams {
            /// name or ID of image to delete
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageDeleteQueryParams {
            /// remove the image even if used by containers or has other tags
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
            /// do not remove dangling parent images
                #[serde(rename = "noprune")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub noprune: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageGetPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageGetAllQueryParams {
            /// one or more image names or IDs comma separated
                #[serde(rename = "names")]
                pub names: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageHistoryPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageInspectPathParams {
            /// the name or ID of the container
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageListQueryParams {
            /// Show all images. Only images from a final layer (no children) are shown by default.
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters: - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`) - `dangling=true` - `label=key` or `label=\"key=value\"` of an image label - `reference`=(`<image-name>[:<tag>]`) - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
            /// Not supported
                #[serde(rename = "digests")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub digests: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageLoadQueryParams {
            /// not supported
                #[serde(rename = "quiet")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub quiet: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePruneQueryParams {
            /// filters to apply to image pruning, encoded as JSON (map[string][]string). Available filters:   - `dangling=<boolean>` When set to `true` (or `1`), prune only      unused *and* untagged images. When set to `false`      (or `0`), all unused images are pruned.   - `until=<string>` Prune images created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.   - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune images with (or without, in case `label!=...` is used) the specified labels.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePushHeaderParams {
        pub x_registry_auth: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePushPathParams {
            /// Name of image to push.
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImagePushQueryParams {
            /// The tag to associate with the image on the registry.
                #[serde(rename = "tag")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tag: Option<String>,
            /// All indicates whether to push all images related to the image list
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// use compression on image
                #[serde(rename = "compress")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub compress: Option<bool>,
            /// destination name for the image being pushed
                #[serde(rename = "destination")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub destination: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageSearchQueryParams {
            /// term to search
                #[serde(rename = "term")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub term: Option<String>,
            /// maximum number of results
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters: - `is-automated=(true|false)` - `is-official=(true|false)` - `stars=<number>` Matches images that have at least 'number' stars.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
            /// Require HTTPS and verify signatures when contacting registries.
                #[serde(rename = "tlsVerify")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tls_verify: Option<bool>,
            /// list the available tags in the repository
                #[serde(rename = "listTags")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub list_tags: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageTagPathParams {
            /// the name or ID of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ImageTagQueryParams {
            /// the repository to tag in
                #[serde(rename = "repo")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub repo: Option<String>,
            /// the name of the new tag
                #[serde(rename = "tag")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tag: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestAddLibpodPathParams {
            /// the name or ID of the manifest
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestCreateLibpodPathParams {
            /// manifest list or index name to create
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestCreateLibpodQueryParams {
            /// One or more names of an image or a manifest list. Repeat parameter as needed.  Support for multiple images, as of version 4.0.0 Alias of `image` is support for compatibility with < 4.0.0 Response status code is 200 with < 4.0.0 for compatibility
                #[serde(rename = "images")]
                pub images: String,
            /// add all contents if given list
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// modify an existing list if one with the desired name already exists
                #[serde(rename = "amend")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub amend: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestDeleteLibpodPathParams {
            /// The name or ID of the  list to be deleted
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestExistsLibpodPathParams {
            /// the name or ID of the manifest list
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestInspectLibpodPathParams {
            /// the name or ID of the manifest list
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestInspectLibpodQueryParams {
            /// Require HTTPS and verify signatures when contacting registries.
                #[serde(rename = "tlsVerify")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tls_verify: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestModifyLibpodPathParams {
            /// the name or ID of the manifest
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestModifyLibpodQueryParams {
            /// Require HTTPS and verify signatures when contacting registries.
                #[serde(rename = "tlsVerify")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tls_verify: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestPushLibpodPathParams {
            /// the name or ID of the manifest list
                pub name: String,
            /// the registry for the manifest list
                pub destination: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestPushLibpodQueryParams {
            /// add existing instances with requested compression algorithms to manifest list
                #[serde(rename = "addCompression")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub add_compression: Option<Vec<String>>,
            /// Enforce compressing the layers with the specified --compression and do not reuse differently compressed blobs on the registry.
                #[serde(rename = "forceCompressionFormat")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force_compression_format: Option<bool>,
            /// push all images
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// Require HTTPS and verify signatures when contacting registries.
                #[serde(rename = "tlsVerify")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tls_verify: Option<bool>,
            /// silences extra stream data on push
                #[serde(rename = "quiet")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub quiet: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestPushV3LibpodPathParams {
            /// the name or ID of the manifest
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ManifestPushV3LibpodQueryParams {
            /// the destination for the manifest
                #[serde(rename = "destination")]
                pub destination: String,
            /// push all images
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkConnectLibpodPathParams {
            /// the name of the network
                pub name: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkDeleteLibpodPathParams {
            /// the name of the network
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkDeleteLibpodQueryParams {
            /// remove containers associated with network
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkDisconnectLibpodPathParams {
            /// the name of the network
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkExistsLibpodPathParams {
            /// the name or ID of the network
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkInspectLibpodPathParams {
            /// the name of the network
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkListLibpodQueryParams {
            /// JSON encoded value of the filters (a `map[string][]string`) to process on the network list. Available filters:   - `name=[name]` Matches network name (accepts regex).   - `id=[id]` Matches for full or partial ID.   - `driver=[driver]` Only bridge is supported.   - `label=[key]` or `label=[key=value]` Matches networks based on the presence of a label alone or a label and a value.   - `until=[timestamp]` Matches all networks that were created before the given timestamp.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkPruneLibpodQueryParams {
            /// Filters to process on the prune list, encoded as JSON (a `map[string][]string`). Available filters:   - `until=<timestamp>` Prune networks created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.   - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune networks with (or without, in case `label!=...` is used) the specified labels.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkUpdateLibpodPathParams {
            /// the name or ID of the network
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkConnectPathParams {
            /// the name of the network
                pub name: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkDeletePathParams {
            /// the name of the network
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkDisconnectPathParams {
            /// the name of the network
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkInspectPathParams {
            /// the name of the network
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkInspectQueryParams {
            /// Detailed inspect output for troubleshooting
                #[serde(rename = "verbose")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub verbose: Option<bool>,
            /// Filter the network by scope (swarm, global, or local)
                #[serde(rename = "scope")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub scope: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkListQueryParams {
            /// JSON encoded value of the filters (a `map[string][]string`) to process on the network list. Currently available filters:   - `name=[name]` Matches network name (accepts regex).   - `id=[id]` Matches for full or partial ID.   - `driver=[driver]` Only bridge is supported.   - `label=[key]` or `label=[key=value]` Matches networks based on the presence of a label alone or a label and a value.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NetworkPruneQueryParams {
            /// Filters to process on the prune list, encoded as JSON (a map[string][]string). Available filters:   - `until=<timestamp>` Prune networks created before this timestamp. The <timestamp> can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.   - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune networks with (or without, in case `label!=...` is used) the specified labels.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodDeleteLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodDeleteLibpodQueryParams {
            /// force removal of a running pod by first stopping all containers, then removing all containers in the pod
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodExistsLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodInspectLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodKillLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodKillLibpodQueryParams {
            /// signal to be sent to pod
                #[serde(rename = "signal")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub signal: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodListLibpodQueryParams {
            /// JSON encoded value of the filters (a map[string][]string) to process on the pods list. Available filters:   - `id=<pod-id>` Matches all of pod id.   - `label=<key>` or `label=<key>:<value>` Matches pods based on the presence of a label alone or a label and a value.   - `name=<pod-name>` Matches all of pod name.   - `until=<timestamp>` List pods created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.   - `status=<pod-status>` Pod's status: `stopped`, `running`, `paused`, `exited`, `dead`, `created`, `degraded`.   - `network=<pod-network>` Name or full ID of network.   - `ctr-names=<pod-ctr-names>` Container name within the pod.   - `ctr-ids=<pod-ctr-ids>` Container ID within the pod.   - `ctr-status=<pod-ctr-status>` Container status within the pod.   - `ctr-number=<pod-ctr-number>` Number of containers in the pod.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodPauseLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodRestartLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodStartLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodStatsAllLibpodQueryParams {
            /// Provide statistics for all running pods.
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
            /// Names or IDs of pods.
                #[serde(rename = "namesOrIDs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub names_or_ids: Option<Vec<String>>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodStopLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodStopLibpodQueryParams {
            /// timeout
                #[serde(rename = "t")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub t: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodTopLibpodPathParams {
            /// Name of pod to query for processes
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodTopLibpodQueryParams {
            /// when true, repeatedly stream the latest output (As of version 4.0)
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
            /// if streaming, delay in seconds between updates. Must be >1. (As of version 4.0)
                #[serde(rename = "delay")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub delay: Option<i32>,
            /// arguments to pass to ps such as aux.
                #[serde(rename = "ps_args")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ps_args: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PodUnpauseLibpodPathParams {
            /// the name or ID of the pod
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretCreateLibpodQueryParams {
            /// User-defined name of the secret.
                #[serde(rename = "name")]
                pub name: String,
            /// Secret driver
                #[serde(rename = "driver")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub driver: Option<String>,
            /// Secret driver options
                #[serde(rename = "driveropts")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub driveropts: Option<String>,
            /// Labels on the secret
                #[serde(rename = "labels")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub labels: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretDeleteLibpodPathParams {
            /// the name or ID of the secret
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretDeleteLibpodQueryParams {
            /// Remove all secrets
                #[serde(rename = "all")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub all: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretExistsLibpodPathParams {
            /// the name or ID of the secret
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretInspectLibpodPathParams {
            /// the name or ID of the secret
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretInspectLibpodQueryParams {
            /// Display Secret
                #[serde(rename = "showsecret")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub showsecret: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretListLibpodQueryParams {
            /// JSON encoded value of the filters (a `map[string][]string`) to process on the secrets list. Currently available filters:   - `name=[name]` Matches secrets name (accepts regex).   - `id=[id]` Matches for full or partial ID.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretDeletePathParams {
            /// the name or ID of the secret
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretInspectPathParams {
            /// the name or ID of the secret
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SecretListQueryParams {
            /// JSON encoded value of the filters (a `map[string][]string`) to process on the secrets list. Currently available filters:   - `name=[name]` Matches secrets name (accepts regex).   - `id=[id]` Matches for full or partial ID.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SystemCheckLibpodQueryParams {
            /// Skip time-consuming checks
                #[serde(rename = "quick")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub quick: Option<bool>,
            /// Remove inconsistent images
                #[serde(rename = "repair")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub repair: Option<bool>,
            /// Remove inconsistent containers and images
                #[serde(rename = "repair_lossy")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub repair_lossy: Option<bool>,
            /// Maximum allowed age of unreferenced layers
                #[serde(rename = "unreferenced_layer_max_age")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub unreferenced_layer_max_age: Option<String>,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SystemEventsLibpodQueryParams {
            /// start streaming events from this time
                #[serde(rename = "since")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub since: Option<String>,
            /// stop streaming events later than this
                #[serde(rename = "until")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub until: Option<String>,
            /// JSON encoded map[string][]string of constraints
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
            /// when false, do not follow events
                #[serde(rename = "stream")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stream: Option<bool>,
    }







    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SystemEventsQueryParams {
            /// start streaming events from this time
                #[serde(rename = "since")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub since: Option<String>,
            /// stop streaming events later than this
                #[serde(rename = "until")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub until: Option<String>,
            /// JSON encoded map[string][]string of constraints
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }





    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeDeleteLibpodPathParams {
            /// the name or ID of the volume
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeDeleteLibpodQueryParams {
            /// force removal
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeExistsLibpodPathParams {
            /// the name of the volume
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeInspectLibpodPathParams {
            /// the name or ID of the volume
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeListLibpodQueryParams {
            /// JSON encoded value of the filters (a map[string][]string) to process on the volumes list. Available filters:   - driver=<volume-driver-name> Matches volumes based on their driver.   - label=<key> or label=<key>:<value> Matches volumes based on the presence of a label alone or a label and a value.   - name=<volume-name> Matches all of volume name.   - opt=<driver-option> Matches a storage driver options   - `until=<timestamp>` List volumes created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumePruneLibpodQueryParams {
            /// JSON encoded value of filters (a map[string][]string) to match volumes against before pruning. Available filters:   - `until=<timestamp>` Prune volumes created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.   - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune volumes with (or without, in case `label!=...` is used) the specified labels.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeDeletePathParams {
            /// the name or ID of the volume
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeDeleteQueryParams {
            /// Force removal of the volume. This actually only causes errors due to the names volume not being found to be suppressed, which is the behaviour Docker implements.
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeInspectPathParams {
            /// the name or ID of the volume
                pub name: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumeListQueryParams {
            /// JSON encoded value of the filters (a map[string][]string) to process on the volumes list. Available filters:   - driver=<volume-driver-name> Matches volumes based on their driver.   - label=<key> or label=<key>:<value> Matches volumes based on the presence of a label alone or a label and a value.   - name=<volume-name> Matches all of volume name.   - `until=<timestamp>` List volumes created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.  Note:   The boolean `dangling` filter is not yet implemented for this endpoint.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VolumePruneQueryParams {
            /// JSON encoded value of filters (a map[string][]string) to match volumes against before pruning. Available filters:   - `until=<timestamp>` Prune volumes created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time.   - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune volumes with (or without, in case `label!=...` is used) the specified labels.
                #[serde(rename = "filters")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub filters: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerChangesLibpodPathParams {
            /// the name or id of the container
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContainerChangesLibpodQueryParams {
            /// specify a second layer which is used to compare against it instead of the parent layer
                #[serde(rename = "parent")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub parent: Option<String>,
            /// select what you want to match, default is all
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "diffType")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub diff_type: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GenerateKubeLibpodQueryParams {
            /// Name or ID of the container or pod.
                #[serde(rename = "names")]
                pub names: Vec<String>,
            /// Generate YAML for a Kubernetes service object.
                #[serde(rename = "service")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub service: Option<bool>,
            /// Generate YAML for the given Kubernetes kind.
                #[serde(rename = "type")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub r#type: Option<String>,
            /// Set the replica number for Deployment kind.
                #[serde(rename = "replicas")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub replicas: Option<i32>,
            /// don't truncate annotations to the Kubernetes maximum length of 63 characters
                #[serde(rename = "noTrunc")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub no_trunc: Option<bool>,
            /// add podman-only reserved annotations in generated YAML file (cannot be used by Kubernetes)
                #[serde(rename = "podmanOnly")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub podman_only: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GenerateSystemdLibpodPathParams {
            /// Name or ID of the container or pod.
                pub name: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GenerateSystemdLibpodQueryParams {
            /// Use container/pod names instead of IDs.
                #[serde(rename = "useName")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub use_name: Option<bool>,
            /// Create a new container instead of starting an existing one.
                #[serde(rename = "new")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub new: Option<bool>,
            /// Do not generate the header including the Podman version and the timestamp.
                #[serde(rename = "noHeader")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub no_header: Option<bool>,
            /// Start timeout in seconds.
                #[serde(rename = "startTimeout")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub start_timeout: Option<i32>,
            /// Stop timeout in seconds.
                #[serde(rename = "stopTimeout")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub stop_timeout: Option<i32>,
            /// Systemd restart-policy.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "restartPolicy")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub restart_policy: Option<String>,
            /// Systemd unit name prefix for containers.
                #[serde(rename = "containerPrefix")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub container_prefix: Option<String>,
            /// Systemd unit name prefix for pods.
                #[serde(rename = "podPrefix")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub pod_prefix: Option<String>,
            /// Systemd unit name separator between name/id and prefix.
                #[serde(rename = "separator")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub separator: Option<String>,
            /// Configures the time to sleep before restarting a service.
                #[serde(rename = "restartSec")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub restart_sec: Option<i32>,
            /// Systemd Wants list for the container or pods.
                #[serde(rename = "wants")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub wants: Option<Vec<String>>,
            /// Systemd After list for the container or pods.
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<Vec<String>>,
            /// Systemd Requires list for the container or pods.
                #[serde(rename = "requires")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub requires: Option<Vec<String>>,
            /// Set environment variables to the systemd unit files.
                #[serde(rename = "additionalEnvVariables")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub additional_env_variables: Option<Vec<String>>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct KubeApplyLibpodQueryParams {
            /// Path to the CA cert file for the Kubernetes cluster.
                #[serde(rename = "caCertFile")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub ca_cert_file: Option<String>,
            /// Path to the kubeconfig file for the Kubernetes cluster.
                #[serde(rename = "kubeConfig")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub kube_config: Option<String>,
            /// The namespace to deploy the workload to on the Kubernetes cluster.
                #[serde(rename = "namespace")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub namespace: Option<String>,
            /// Create a service object for the container being deployed.
                #[serde(rename = "service")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub service: Option<bool>,
            /// Path to the Kubernetes yaml file to deploy.
                #[serde(rename = "file")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub file: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PlayKubeDownLibpodQueryParams {
            /// Remove volumes.
                #[serde(rename = "force")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub force: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PlayKubeLibpodQueryParams {
            /// JSON encoded value of annotations (a map[string]string).
                #[serde(rename = "annotations")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub annotations: Option<String>,
            /// Logging driver for the containers in the pod.
                #[serde(rename = "logDriver")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub log_driver: Option<String>,
            /// logging driver options
                #[serde(rename = "logOptions")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub log_options: Option<Vec<String>>,
            /// USe the network mode or specify an array of networks.
                #[serde(rename = "network")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub network: Option<Vec<String>>,
            /// do not setup /etc/hosts file in container
                #[serde(rename = "noHosts")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub no_hosts: Option<bool>,
            /// use annotations that are not truncated to the Kubernetes maximum length of 63 characters
                #[serde(rename = "noTrunc")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub no_trunc: Option<bool>,
            /// publish a container's port, or a range of ports, to the host
                #[serde(rename = "publishPorts")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub publish_ports: Option<Vec<String>>,
            /// Whether to publish all ports defined in the K8S YAML file (containerPort, hostPort), if false only hostPort will be published
                #[serde(rename = "publishAllPorts")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub publish_all_ports: Option<bool>,
            /// replace existing pods and containers
                #[serde(rename = "replace")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub replace: Option<bool>,
            /// Starts a service container before all pods.
                #[serde(rename = "serviceContainer")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub service_container: Option<bool>,
            /// Start the pod after creating it.
                #[serde(rename = "start")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub start: Option<bool>,
            /// Static IPs used for the pods.
                #[serde(rename = "staticIPs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub static_ips: Option<Vec<String>>,
            /// Static MACs used for the pods.
                #[serde(rename = "staticMACs")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub static_macs: Option<Vec<String>>,
            /// Require HTTPS and verify signatures when contacting registries.
                #[serde(rename = "tlsVerify")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub tls_verify: Option<bool>,
            /// Set the user namespace mode for the pods.
                #[serde(rename = "userns")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub userns: Option<String>,
            /// Clean up all objects created when a SIGTERM is received or pods exit.
                #[serde(rename = "wait")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub wait: Option<bool>,
    }







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AccessMode {
/// Intentionally empty.
    #[serde(rename = "BlockVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_volume: Option<crate::types::Object>,

    #[serde(rename = "MountVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mount_volume: Option<models::TypeMount>,

/// Scope defines the Scope of a Cluster Volume. This is how many nodes a Volume can be accessed simultaneously on.
    #[serde(rename = "Scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

/// SharingMode defines the Sharing of a Cluster Volume. This is how Tasks using a Volume at the same time can use it.
    #[serde(rename = "Sharing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sharing: Option<String>,

}


impl AccessMode {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AccessMode {
        AccessMode {
            block_volume: None,
            mount_volume: None,
            scope: None,
            sharing: None,
        }
    }
}

/// Converts the AccessMode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AccessMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping BlockVolume in query parameter serialization

            // Skipping MountVolume in query parameter serialization


            self.scope.as_ref().map(|scope| {
                [
                    "Scope".to_string(),
                    scope.to_string(),
                ].join(",")
            }),


            self.sharing.as_ref().map(|sharing| {
                [
                    "Sharing".to_string(),
                    sharing.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AccessMode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AccessMode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub block_volume: Vec<crate::types::Object>,
            pub mount_volume: Vec<models::TypeMount>,
            pub scope: Vec<String>,
            pub sharing: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AccessMode".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "BlockVolume" => intermediate_rep.block_volume.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MountVolume" => intermediate_rep.mount_volume.push(<models::TypeMount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Sharing" => intermediate_rep.sharing.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AccessMode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AccessMode {
            block_volume: intermediate_rep.block_volume.into_iter().next(),
            mount_volume: intermediate_rep.mount_volume.into_iter().next(),
            scope: intermediate_rep.scope.into_iter().next(),
            sharing: intermediate_rep.sharing.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AccessMode> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AccessMode>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AccessMode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AccessMode - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AccessMode> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AccessMode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AccessMode - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Address {
    #[serde(rename = "Addr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub addr: Option<String>,

    #[serde(rename = "PrefixLength")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prefix_length: Option<i64>,

}


impl Address {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Address {
        Address {
            addr: None,
            prefix_length: None,
        }
    }
}

/// Converts the Address value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.addr.as_ref().map(|addr| {
                [
                    "Addr".to_string(),
                    addr.to_string(),
                ].join(",")
            }),


            self.prefix_length.as_ref().map(|prefix_length| {
                [
                    "PrefixLength".to_string(),
                    prefix_length.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Address value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Address {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub addr: Vec<String>,
            pub prefix_length: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Address".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Addr" => intermediate_rep.addr.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PrefixLength" => intermediate_rep.prefix_length.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Address".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Address {
            addr: intermediate_rep.addr.into_iter().next(),
            prefix_length: intermediate_rep.prefix_length.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Address> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Address>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Address>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Address - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Address> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Address as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Address - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// AuthConfig contains authorization information for connecting to a Registry



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthConfig {
    #[serde(rename = "auth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auth: Option<String>,

/// Email is an optional value associated with the username. This field is deprecated and will be removed in a later version of docker.
    #[serde(rename = "email")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,

/// IdentityToken is used to authenticate the user and get an access token for the registry.
    #[serde(rename = "identitytoken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub identitytoken: Option<String>,

    #[serde(rename = "password")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub password: Option<String>,

/// RegistryToken is a bearer token to be sent to a registry
    #[serde(rename = "registrytoken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub registrytoken: Option<String>,

    #[serde(rename = "serveraddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub serveraddress: Option<String>,

    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

}


impl AuthConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuthConfig {
        AuthConfig {
            auth: None,
            email: None,
            identitytoken: None,
            password: None,
            registrytoken: None,
            serveraddress: None,
            username: None,
        }
    }
}

/// Converts the AuthConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.auth.as_ref().map(|auth| {
                [
                    "auth".to_string(),
                    auth.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),


            self.identitytoken.as_ref().map(|identitytoken| {
                [
                    "identitytoken".to_string(),
                    identitytoken.to_string(),
                ].join(",")
            }),


            self.password.as_ref().map(|password| {
                [
                    "password".to_string(),
                    password.to_string(),
                ].join(",")
            }),


            self.registrytoken.as_ref().map(|registrytoken| {
                [
                    "registrytoken".to_string(),
                    registrytoken.to_string(),
                ].join(",")
            }),


            self.serveraddress.as_ref().map(|serveraddress| {
                [
                    "serveraddress".to_string(),
                    serveraddress.to_string(),
                ].join(",")
            }),


            self.username.as_ref().map(|username| {
                [
                    "username".to_string(),
                    username.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auth: Vec<String>,
            pub email: Vec<String>,
            pub identitytoken: Vec<String>,
            pub password: Vec<String>,
            pub registrytoken: Vec<String>,
            pub serveraddress: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "auth" => intermediate_rep.auth.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "identitytoken" => intermediate_rep.identitytoken.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "registrytoken" => intermediate_rep.registrytoken.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serveraddress" => intermediate_rep.serveraddress.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthConfig {
            auth: intermediate_rep.auth.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
            identitytoken: intermediate_rep.identitytoken.into_iter().next(),
            password: intermediate_rep.password.into_iter().next(),
            registrytoken: intermediate_rep.registrytoken.into_iter().next(),
            serveraddress: intermediate_rep.serveraddress.into_iter().next(),
            username: intermediate_rep.username.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuthConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// AuthReport describes the response for authentication check



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthReport {
    #[serde(rename = "IdentityToken")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub identity_token: Option<String>,

    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl AuthReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuthReport {
        AuthReport {
            identity_token: None,
            status: None,
        }
    }
}

/// Converts the AuthReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuthReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.identity_token.as_ref().map(|identity_token| {
                [
                    "IdentityToken".to_string(),
                    identity_token.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub identity_token: Vec<String>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IdentityToken" => intermediate_rep.identity_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthReport {
            identity_token: intermediate_rep.identity_token.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuthReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// AuthenticateOKBody authenticate o k body



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuthenticateOkBody {
/// An opaque token used to authenticate a user after a successful login
    #[serde(rename = "IdentityToken")]
    pub identity_token: String,

/// The status of the authentication
    #[serde(rename = "Status")]
    pub status: String,

}


impl AuthenticateOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(identity_token: String, status: String, ) -> AuthenticateOkBody {
        AuthenticateOkBody {
            identity_token,
            status,
        }
    }
}

/// Converts the AuthenticateOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuthenticateOkBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("IdentityToken".to_string()),
            Some(self.identity_token.to_string()),


            Some("Status".to_string()),
            Some(self.status.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuthenticateOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuthenticateOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub identity_token: Vec<String>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuthenticateOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IdentityToken" => intermediate_rep.identity_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuthenticateOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuthenticateOkBody {
            identity_token: intermediate_rep.identity_token.into_iter().next().ok_or_else(|| "IdentityToken missing in AuthenticateOkBody".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "Status missing in AuthenticateOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuthenticateOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuthenticateOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuthenticateOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AuthenticateOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuthenticateOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuthenticateOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AuthenticateOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AutoUserNsOptions {
/// AdditionalGIDMappings specified additional GID mappings to include in the generated user namespace.
    #[serde(rename = "AdditionalGIDMappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_gid_mappings: Option<Vec<models::IdMap>>,

/// AdditionalUIDMappings specified additional UID mappings to include in the generated user namespace.
    #[serde(rename = "AdditionalUIDMappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_uid_mappings: Option<Vec<models::IdMap>>,

/// GroupFile to use if the container uses a volume.
    #[serde(rename = "GroupFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_file: Option<String>,

/// InitialSize defines the minimum size for the user namespace. The created user namespace will have at least this size.
    #[serde(rename = "InitialSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub initial_size: Option<i32>,

/// PasswdFile to use if the container uses a volume.
    #[serde(rename = "PasswdFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub passwd_file: Option<String>,

/// Size defines the size for the user namespace.  If it is set to a value bigger than 0, the user namespace will have exactly this size. If it is not set, some heuristics will be used to find its size.
    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i32>,

}


impl AutoUserNsOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AutoUserNsOptions {
        AutoUserNsOptions {
            additional_gid_mappings: None,
            additional_uid_mappings: None,
            group_file: None,
            initial_size: None,
            passwd_file: None,
            size: None,
        }
    }
}

/// Converts the AutoUserNsOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AutoUserNsOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping AdditionalGIDMappings in query parameter serialization

            // Skipping AdditionalUIDMappings in query parameter serialization


            self.group_file.as_ref().map(|group_file| {
                [
                    "GroupFile".to_string(),
                    group_file.to_string(),
                ].join(",")
            }),


            self.initial_size.as_ref().map(|initial_size| {
                [
                    "InitialSize".to_string(),
                    initial_size.to_string(),
                ].join(",")
            }),


            self.passwd_file.as_ref().map(|passwd_file| {
                [
                    "PasswdFile".to_string(),
                    passwd_file.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AutoUserNsOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AutoUserNsOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub additional_gid_mappings: Vec<Vec<models::IdMap>>,
            pub additional_uid_mappings: Vec<Vec<models::IdMap>>,
            pub group_file: Vec<String>,
            pub initial_size: Vec<i32>,
            pub passwd_file: Vec<String>,
            pub size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AutoUserNsOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "AdditionalGIDMappings" => return std::result::Result::Err("Parsing a container in this style is not supported in AutoUserNsOptions".to_string()),
                    "AdditionalUIDMappings" => return std::result::Result::Err("Parsing a container in this style is not supported in AutoUserNsOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "GroupFile" => intermediate_rep.group_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "InitialSize" => intermediate_rep.initial_size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PasswdFile" => intermediate_rep.passwd_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AutoUserNsOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AutoUserNsOptions {
            additional_gid_mappings: intermediate_rep.additional_gid_mappings.into_iter().next(),
            additional_uid_mappings: intermediate_rep.additional_uid_mappings.into_iter().next(),
            group_file: intermediate_rep.group_file.into_iter().next(),
            initial_size: intermediate_rep.initial_size.into_iter().next(),
            passwd_file: intermediate_rep.passwd_file.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AutoUserNsOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AutoUserNsOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AutoUserNsOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AutoUserNsOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AutoUserNsOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AutoUserNsOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AutoUserNsOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Availability(String);

impl validator::Validate for Availability {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Availability {
    fn from(x: String) -> Self {
        Availability(x)
    }
}

impl std::fmt::Display for Availability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for Availability {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Availability(x.to_string()))
    }
}

impl std::convert::From<Availability> for String {
    fn from(x: Availability) -> Self {
        x.0
    }
}

impl std::ops::Deref for Availability {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Availability {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BindOptions {
    #[serde(rename = "CreateMountpoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_mountpoint: Option<bool>,

    #[serde(rename = "NonRecursive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub non_recursive: Option<bool>,

    #[serde(rename = "Propagation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub propagation: Option<String>,

/// ReadOnlyForceRecursive raises an error if the mount cannot be made recursively read-only.
    #[serde(rename = "ReadOnlyForceRecursive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only_force_recursive: Option<bool>,

/// ReadOnlyNonRecursive makes the mount non-recursively read-only, but still leaves the mount recursive (unless NonRecursive is set to true in conjunction).
    #[serde(rename = "ReadOnlyNonRecursive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only_non_recursive: Option<bool>,

}


impl BindOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BindOptions {
        BindOptions {
            create_mountpoint: None,
            non_recursive: None,
            propagation: None,
            read_only_force_recursive: None,
            read_only_non_recursive: None,
        }
    }
}

/// Converts the BindOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BindOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.create_mountpoint.as_ref().map(|create_mountpoint| {
                [
                    "CreateMountpoint".to_string(),
                    create_mountpoint.to_string(),
                ].join(",")
            }),


            self.non_recursive.as_ref().map(|non_recursive| {
                [
                    "NonRecursive".to_string(),
                    non_recursive.to_string(),
                ].join(",")
            }),


            self.propagation.as_ref().map(|propagation| {
                [
                    "Propagation".to_string(),
                    propagation.to_string(),
                ].join(",")
            }),


            self.read_only_force_recursive.as_ref().map(|read_only_force_recursive| {
                [
                    "ReadOnlyForceRecursive".to_string(),
                    read_only_force_recursive.to_string(),
                ].join(",")
            }),


            self.read_only_non_recursive.as_ref().map(|read_only_non_recursive| {
                [
                    "ReadOnlyNonRecursive".to_string(),
                    read_only_non_recursive.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BindOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BindOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub create_mountpoint: Vec<bool>,
            pub non_recursive: Vec<bool>,
            pub propagation: Vec<String>,
            pub read_only_force_recursive: Vec<bool>,
            pub read_only_non_recursive: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BindOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CreateMountpoint" => intermediate_rep.create_mountpoint.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NonRecursive" => intermediate_rep.non_recursive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Propagation" => intermediate_rep.propagation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ReadOnlyForceRecursive" => intermediate_rep.read_only_force_recursive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ReadOnlyNonRecursive" => intermediate_rep.read_only_non_recursive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BindOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BindOptions {
            create_mountpoint: intermediate_rep.create_mountpoint.into_iter().next(),
            non_recursive: intermediate_rep.non_recursive.into_iter().next(),
            propagation: intermediate_rep.propagation.into_iter().next(),
            read_only_force_recursive: intermediate_rep.read_only_force_recursive.into_iter().next(),
            read_only_non_recursive: intermediate_rep.read_only_non_recursive.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BindOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BindOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BindOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BindOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BindOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BindOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BindOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// CapacityRange describes the minimum and maximum capacity a volume should be created with



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CapacityRange {
/// LimitBytes specifies that a volume must not be bigger than this. The value of 0 indicates an unspecified maximum
    #[serde(rename = "LimitBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit_bytes: Option<i64>,

/// RequiredBytes specifies that a volume must be at least this big. The value of 0 indicates an unspecified minimum.
    #[serde(rename = "RequiredBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_bytes: Option<i64>,

}


impl CapacityRange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CapacityRange {
        CapacityRange {
            limit_bytes: None,
            required_bytes: None,
        }
    }
}

/// Converts the CapacityRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CapacityRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.limit_bytes.as_ref().map(|limit_bytes| {
                [
                    "LimitBytes".to_string(),
                    limit_bytes.to_string(),
                ].join(",")
            }),


            self.required_bytes.as_ref().map(|required_bytes| {
                [
                    "RequiredBytes".to_string(),
                    required_bytes.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CapacityRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CapacityRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub limit_bytes: Vec<i64>,
            pub required_bytes: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CapacityRange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "LimitBytes" => intermediate_rep.limit_bytes.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RequiredBytes" => intermediate_rep.required_bytes.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CapacityRange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CapacityRange {
            limit_bytes: intermediate_rep.limit_bytes.into_iter().next(),
            required_bytes: intermediate_rep.required_bytes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CapacityRange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CapacityRange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CapacityRange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CapacityRange - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CapacityRange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CapacityRange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CapacityRange - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CgroupSpec(String);

impl validator::Validate for CgroupSpec {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for CgroupSpec {
    fn from(x: String) -> Self {
        CgroupSpec(x)
    }
}

impl std::fmt::Display for CgroupSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for CgroupSpec {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CgroupSpec(x.to_string()))
    }
}

impl std::convert::From<CgroupSpec> for String {
    fn from(x: CgroupSpec) -> Self {
        x.0
    }
}

impl std::ops::Deref for CgroupSpec {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CgroupSpec {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// CgroupnsMode represents the cgroup namespace mode of the container
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CgroupnsMode(String);

impl validator::Validate for CgroupnsMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for CgroupnsMode {
    fn from(x: String) -> Self {
        CgroupnsMode(x)
    }
}

impl std::fmt::Display for CgroupnsMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for CgroupnsMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(CgroupnsMode(x.to_string()))
    }
}

impl std::convert::From<CgroupnsMode> for String {
    fn from(x: CgroupnsMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for CgroupnsMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for CgroupnsMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Can be one of:  `0`: Modified (\"C\") `1`: Added (\"A\") `2`: Deleted (\"D\")
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChangeType(i32);

impl validator::Validate for ChangeType {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<i32> for ChangeType {
    fn from(x: i32) -> Self {
        ChangeType(x)
    }
}

impl std::convert::From<ChangeType> for i32 {
    fn from(x: ChangeType) -> Self {
        x.0
    }
}

impl std::ops::Deref for ChangeType {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for ChangeType {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}



/// ClusterVolume contains options and information specific to, and only present on, Swarm CSI cluster volumes.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ClusterVolume {
    #[serde(rename = "CreatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

/// ID is the Swarm ID of the volume. Because cluster volumes are Swarm objects, they have an ID, unlike non-cluster volumes, which only have a Name. This ID can be used to refer to the cluster volume.
    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Info")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub info: Option<models::Info>,

/// PublishStatus contains the status of the volume as it pertains to its publishing on Nodes.
    #[serde(rename = "PublishStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_status: Option<Vec<models::PublishStatus>>,

    #[serde(rename = "Spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spec: Option<models::ClusterVolumeSpec>,

    #[serde(rename = "UpdatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<models::Version>,

}


impl ClusterVolume {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ClusterVolume {
        ClusterVolume {
            created_at: None,
            id: None,
            info: None,
            publish_status: None,
            spec: None,
            updated_at: None,
            version: None,
        }
    }
}

/// Converts the ClusterVolume value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ClusterVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CreatedAt in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping Info in query parameter serialization

            // Skipping PublishStatus in query parameter serialization

            // Skipping Spec in query parameter serialization

            // Skipping UpdatedAt in query parameter serialization

            // Skipping Version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ClusterVolume value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ClusterVolume {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub info: Vec<models::Info>,
            pub publish_status: Vec<Vec<models::PublishStatus>>,
            pub spec: Vec<models::ClusterVolumeSpec>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub version: Vec<models::Version>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ClusterVolume".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CreatedAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Info" => intermediate_rep.info.push(<models::Info as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "PublishStatus" => return std::result::Result::Err("Parsing a container in this style is not supported in ClusterVolume".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Spec" => intermediate_rep.spec.push(<models::ClusterVolumeSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UpdatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Version" => intermediate_rep.version.push(<models::Version as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ClusterVolume".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ClusterVolume {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            info: intermediate_rep.info.into_iter().next(),
            publish_status: intermediate_rep.publish_status.into_iter().next(),
            spec: intermediate_rep.spec.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ClusterVolume> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ClusterVolume>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ClusterVolume>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ClusterVolume - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ClusterVolume> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ClusterVolume as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ClusterVolume - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ClusterVolumeSpec {
    #[serde(rename = "AccessMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_mode: Option<models::AccessMode>,

    #[serde(rename = "AccessibilityRequirements")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accessibility_requirements: Option<models::TopologyRequirement>,

    #[serde(rename = "Availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability: Option<String>,

    #[serde(rename = "CapacityRange")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub capacity_range: Option<models::CapacityRange>,

/// Group defines the volume group of this volume. Volumes belonging to the same group can be referred to by group name when creating Services. Referring to a volume by group instructs swarm to treat volumes in that group interchangeably for the purpose of scheduling. Volumes with an empty string for a group technically all belong to the same, emptystring group.
    #[serde(rename = "Group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group: Option<String>,

/// Secrets defines Swarm Secrets that are passed to the CSI storage plugin when operating on this volume.
    #[serde(rename = "Secrets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<models::Secret>>,

}


impl ClusterVolumeSpec {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ClusterVolumeSpec {
        ClusterVolumeSpec {
            access_mode: None,
            accessibility_requirements: None,
            availability: None,
            capacity_range: None,
            group: None,
            secrets: None,
        }
    }
}

/// Converts the ClusterVolumeSpec value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ClusterVolumeSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping AccessMode in query parameter serialization

            // Skipping AccessibilityRequirements in query parameter serialization


            self.availability.as_ref().map(|availability| {
                [
                    "Availability".to_string(),
                    availability.to_string(),
                ].join(",")
            }),

            // Skipping CapacityRange in query parameter serialization


            self.group.as_ref().map(|group| {
                [
                    "Group".to_string(),
                    group.to_string(),
                ].join(",")
            }),

            // Skipping Secrets in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ClusterVolumeSpec value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ClusterVolumeSpec {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub access_mode: Vec<models::AccessMode>,
            pub accessibility_requirements: Vec<models::TopologyRequirement>,
            pub availability: Vec<String>,
            pub capacity_range: Vec<models::CapacityRange>,
            pub group: Vec<String>,
            pub secrets: Vec<Vec<models::Secret>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ClusterVolumeSpec".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AccessMode" => intermediate_rep.access_mode.push(<models::AccessMode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AccessibilityRequirements" => intermediate_rep.accessibility_requirements.push(<models::TopologyRequirement as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Availability" => intermediate_rep.availability.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CapacityRange" => intermediate_rep.capacity_range.push(<models::CapacityRange as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Group" => intermediate_rep.group.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Secrets" => return std::result::Result::Err("Parsing a container in this style is not supported in ClusterVolumeSpec".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ClusterVolumeSpec".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ClusterVolumeSpec {
            access_mode: intermediate_rep.access_mode.into_iter().next(),
            accessibility_requirements: intermediate_rep.accessibility_requirements.into_iter().next(),
            availability: intermediate_rep.availability.into_iter().next(),
            capacity_range: intermediate_rep.capacity_range.into_iter().next(),
            group: intermediate_rep.group.into_iter().next(),
            secrets: intermediate_rep.secrets.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ClusterVolumeSpec> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ClusterVolumeSpec>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ClusterVolumeSpec>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ClusterVolumeSpec - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ClusterVolumeSpec> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ClusterVolumeSpec as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ClusterVolumeSpec - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ComponentVersion {
    #[serde(rename = "Details")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl ComponentVersion {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ComponentVersion {
        ComponentVersion {
            details: None,
            name: None,
            version: None,
        }
    }
}

/// Converts the ComponentVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ComponentVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Details in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "Version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ComponentVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ComponentVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub details: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ComponentVersion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Details" => return std::result::Result::Err("Parsing a container in this style is not supported in ComponentVersion".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ComponentVersion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ComponentVersion {
            details: intermediate_rep.details.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ComponentVersion> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ComponentVersion>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ComponentVersion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ComponentVersion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ComponentVersion> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ComponentVersion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ComponentVersion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// It should hold only portable information about the container. Here, \"portable\" means \"independent from the host we are running on\". Non-portable information *should* appear in HostConfig. All fields added to this struct must be marked `omitempty` to keep getting predictable hashes from the old `v1Compatibility` configuration.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Config {
    #[serde(rename = "ArgsEscaped")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args_escaped: Option<bool>,

    #[serde(rename = "AttachStderr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stderr: Option<bool>,

    #[serde(rename = "AttachStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdin: Option<bool>,

    #[serde(rename = "AttachStdout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdout: Option<bool>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Cmd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cmd: Option<Vec<String>>,

    #[serde(rename = "Domainname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub domainname: Option<String>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Entrypoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrypoint: Option<Vec<String>>,

    #[serde(rename = "Env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<String>>,

/// PortSet is a collection of structs indexed by Port
    #[serde(rename = "ExposedPorts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exposed_ports: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "Healthcheck")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healthcheck: Option<models::HealthcheckConfig>,

    #[serde(rename = "Hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// Mac Address of the container.  Deprecated: this field is deprecated since API v1.44. Use EndpointSettings.MacAddress instead.
    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

    #[serde(rename = "NetworkDisabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_disabled: Option<bool>,

    #[serde(rename = "OnBuild")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_build: Option<Vec<String>>,

    #[serde(rename = "OpenStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_stdin: Option<bool>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Shell")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shell: Option<Vec<String>>,

    #[serde(rename = "StdinOnce")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin_once: Option<bool>,

    #[serde(rename = "StopSignal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_signal: Option<String>,

    #[serde(rename = "StopTimeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_timeout: Option<i64>,

    #[serde(rename = "Tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

    #[serde(rename = "Volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "WorkingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

}


impl Config {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Config {
        Config {
            args_escaped: None,
            attach_stderr: None,
            attach_stdin: None,
            attach_stdout: None,
            cmd: None,
            domainname: None,
            entrypoint: None,
            env: None,
            exposed_ports: None,
            healthcheck: None,
            hostname: None,
            image: None,
            labels: None,
            mac_address: None,
            network_disabled: None,
            on_build: None,
            open_stdin: None,
            shell: None,
            stdin_once: None,
            stop_signal: None,
            stop_timeout: None,
            tty: None,
            user: None,
            volumes: None,
            working_dir: None,
        }
    }
}

/// Converts the Config value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Config {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.args_escaped.as_ref().map(|args_escaped| {
                [
                    "ArgsEscaped".to_string(),
                    args_escaped.to_string(),
                ].join(",")
            }),


            self.attach_stderr.as_ref().map(|attach_stderr| {
                [
                    "AttachStderr".to_string(),
                    attach_stderr.to_string(),
                ].join(",")
            }),


            self.attach_stdin.as_ref().map(|attach_stdin| {
                [
                    "AttachStdin".to_string(),
                    attach_stdin.to_string(),
                ].join(",")
            }),


            self.attach_stdout.as_ref().map(|attach_stdout| {
                [
                    "AttachStdout".to_string(),
                    attach_stdout.to_string(),
                ].join(",")
            }),


            self.cmd.as_ref().map(|cmd| {
                [
                    "Cmd".to_string(),
                    cmd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.domainname.as_ref().map(|domainname| {
                [
                    "Domainname".to_string(),
                    domainname.to_string(),
                ].join(",")
            }),


            self.entrypoint.as_ref().map(|entrypoint| {
                [
                    "Entrypoint".to_string(),
                    entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.env.as_ref().map(|env| {
                [
                    "Env".to_string(),
                    env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping ExposedPorts in query parameter serialization
            // Skipping ExposedPorts in query parameter serialization

            // Skipping Healthcheck in query parameter serialization


            self.hostname.as_ref().map(|hostname| {
                [
                    "Hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),


            self.network_disabled.as_ref().map(|network_disabled| {
                [
                    "NetworkDisabled".to_string(),
                    network_disabled.to_string(),
                ].join(",")
            }),


            self.on_build.as_ref().map(|on_build| {
                [
                    "OnBuild".to_string(),
                    on_build.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.open_stdin.as_ref().map(|open_stdin| {
                [
                    "OpenStdin".to_string(),
                    open_stdin.to_string(),
                ].join(",")
            }),


            self.shell.as_ref().map(|shell| {
                [
                    "Shell".to_string(),
                    shell.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.stdin_once.as_ref().map(|stdin_once| {
                [
                    "StdinOnce".to_string(),
                    stdin_once.to_string(),
                ].join(",")
            }),


            self.stop_signal.as_ref().map(|stop_signal| {
                [
                    "StopSignal".to_string(),
                    stop_signal.to_string(),
                ].join(",")
            }),


            self.stop_timeout.as_ref().map(|stop_timeout| {
                [
                    "StopTimeout".to_string(),
                    stop_timeout.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "Tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "User".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping Volumes in query parameter serialization
            // Skipping Volumes in query parameter serialization


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "WorkingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Config value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Config {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args_escaped: Vec<bool>,
            pub attach_stderr: Vec<bool>,
            pub attach_stdin: Vec<bool>,
            pub attach_stdout: Vec<bool>,
            pub cmd: Vec<Vec<String>>,
            pub domainname: Vec<String>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<Vec<String>>,
            pub exposed_ports: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub healthcheck: Vec<models::HealthcheckConfig>,
            pub hostname: Vec<String>,
            pub image: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub mac_address: Vec<String>,
            pub network_disabled: Vec<bool>,
            pub on_build: Vec<Vec<String>>,
            pub open_stdin: Vec<bool>,
            pub shell: Vec<Vec<String>>,
            pub stdin_once: Vec<bool>,
            pub stop_signal: Vec<String>,
            pub stop_timeout: Vec<i64>,
            pub tty: Vec<bool>,
            pub user: Vec<String>,
            pub volumes: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub working_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Config".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ArgsEscaped" => intermediate_rep.args_escaped.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStderr" => intermediate_rep.attach_stderr.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdin" => intermediate_rep.attach_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdout" => intermediate_rep.attach_stdout.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Cmd" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Domainname" => intermediate_rep.domainname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    "ExposedPorts" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Healthcheck" => intermediate_rep.healthcheck.push(<models::HealthcheckConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkDisabled" => intermediate_rep.network_disabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "OnBuild" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "OpenStdin" => intermediate_rep.open_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Shell" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "StdinOnce" => intermediate_rep.stdin_once.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StopSignal" => intermediate_rep.stop_signal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StopTimeout" => intermediate_rep.stop_timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in Config".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "WorkingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Config".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Config {
            args_escaped: intermediate_rep.args_escaped.into_iter().next(),
            attach_stderr: intermediate_rep.attach_stderr.into_iter().next(),
            attach_stdin: intermediate_rep.attach_stdin.into_iter().next(),
            attach_stdout: intermediate_rep.attach_stdout.into_iter().next(),
            cmd: intermediate_rep.cmd.into_iter().next(),
            domainname: intermediate_rep.domainname.into_iter().next(),
            entrypoint: intermediate_rep.entrypoint.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            exposed_ports: intermediate_rep.exposed_ports.into_iter().next(),
            healthcheck: intermediate_rep.healthcheck.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            network_disabled: intermediate_rep.network_disabled.into_iter().next(),
            on_build: intermediate_rep.on_build.into_iter().next(),
            open_stdin: intermediate_rep.open_stdin.into_iter().next(),
            shell: intermediate_rep.shell.into_iter().next(),
            stdin_once: intermediate_rep.stdin_once.into_iter().next(),
            stop_signal: intermediate_rep.stop_signal.into_iter().next(),
            stop_timeout: intermediate_rep.stop_timeout.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Config> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Config>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Config>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Config - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Config> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Config as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Config - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ConfigReference specifies the source which provides a network's configuration



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConfigReference {
    #[serde(rename = "Network")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network: Option<String>,

}


impl ConfigReference {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConfigReference {
        ConfigReference {
            network: None,
        }
    }
}

/// Converts the ConfigReference value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConfigReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.network.as_ref().map(|network| {
                [
                    "Network".to_string(),
                    network.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConfigReference value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConfigReference {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub network: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConfigReference".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Network" => intermediate_rep.network.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConfigReference".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConfigReference {
            network: intermediate_rep.network.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConfigReference> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConfigReference>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConfigReference>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConfigReference - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConfigReference> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConfigReference as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConfigReference - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ConmonInfo describes the conmon executable being used



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConmonInfo {
    #[serde(rename = "package")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<String>,

    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl ConmonInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ConmonInfo {
        ConmonInfo {
            package: None,
            path: None,
            version: None,
        }
    }
}

/// Converts the ConmonInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ConmonInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.package.as_ref().map(|package| {
                [
                    "package".to_string(),
                    package.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConmonInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConmonInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub package: Vec<String>,
            pub path: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConmonInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "package" => intermediate_rep.package.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConmonInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConmonInfo {
            package: intermediate_rep.package.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConmonInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ConmonInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConmonInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConmonInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ConmonInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConmonInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConmonInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Consistency(String);

impl validator::Validate for Consistency {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Consistency {
    fn from(x: String) -> Self {
        Consistency(x)
    }
}

impl std::fmt::Display for Consistency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for Consistency {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Consistency(x.to_string()))
    }
}

impl std::convert::From<Consistency> for String {
    fn from(x: Consistency) -> Self {
        x.0
    }
}

impl std::ops::Deref for Consistency {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Consistency {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate, Default)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Container {
    #[serde(rename = "Command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<String>,

    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<models::Config>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<i64>,

    #[serde(rename = "DefaultReadOnlyNonRecursive")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_read_only_non_recursive: Option<bool>,

    #[serde(rename = "HostConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_config: Option<models::HostConfig>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

    #[serde(rename = "ImageID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_id: Option<String>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::MountPoint>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Names")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub names: Option<Vec<String>>,

    #[serde(rename = "NetworkSettings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_settings: Option<models::SummaryNetworkSettings>,

    #[serde(rename = "NetworkingConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networking_config: Option<models::NetworkingConfig>,

    #[serde(rename = "Platform")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<models::Platform>,

    #[serde(rename = "Ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ports: Option<Vec<models::Port>>,

    #[serde(rename = "SizeRootFs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_root_fs: Option<i64>,

    #[serde(rename = "SizeRw")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_rw: Option<i64>,

    #[serde(rename = "State")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,

    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl Container {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Container {
        Container {
            command: None,
            config: None,
            created: None,
            default_read_only_non_recursive: None,
            host_config: None,
            id: None,
            image: None,
            image_id: None,
            labels: None,
            mounts: None,
            name: None,
            names: None,
            network_settings: None,
            networking_config: None,
            platform: None,
            ports: None,
            size_root_fs: None,
            size_rw: None,
            state: None,
            status: None,
        }
    }
}

/// Converts the Container value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Container {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.command.as_ref().map(|command| {
                [
                    "Command".to_string(),
                    command.to_string(),
                ].join(",")
            }),

            // Skipping Config in query parameter serialization


            self.created.as_ref().map(|created| {
                [
                    "Created".to_string(),
                    created.to_string(),
                ].join(",")
            }),


            self.default_read_only_non_recursive.as_ref().map(|default_read_only_non_recursive| {
                [
                    "DefaultReadOnlyNonRecursive".to_string(),
                    default_read_only_non_recursive.to_string(),
                ].join(",")
            }),

            // Skipping HostConfig in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.image_id.as_ref().map(|image_id| {
                [
                    "ImageID".to_string(),
                    image_id.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization

            // Skipping Mounts in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.names.as_ref().map(|names| {
                [
                    "Names".to_string(),
                    names.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping NetworkSettings in query parameter serialization

            // Skipping NetworkingConfig in query parameter serialization

            // Skipping Platform in query parameter serialization

            // Skipping Ports in query parameter serialization


            self.size_root_fs.as_ref().map(|size_root_fs| {
                [
                    "SizeRootFs".to_string(),
                    size_root_fs.to_string(),
                ].join(",")
            }),


            self.size_rw.as_ref().map(|size_rw| {
                [
                    "SizeRw".to_string(),
                    size_rw.to_string(),
                ].join(",")
            }),


            self.state.as_ref().map(|state| {
                [
                    "State".to_string(),
                    state.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Container value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Container {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub command: Vec<String>,
            pub config: Vec<models::Config>,
            pub created: Vec<i64>,
            pub default_read_only_non_recursive: Vec<bool>,
            pub host_config: Vec<models::HostConfig>,
            pub id: Vec<String>,
            pub image: Vec<String>,
            pub image_id: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub mounts: Vec<Vec<models::MountPoint>>,
            pub name: Vec<String>,
            pub names: Vec<Vec<String>>,
            pub network_settings: Vec<models::SummaryNetworkSettings>,
            pub networking_config: Vec<models::NetworkingConfig>,
            pub platform: Vec<models::Platform>,
            pub ports: Vec<Vec<models::Port>>,
            pub size_root_fs: Vec<i64>,
            pub size_rw: Vec<i64>,
            pub state: Vec<String>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Container".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Command" => intermediate_rep.command.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Config" => intermediate_rep.config.push(<models::Config as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DefaultReadOnlyNonRecursive" => intermediate_rep.default_read_only_non_recursive.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostConfig" => intermediate_rep.host_config.push(<models::HostConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ImageID" => intermediate_rep.image_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Names" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "NetworkSettings" => intermediate_rep.network_settings.push(<models::SummaryNetworkSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkingConfig" => intermediate_rep.networking_config.push(<models::NetworkingConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Platform" => intermediate_rep.platform.push(<models::Platform as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ports" => return std::result::Result::Err("Parsing a container in this style is not supported in Container".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SizeRootFs" => intermediate_rep.size_root_fs.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SizeRw" => intermediate_rep.size_rw.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "State" => intermediate_rep.state.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Container".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Container {
            command: intermediate_rep.command.into_iter().next(),
            config: intermediate_rep.config.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            default_read_only_non_recursive: intermediate_rep.default_read_only_non_recursive.into_iter().next(),
            host_config: intermediate_rep.host_config.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            image_id: intermediate_rep.image_id.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            names: intermediate_rep.names.into_iter().next(),
            network_settings: intermediate_rep.network_settings.into_iter().next(),
            networking_config: intermediate_rep.networking_config.into_iter().next(),
            platform: intermediate_rep.platform.into_iter().next(),
            ports: intermediate_rep.ports.into_iter().next(),
            size_root_fs: intermediate_rep.size_root_fs.into_iter().next(),
            size_rw: intermediate_rep.size_rw.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Container> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Container>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Container>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Container - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Container> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Container as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Container - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerBasicConfig {
/// Annotations are key-value options passed into the container runtime that can be used to trigger special behavior. Optional.
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// Command is the container's command. If not given and Image is specified, this will be populated by the image's configuration. Optional.
    #[serde(rename = "command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<Vec<String>>,

/// ConmonPidFile is a path at which a PID file for Conmon will be placed. If not given, a default location will be used. Optional.
    #[serde(rename = "conmon_pid_file")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conmon_pid_file: Option<String>,

/// ContainerCreateCommand is the command that was used to create this container. This will be shown in the output of Inspect() on the container, and may also be used by some tools that wish to recreate the container (e.g. `podman generate systemd --new`). Optional.
    #[serde(rename = "containerCreateCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_create_command: Option<Vec<String>>,

/// DependencyContainers is an array of containers this container depends on. Dependency containers must be started before this container. Dependencies can be specified by name or full/partial ID. Optional.
    #[serde(rename = "dependencyContainers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_containers: Option<Vec<String>>,

/// Entrypoint is the container's entrypoint. If not given and Image is specified, this will be populated by the image's configuration. Optional.
    #[serde(rename = "entrypoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrypoint: Option<Vec<String>>,

/// Env is a set of environment variables that will be set in the container. Optional.
    #[serde(rename = "env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<std::collections::HashMap<String, String>>,

/// EnvHost indicates that the host environment should be added to container Optional.
    #[serde(rename = "env_host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env_host: Option<bool>,

/// EnvMerge takes the specified environment variables from image and preprocess them before injecting them into the container. Optional.
    #[serde(rename = "envmerge")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub envmerge: Option<Vec<String>>,

/// GroupEntry specifies an arbitrary string to append to the container's /etc/group file. Optional.
    #[serde(rename = "group_entry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_entry: Option<String>,

/// Hostname is the container's hostname. If not set, the hostname will not be modified (if UtsNS is not private) or will be set to the container ID (if UtsNS is private). Conflicts with UtsNS if UtsNS is not set to private. Optional.
    #[serde(rename = "hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

/// HostUsers is a list of host usernames or UIDs to add to the container etc/passwd file
    #[serde(rename = "hostusers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostusers: Option<Vec<String>>,

/// EnvHTTPProxy indicates that the http host proxy environment variables should be added to container Optional.
    #[serde(rename = "httpproxy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub httpproxy: Option<bool>,

/// InitContainerType describes if this container is an init container and if so, what type: always or once. Optional.
    #[serde(rename = "init_container_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init_container_type: Option<String>,

/// Labels are key-value pairs that are used to add metadata to containers. Optional.
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "log_configuration")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_configuration: Option<models::LogConfigLibpod>,

/// Passwd is a container run option that determines if we are validating users/groups before running the container
    #[serde(rename = "manage_password")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manage_password: Option<bool>,

/// Name is the name the container will be given. If no name is provided, one will be randomly generated. Optional.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// OCIRuntime is the name of the OCI runtime that will be used to create the container. If not specified, the default will be used. Optional.
    #[serde(rename = "oci_runtime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oci_runtime: Option<String>,

/// PasswdEntry specifies an arbitrary string to append to the container's /etc/passwd file. Optional.
    #[serde(rename = "passwd_entry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub passwd_entry: Option<String>,

    #[serde(rename = "personality")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub personality: Option<models::LinuxPersonality>,

    #[serde(rename = "pidns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pidns: Option<models::Namespace>,

/// Pod is the ID of the pod the container will join. Optional.
    #[serde(rename = "pod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod: Option<String>,

/// Remove indicates if the container should be removed once it has been started and exits. Optional.
    #[serde(rename = "remove")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub remove: Option<bool>,

/// RestartPolicy is the container's restart policy - an action which will be taken when the container exits. If not given, the default policy, which does nothing, will be used. Optional.
    #[serde(rename = "restart_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<String>,

/// RestartRetries is the number of attempts that will be made to restart the container. Only available when RestartPolicy is set to \"on-failure\". Optional.
    #[serde(rename = "restart_tries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_tries: Option<i32>,

/// Determine how to handle the NOTIFY_SOCKET - do we participate or pass it through \"container\" - let the OCI runtime deal with it, advertise conmon's MAINPID \"conmon-only\" - advertise conmon's MAINPID, send READY when started, don't pass to OCI \"ignore\" - unset NOTIFY_SOCKET Optional.
    #[serde(rename = "sdnotifyMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sdnotify_mode: Option<String>,

/// EnvSecrets are secrets that will be set as environment variables Optional.
    #[serde(rename = "secret_env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_env: Option<std::collections::HashMap<String, String>>,

/// Stdin is whether the container will keep its STDIN open. Optional.
    #[serde(rename = "stdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin: Option<bool>,

/// It implements the os.Signal interface.
    #[serde(rename = "stop_signal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_signal: Option<i64>,

/// StopTimeout is a timeout between the container's stop signal being sent and SIGKILL being sent. If not provided, the default will be used. If 0 is used, stop signal will not be sent, and SIGKILL will be sent instead. Optional.
    #[serde(rename = "stop_timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_timeout: Option<i32>,

/// Sysctl sets kernel parameters for the container
    #[serde(rename = "sysctl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sysctl: Option<std::collections::HashMap<String, String>>,

/// Systemd is whether the container will be started in systemd mode. Valid options are \"true\", \"false\", and \"always\". \"true\" enables this mode only if the binary run in the container is sbin/init or systemd. \"always\" unconditionally enables systemd mode. \"false\" unconditionally disables systemd mode. If enabled, mounts and stop signal will be modified. If set to \"always\" or set to \"true\" and conditionally triggered, conflicts with StopSignal. If not specified, \"false\" will be assumed. Optional.
    #[serde(rename = "systemd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub systemd: Option<String>,

/// Terminal is whether the container will create a PTY. Optional.
    #[serde(rename = "terminal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub terminal: Option<bool>,

/// Timeout is a maximum time in seconds the container will run before main process is sent SIGKILL. If 0 is used, signal will not be sent. Container can run indefinitely if they do not stop after the default termination signal. Optional.
    #[serde(rename = "timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i32>,

/// Timezone is the timezone inside the container. Local means it has the same timezone as the host machine Optional.
    #[serde(rename = "timezone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timezone: Option<String>,

/// UnsetEnv unsets the specified default environment variables from the image or from buildin or containers.conf Optional.
    #[serde(rename = "unsetenv")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unsetenv: Option<Vec<String>>,

/// UnsetEnvAll unsetall default environment variables from the image or from buildin or containers.conf UnsetEnvAll unsets all default environment variables from the image or from buildin Optional.
    #[serde(rename = "unsetenvall")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unsetenvall: Option<bool>,

    #[serde(rename = "utsns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub utsns: Option<models::Namespace>,

}


impl ContainerBasicConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerBasicConfig {
        ContainerBasicConfig {
            annotations: None,
            command: None,
            conmon_pid_file: None,
            container_create_command: None,
            dependency_containers: None,
            entrypoint: None,
            env: None,
            env_host: None,
            envmerge: None,
            group_entry: None,
            hostname: None,
            hostusers: None,
            httpproxy: None,
            init_container_type: None,
            labels: None,
            log_configuration: None,
            manage_password: None,
            name: None,
            oci_runtime: None,
            passwd_entry: None,
            personality: None,
            pidns: None,
            pod: None,
            remove: None,
            restart_policy: None,
            restart_tries: None,
            sdnotify_mode: None,
            secret_env: None,
            stdin: None,
            stop_signal: None,
            stop_timeout: None,
            sysctl: None,
            systemd: None,
            terminal: None,
            timeout: None,
            timezone: None,
            unsetenv: None,
            unsetenvall: None,
            utsns: None,
        }
    }
}

/// Converts the ContainerBasicConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerBasicConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping annotations in query parameter serialization


            self.command.as_ref().map(|command| {
                [
                    "command".to_string(),
                    command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.conmon_pid_file.as_ref().map(|conmon_pid_file| {
                [
                    "conmon_pid_file".to_string(),
                    conmon_pid_file.to_string(),
                ].join(",")
            }),


            self.container_create_command.as_ref().map(|container_create_command| {
                [
                    "containerCreateCommand".to_string(),
                    container_create_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dependency_containers.as_ref().map(|dependency_containers| {
                [
                    "dependencyContainers".to_string(),
                    dependency_containers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.entrypoint.as_ref().map(|entrypoint| {
                [
                    "entrypoint".to_string(),
                    entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping env in query parameter serialization


            self.env_host.as_ref().map(|env_host| {
                [
                    "env_host".to_string(),
                    env_host.to_string(),
                ].join(",")
            }),


            self.envmerge.as_ref().map(|envmerge| {
                [
                    "envmerge".to_string(),
                    envmerge.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.group_entry.as_ref().map(|group_entry| {
                [
                    "group_entry".to_string(),
                    group_entry.to_string(),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.hostusers.as_ref().map(|hostusers| {
                [
                    "hostusers".to_string(),
                    hostusers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.httpproxy.as_ref().map(|httpproxy| {
                [
                    "httpproxy".to_string(),
                    httpproxy.to_string(),
                ].join(",")
            }),


            self.init_container_type.as_ref().map(|init_container_type| {
                [
                    "init_container_type".to_string(),
                    init_container_type.to_string(),
                ].join(",")
            }),

            // Skipping labels in query parameter serialization

            // Skipping log_configuration in query parameter serialization


            self.manage_password.as_ref().map(|manage_password| {
                [
                    "manage_password".to_string(),
                    manage_password.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.oci_runtime.as_ref().map(|oci_runtime| {
                [
                    "oci_runtime".to_string(),
                    oci_runtime.to_string(),
                ].join(",")
            }),


            self.passwd_entry.as_ref().map(|passwd_entry| {
                [
                    "passwd_entry".to_string(),
                    passwd_entry.to_string(),
                ].join(",")
            }),

            // Skipping personality in query parameter serialization

            // Skipping pidns in query parameter serialization


            self.pod.as_ref().map(|pod| {
                [
                    "pod".to_string(),
                    pod.to_string(),
                ].join(",")
            }),


            self.remove.as_ref().map(|remove| {
                [
                    "remove".to_string(),
                    remove.to_string(),
                ].join(",")
            }),


            self.restart_policy.as_ref().map(|restart_policy| {
                [
                    "restart_policy".to_string(),
                    restart_policy.to_string(),
                ].join(",")
            }),


            self.restart_tries.as_ref().map(|restart_tries| {
                [
                    "restart_tries".to_string(),
                    restart_tries.to_string(),
                ].join(",")
            }),


            self.sdnotify_mode.as_ref().map(|sdnotify_mode| {
                [
                    "sdnotifyMode".to_string(),
                    sdnotify_mode.to_string(),
                ].join(",")
            }),

            // Skipping secret_env in query parameter serialization


            self.stdin.as_ref().map(|stdin| {
                [
                    "stdin".to_string(),
                    stdin.to_string(),
                ].join(",")
            }),


            self.stop_signal.as_ref().map(|stop_signal| {
                [
                    "stop_signal".to_string(),
                    stop_signal.to_string(),
                ].join(",")
            }),


            self.stop_timeout.as_ref().map(|stop_timeout| {
                [
                    "stop_timeout".to_string(),
                    stop_timeout.to_string(),
                ].join(",")
            }),

            // Skipping sysctl in query parameter serialization


            self.systemd.as_ref().map(|systemd| {
                [
                    "systemd".to_string(),
                    systemd.to_string(),
                ].join(",")
            }),


            self.terminal.as_ref().map(|terminal| {
                [
                    "terminal".to_string(),
                    terminal.to_string(),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),


            self.timezone.as_ref().map(|timezone| {
                [
                    "timezone".to_string(),
                    timezone.to_string(),
                ].join(",")
            }),


            self.unsetenv.as_ref().map(|unsetenv| {
                [
                    "unsetenv".to_string(),
                    unsetenv.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.unsetenvall.as_ref().map(|unsetenvall| {
                [
                    "unsetenvall".to_string(),
                    unsetenvall.to_string(),
                ].join(",")
            }),

            // Skipping utsns in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerBasicConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerBasicConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub command: Vec<Vec<String>>,
            pub conmon_pid_file: Vec<String>,
            pub container_create_command: Vec<Vec<String>>,
            pub dependency_containers: Vec<Vec<String>>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<std::collections::HashMap<String, String>>,
            pub env_host: Vec<bool>,
            pub envmerge: Vec<Vec<String>>,
            pub group_entry: Vec<String>,
            pub hostname: Vec<String>,
            pub hostusers: Vec<Vec<String>>,
            pub httpproxy: Vec<bool>,
            pub init_container_type: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub log_configuration: Vec<models::LogConfigLibpod>,
            pub manage_password: Vec<bool>,
            pub name: Vec<String>,
            pub oci_runtime: Vec<String>,
            pub passwd_entry: Vec<String>,
            pub personality: Vec<models::LinuxPersonality>,
            pub pidns: Vec<models::Namespace>,
            pub pod: Vec<String>,
            pub remove: Vec<bool>,
            pub restart_policy: Vec<String>,
            pub restart_tries: Vec<i32>,
            pub sdnotify_mode: Vec<String>,
            pub secret_env: Vec<std::collections::HashMap<String, String>>,
            pub stdin: Vec<bool>,
            pub stop_signal: Vec<i64>,
            pub stop_timeout: Vec<i32>,
            pub sysctl: Vec<std::collections::HashMap<String, String>>,
            pub systemd: Vec<String>,
            pub terminal: Vec<bool>,
            pub timeout: Vec<i32>,
            pub timezone: Vec<String>,
            pub unsetenv: Vec<Vec<String>>,
            pub unsetenvall: Vec<bool>,
            pub utsns: Vec<models::Namespace>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerBasicConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    "command" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "conmon_pid_file" => intermediate_rep.conmon_pid_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "containerCreateCommand" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    "dependencyContainers" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    "entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    "env" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "env_host" => intermediate_rep.env_host.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "envmerge" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "group_entry" => intermediate_rep.group_entry.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hostusers" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "httpproxy" => intermediate_rep.httpproxy.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "init_container_type" => intermediate_rep.init_container_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "log_configuration" => intermediate_rep.log_configuration.push(<models::LogConfigLibpod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "manage_password" => intermediate_rep.manage_password.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oci_runtime" => intermediate_rep.oci_runtime.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "passwd_entry" => intermediate_rep.passwd_entry.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "personality" => intermediate_rep.personality.push(<models::LinuxPersonality as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pidns" => intermediate_rep.pidns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pod" => intermediate_rep.pod.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "remove" => intermediate_rep.remove.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "restart_policy" => intermediate_rep.restart_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "restart_tries" => intermediate_rep.restart_tries.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sdnotifyMode" => intermediate_rep.sdnotify_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "secret_env" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "stdin" => intermediate_rep.stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stop_signal" => intermediate_rep.stop_signal.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stop_timeout" => intermediate_rep.stop_timeout.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "sysctl" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "systemd" => intermediate_rep.systemd.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminal" => intermediate_rep.terminal.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timeout" => intermediate_rep.timeout.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timezone" => intermediate_rep.timezone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "unsetenv" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "unsetenvall" => intermediate_rep.unsetenvall.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "utsns" => intermediate_rep.utsns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerBasicConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerBasicConfig {
            annotations: intermediate_rep.annotations.into_iter().next(),
            command: intermediate_rep.command.into_iter().next(),
            conmon_pid_file: intermediate_rep.conmon_pid_file.into_iter().next(),
            container_create_command: intermediate_rep.container_create_command.into_iter().next(),
            dependency_containers: intermediate_rep.dependency_containers.into_iter().next(),
            entrypoint: intermediate_rep.entrypoint.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            env_host: intermediate_rep.env_host.into_iter().next(),
            envmerge: intermediate_rep.envmerge.into_iter().next(),
            group_entry: intermediate_rep.group_entry.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            hostusers: intermediate_rep.hostusers.into_iter().next(),
            httpproxy: intermediate_rep.httpproxy.into_iter().next(),
            init_container_type: intermediate_rep.init_container_type.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            log_configuration: intermediate_rep.log_configuration.into_iter().next(),
            manage_password: intermediate_rep.manage_password.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            oci_runtime: intermediate_rep.oci_runtime.into_iter().next(),
            passwd_entry: intermediate_rep.passwd_entry.into_iter().next(),
            personality: intermediate_rep.personality.into_iter().next(),
            pidns: intermediate_rep.pidns.into_iter().next(),
            pod: intermediate_rep.pod.into_iter().next(),
            remove: intermediate_rep.remove.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            restart_tries: intermediate_rep.restart_tries.into_iter().next(),
            sdnotify_mode: intermediate_rep.sdnotify_mode.into_iter().next(),
            secret_env: intermediate_rep.secret_env.into_iter().next(),
            stdin: intermediate_rep.stdin.into_iter().next(),
            stop_signal: intermediate_rep.stop_signal.into_iter().next(),
            stop_timeout: intermediate_rep.stop_timeout.into_iter().next(),
            sysctl: intermediate_rep.sysctl.into_iter().next(),
            systemd: intermediate_rep.systemd.into_iter().next(),
            terminal: intermediate_rep.terminal.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
            timezone: intermediate_rep.timezone.into_iter().next(),
            unsetenv: intermediate_rep.unsetenv.into_iter().next(),
            unsetenvall: intermediate_rep.unsetenvall.into_iter().next(),
            utsns: intermediate_rep.utsns.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerBasicConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerBasicConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerBasicConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerBasicConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerBasicConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerBasicConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerBasicConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerCgroupConfig contains configuration information about a container's cgroups.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerCgroupConfig {
/// CgroupParent is the container's Cgroup parent. If not set, the default for the current cgroup driver will be used. Optional.
    #[serde(rename = "cgroup_parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

    #[serde(rename = "cgroupns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroupns: Option<models::Namespace>,

/// CgroupsMode sets a policy for how cgroups will be created for the container, including the ability to disable creation entirely. Optional.
    #[serde(rename = "cgroups_mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroups_mode: Option<String>,

}


impl ContainerCgroupConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerCgroupConfig {
        ContainerCgroupConfig {
            cgroup_parent: None,
            cgroupns: None,
            cgroups_mode: None,
        }
    }
}

/// Converts the ContainerCgroupConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerCgroupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "cgroup_parent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),

            // Skipping cgroupns in query parameter serialization


            self.cgroups_mode.as_ref().map(|cgroups_mode| {
                [
                    "cgroups_mode".to_string(),
                    cgroups_mode.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerCgroupConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerCgroupConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup_parent: Vec<String>,
            pub cgroupns: Vec<models::Namespace>,
            pub cgroups_mode: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerCgroupConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cgroup_parent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cgroupns" => intermediate_rep.cgroupns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cgroups_mode" => intermediate_rep.cgroups_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerCgroupConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerCgroupConfig {
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cgroupns: intermediate_rep.cgroupns.into_iter().next(),
            cgroups_mode: intermediate_rep.cgroups_mode.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerCgroupConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerCgroupConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerCgroupConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerCgroupConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerCgroupConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerCgroupConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerCgroupConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerCreateResponse is the response struct for creating a container



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerCreateResponse {
/// ID of the container created
    #[serde(rename = "Id")]
    pub id: String,

/// Warnings during container creation
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,

}


impl ContainerCreateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, warnings: Vec<String>, ) -> ContainerCreateResponse {
        ContainerCreateResponse {
            id,
            warnings,
        }
    }
}

/// Converts the ContainerCreateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerCreateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Id".to_string()),
            Some(self.id.to_string()),


            Some("Warnings".to_string()),
            Some(self.warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerCreateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerCreateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerCreateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerCreateResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerCreateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerCreateResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in ContainerCreateResponse".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "Warnings missing in ContainerCreateResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerCreateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerCreateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerCreateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerCreateResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerCreateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerCreateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerCreateResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerExecRequest {
/// Attach to stderr of the exec command
    #[serde(rename = "AttachStderr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stderr: Option<bool>,

/// Attach to stdin of the exec command
    #[serde(rename = "AttachStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdin: Option<bool>,

/// Attach to stdout of the exec command
    #[serde(rename = "AttachStdout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdout: Option<bool>,

/// Command to run, as a string or array of strings.
    #[serde(rename = "Cmd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cmd: Option<Vec<String>>,

/// \"Override the key sequence for detaching a container. Format is a single character [a-Z] or ctrl-<value> where <value> is one of: a-z, @, ^, [, , or _.\"
    #[serde(rename = "DetachKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detach_keys: Option<String>,

/// A list of environment variables in the form [\"VAR=value\", ...]
    #[serde(rename = "Env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<String>>,

/// Runs the exec process with extended privileges
    #[serde(rename = "Privileged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privileged: Option<bool>,

/// Allocate a pseudo-TTY
    #[serde(rename = "Tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

/// \"The user, and optionally, group to run the exec process inside the container. Format is one of: user, user:group, uid, or uid:gid.\"
    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

/// The working directory for the exec process inside the container.
    #[serde(rename = "WorkingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

}


impl ContainerExecRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerExecRequest {
        ContainerExecRequest {
            attach_stderr: None,
            attach_stdin: None,
            attach_stdout: None,
            cmd: None,
            detach_keys: None,
            env: None,
            privileged: Some(false),
            tty: None,
            user: None,
            working_dir: None,
        }
    }
}

/// Converts the ContainerExecRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerExecRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.attach_stderr.as_ref().map(|attach_stderr| {
                [
                    "AttachStderr".to_string(),
                    attach_stderr.to_string(),
                ].join(",")
            }),


            self.attach_stdin.as_ref().map(|attach_stdin| {
                [
                    "AttachStdin".to_string(),
                    attach_stdin.to_string(),
                ].join(",")
            }),


            self.attach_stdout.as_ref().map(|attach_stdout| {
                [
                    "AttachStdout".to_string(),
                    attach_stdout.to_string(),
                ].join(",")
            }),


            self.cmd.as_ref().map(|cmd| {
                [
                    "Cmd".to_string(),
                    cmd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.detach_keys.as_ref().map(|detach_keys| {
                [
                    "DetachKeys".to_string(),
                    detach_keys.to_string(),
                ].join(",")
            }),


            self.env.as_ref().map(|env| {
                [
                    "Env".to_string(),
                    env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.privileged.as_ref().map(|privileged| {
                [
                    "Privileged".to_string(),
                    privileged.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "Tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "User".to_string(),
                    user.to_string(),
                ].join(",")
            }),


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "WorkingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerExecRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerExecRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub attach_stderr: Vec<bool>,
            pub attach_stdin: Vec<bool>,
            pub attach_stdout: Vec<bool>,
            pub cmd: Vec<Vec<String>>,
            pub detach_keys: Vec<String>,
            pub env: Vec<Vec<String>>,
            pub privileged: Vec<bool>,
            pub tty: Vec<bool>,
            pub user: Vec<String>,
            pub working_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerExecRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AttachStderr" => intermediate_rep.attach_stderr.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdin" => intermediate_rep.attach_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdout" => intermediate_rep.attach_stdout.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Cmd" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerExecRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "DetachKeys" => intermediate_rep.detach_keys.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerExecRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Privileged" => intermediate_rep.privileged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "WorkingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerExecRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerExecRequest {
            attach_stderr: intermediate_rep.attach_stderr.into_iter().next(),
            attach_stdin: intermediate_rep.attach_stdin.into_iter().next(),
            attach_stdout: intermediate_rep.attach_stdout.into_iter().next(),
            cmd: intermediate_rep.cmd.into_iter().next(),
            detach_keys: intermediate_rep.detach_keys.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            privileged: intermediate_rep.privileged.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerExecRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerExecRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerExecRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerExecRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerExecRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerExecRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerExecRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerHealthCheckConfig describes a container healthcheck with attributes like command, retries, interval, start period, and timeout.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerHealthCheckConfig {
/// HealthCheckOnFailureAction defines how Podman reacts when a container's health status turns unhealthy.
    #[serde(rename = "health_check_on_failure_action")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub health_check_on_failure_action: Option<i64>,

    #[serde(rename = "healthconfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healthconfig: Option<models::Schema2HealthConfig>,

    #[serde(rename = "startupHealthConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub startup_health_config: Option<models::StartupHealthCheck>,

}


impl ContainerHealthCheckConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerHealthCheckConfig {
        ContainerHealthCheckConfig {
            health_check_on_failure_action: None,
            healthconfig: None,
            startup_health_config: None,
        }
    }
}

/// Converts the ContainerHealthCheckConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerHealthCheckConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.health_check_on_failure_action.as_ref().map(|health_check_on_failure_action| {
                [
                    "health_check_on_failure_action".to_string(),
                    health_check_on_failure_action.to_string(),
                ].join(",")
            }),

            // Skipping healthconfig in query parameter serialization

            // Skipping startupHealthConfig in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerHealthCheckConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerHealthCheckConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub health_check_on_failure_action: Vec<i64>,
            pub healthconfig: Vec<models::Schema2HealthConfig>,
            pub startup_health_config: Vec<models::StartupHealthCheck>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerHealthCheckConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "health_check_on_failure_action" => intermediate_rep.health_check_on_failure_action.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "healthconfig" => intermediate_rep.healthconfig.push(<models::Schema2HealthConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startupHealthConfig" => intermediate_rep.startup_health_config.push(<models::StartupHealthCheck as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerHealthCheckConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerHealthCheckConfig {
            health_check_on_failure_action: intermediate_rep.health_check_on_failure_action.into_iter().next(),
            healthconfig: intermediate_rep.healthconfig.into_iter().next(),
            startup_health_config: intermediate_rep.startup_health_config.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerHealthCheckConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerHealthCheckConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerHealthCheckConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerHealthCheckConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerHealthCheckConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerHealthCheckConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerHealthCheckConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerJSON is newly used struct along with MountPoint



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate, Default)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerJson {
    #[serde(rename = "AppArmorProfile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_armor_profile: Option<String>,

    #[serde(rename = "Args")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args: Option<Vec<String>>,

    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<models::Config>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<String>,

    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

    #[serde(rename = "ExecIDs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exec_ids: Option<Vec<String>>,

    #[serde(rename = "GraphDriver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_driver: Option<models::GraphDriverData>,

    #[serde(rename = "HostConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_config: Option<models::HostConfig>,

    #[serde(rename = "HostnamePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname_path: Option<String>,

    #[serde(rename = "HostsPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hosts_path: Option<String>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

    #[serde(rename = "LogPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_path: Option<String>,

    #[serde(rename = "MountLabel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mount_label: Option<String>,

    #[serde(rename = "Mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::MountPoint>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "NetworkSettings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_settings: Option<models::NetworkSettings>,

    #[serde(rename = "Node")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub node: Option<models::ContainerNode>,

    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "Platform")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<String>,

    #[serde(rename = "ProcessLabel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub process_label: Option<String>,

    #[serde(rename = "ResolvConfPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolv_conf_path: Option<String>,

    #[serde(rename = "RestartCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_count: Option<i64>,

    #[serde(rename = "SizeRootFs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_root_fs: Option<i64>,

    #[serde(rename = "SizeRw")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_rw: Option<i64>,

    #[serde(rename = "State")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<models::ContainerState>,

}


impl ContainerJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerJson {
        ContainerJson {
            app_armor_profile: None,
            args: None,
            config: None,
            created: None,
            driver: None,
            exec_ids: None,
            graph_driver: None,
            host_config: None,
            hostname_path: None,
            hosts_path: None,
            id: None,
            image: None,
            log_path: None,
            mount_label: None,
            mounts: None,
            name: None,
            network_settings: None,
            node: None,
            path: None,
            platform: None,
            process_label: None,
            resolv_conf_path: None,
            restart_count: None,
            size_root_fs: None,
            size_rw: None,
            state: None,
        }
    }
}

/// Converts the ContainerJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.app_armor_profile.as_ref().map(|app_armor_profile| {
                [
                    "AppArmorProfile".to_string(),
                    app_armor_profile.to_string(),
                ].join(",")
            }),


            self.args.as_ref().map(|args| {
                [
                    "Args".to_string(),
                    args.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping Config in query parameter serialization


            self.created.as_ref().map(|created| {
                [
                    "Created".to_string(),
                    created.to_string(),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.exec_ids.as_ref().map(|exec_ids| {
                [
                    "ExecIDs".to_string(),
                    exec_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping GraphDriver in query parameter serialization

            // Skipping HostConfig in query parameter serialization


            self.hostname_path.as_ref().map(|hostname_path| {
                [
                    "HostnamePath".to_string(),
                    hostname_path.to_string(),
                ].join(",")
            }),


            self.hosts_path.as_ref().map(|hosts_path| {
                [
                    "HostsPath".to_string(),
                    hosts_path.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.log_path.as_ref().map(|log_path| {
                [
                    "LogPath".to_string(),
                    log_path.to_string(),
                ].join(",")
            }),


            self.mount_label.as_ref().map(|mount_label| {
                [
                    "MountLabel".to_string(),
                    mount_label.to_string(),
                ].join(",")
            }),

            // Skipping Mounts in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping NetworkSettings in query parameter serialization

            // Skipping Node in query parameter serialization


            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.platform.as_ref().map(|platform| {
                [
                    "Platform".to_string(),
                    platform.to_string(),
                ].join(",")
            }),


            self.process_label.as_ref().map(|process_label| {
                [
                    "ProcessLabel".to_string(),
                    process_label.to_string(),
                ].join(",")
            }),


            self.resolv_conf_path.as_ref().map(|resolv_conf_path| {
                [
                    "ResolvConfPath".to_string(),
                    resolv_conf_path.to_string(),
                ].join(",")
            }),


            self.restart_count.as_ref().map(|restart_count| {
                [
                    "RestartCount".to_string(),
                    restart_count.to_string(),
                ].join(",")
            }),


            self.size_root_fs.as_ref().map(|size_root_fs| {
                [
                    "SizeRootFs".to_string(),
                    size_root_fs.to_string(),
                ].join(",")
            }),


            self.size_rw.as_ref().map(|size_rw| {
                [
                    "SizeRw".to_string(),
                    size_rw.to_string(),
                ].join(",")
            }),

            // Skipping State in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub app_armor_profile: Vec<String>,
            pub args: Vec<Vec<String>>,
            pub config: Vec<models::Config>,
            pub created: Vec<String>,
            pub driver: Vec<String>,
            pub exec_ids: Vec<Vec<String>>,
            pub graph_driver: Vec<models::GraphDriverData>,
            pub host_config: Vec<models::HostConfig>,
            pub hostname_path: Vec<String>,
            pub hosts_path: Vec<String>,
            pub id: Vec<String>,
            pub image: Vec<String>,
            pub log_path: Vec<String>,
            pub mount_label: Vec<String>,
            pub mounts: Vec<Vec<models::MountPoint>>,
            pub name: Vec<String>,
            pub network_settings: Vec<models::NetworkSettings>,
            pub node: Vec<models::ContainerNode>,
            pub path: Vec<String>,
            pub platform: Vec<String>,
            pub process_label: Vec<String>,
            pub resolv_conf_path: Vec<String>,
            pub restart_count: Vec<i64>,
            pub size_root_fs: Vec<i64>,
            pub size_rw: Vec<i64>,
            pub state: Vec<models::ContainerState>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AppArmorProfile" => intermediate_rep.app_armor_profile.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Args" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerJson".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Config" => intermediate_rep.config.push(<models::Config as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ExecIDs" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerJson".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "GraphDriver" => intermediate_rep.graph_driver.push(<models::GraphDriverData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostConfig" => intermediate_rep.host_config.push(<models::HostConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostnamePath" => intermediate_rep.hostname_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostsPath" => intermediate_rep.hosts_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LogPath" => intermediate_rep.log_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MountLabel" => intermediate_rep.mount_label.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerJson".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkSettings" => intermediate_rep.network_settings.push(<models::NetworkSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Node" => intermediate_rep.node.push(<models::ContainerNode as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Platform" => intermediate_rep.platform.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ProcessLabel" => intermediate_rep.process_label.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ResolvConfPath" => intermediate_rep.resolv_conf_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestartCount" => intermediate_rep.restart_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SizeRootFs" => intermediate_rep.size_root_fs.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SizeRw" => intermediate_rep.size_rw.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "State" => intermediate_rep.state.push(<models::ContainerState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerJson {
            app_armor_profile: intermediate_rep.app_armor_profile.into_iter().next(),
            args: intermediate_rep.args.into_iter().next(),
            config: intermediate_rep.config.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            exec_ids: intermediate_rep.exec_ids.into_iter().next(),
            graph_driver: intermediate_rep.graph_driver.into_iter().next(),
            host_config: intermediate_rep.host_config.into_iter().next(),
            hostname_path: intermediate_rep.hostname_path.into_iter().next(),
            hosts_path: intermediate_rep.hosts_path.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            log_path: intermediate_rep.log_path.into_iter().next(),
            mount_label: intermediate_rep.mount_label.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            network_settings: intermediate_rep.network_settings.into_iter().next(),
            node: intermediate_rep.node.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            platform: intermediate_rep.platform.into_iter().next(),
            process_label: intermediate_rep.process_label.into_iter().next(),
            resolv_conf_path: intermediate_rep.resolv_conf_path.into_iter().next(),
            restart_count: intermediate_rep.restart_count.into_iter().next(),
            size_root_fs: intermediate_rep.size_root_fs.into_iter().next(),
            size_rw: intermediate_rep.size_rw.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerJson - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerJson - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerNetworkConfig contains information on a container's network configuration.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerNetworkConfig {
/// Map of networks names or ids that the container should join. You can request additional settings for each network, you can set network aliases, static ips, static mac address  and the network interface name for this container on the specific network. If the map is empty and the bridge network mode is set the container will be joined to the default network. Optional.
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<std::collections::HashMap<String, models::PerNetworkOptions>>,

/// BaseHostsFile is the path to a hosts file, the entries from this file are added to the containers hosts file. As special value \"image\" is allowed which uses the /etc/hosts file from within the image and \"none\" which uses no base file at all. If it is empty we should default to the base_hosts_file configuration in containers.conf. Optional.
    #[serde(rename = "base_hosts_file")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_hosts_file: Option<String>,

/// CNINetworks is a list of CNI networks to join the container to. If this list is empty, the default CNI network will be joined instead. If at least one entry is present, we will not join the default network (unless it is part of this list). Only available if NetNS is set to bridge. Optional. Deprecated: as of podman 4.0 use \"Networks\" instead.
    #[serde(rename = "cni_networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cni_networks: Option<Vec<String>>,

/// DNSOptions is a set of DNS options that will be used in the container's resolv.conf, replacing the host's DNS options which are used by default. Conflicts with UseImageResolvConf. Optional.
    #[serde(rename = "dns_option")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_option: Option<Vec<String>>,

/// DNSSearch is a set of DNS search domains that will be used in the container's resolv.conf, replacing the host's DNS search domains which are used by default. Conflicts with UseImageResolvConf. Optional.
    #[serde(rename = "dns_search")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

/// DNSServers is a set of DNS servers that will be used in the container's resolv.conf, replacing the host's DNS Servers which are used by default. Conflicts with UseImageResolvConf. Optional.
    #[serde(rename = "dns_server")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_server: Option<Vec<String>>,

/// Expose is a number of ports that will be forwarded to the container if PublishExposedPorts is set. Expose is a map of uint16 (port number) to a string representing protocol i.e map[uint16]string. Allowed protocols are \"tcp\", \"udp\", and \"sctp\", or some combination of the three separated by commas. If protocol is set to \"\" we will assume TCP. Only available if NetNS is set to Bridge or Slirp, and PublishExposedPorts is set. Optional.
    #[serde(rename = "expose")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expose: Option<crate::types::Object>,

/// HostAdd is a set of hosts which will be added to the container's etc/hosts file. Conflicts with UseImageHosts. Optional.
    #[serde(rename = "hostadd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostadd: Option<Vec<String>>,

    #[serde(rename = "netns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub netns: Option<models::Namespace>,

/// NetworkOptions are additional options for each network Optional.
    #[serde(rename = "network_options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_options: Option<std::collections::HashMap<String, Vec<String>>>,

/// PortBindings is a set of ports to map into the container. Only available if NetNS is set to bridge, slirp, or pasta. Optional.
    #[serde(rename = "portmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub portmappings: Option<Vec<models::PortMapping>>,

/// PublishExposedPorts will publish ports specified in the image to random unused ports (guaranteed to be above 1024) on the host. This is based on ports set in Expose below, and any ports specified by the Image (if one is given). Only available if NetNS is set to Bridge or Slirp. Optional.
    #[serde(rename = "publish_image_ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_image_ports: Option<bool>,

/// UseImageHosts indicates that /etc/hosts should not be managed by Podman, and instead sourced from the image. Conflicts with HostAdd. Optional.
    #[serde(rename = "use_image_hosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_image_hosts: Option<bool>,

/// UseImageResolvConf indicates that resolv.conf should not be managed by Podman, but instead sourced from the image. Conflicts with DNSServer, DNSSearch, DNSOption. Optional.
    #[serde(rename = "use_image_resolve_conf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_image_resolve_conf: Option<bool>,

}


impl ContainerNetworkConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerNetworkConfig {
        ContainerNetworkConfig {
            networks: None,
            base_hosts_file: None,
            cni_networks: None,
            dns_option: None,
            dns_search: None,
            dns_server: None,
            expose: None,
            hostadd: None,
            netns: None,
            network_options: None,
            portmappings: None,
            publish_image_ports: None,
            use_image_hosts: None,
            use_image_resolve_conf: None,
        }
    }
}

/// Converts the ContainerNetworkConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Networks in query parameter serialization
            // Skipping Networks in query parameter serialization


            self.base_hosts_file.as_ref().map(|base_hosts_file| {
                [
                    "base_hosts_file".to_string(),
                    base_hosts_file.to_string(),
                ].join(",")
            }),


            self.cni_networks.as_ref().map(|cni_networks| {
                [
                    "cni_networks".to_string(),
                    cni_networks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_option.as_ref().map(|dns_option| {
                [
                    "dns_option".to_string(),
                    dns_option.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "dns_search".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_server.as_ref().map(|dns_server| {
                [
                    "dns_server".to_string(),
                    dns_server.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping expose in query parameter serialization


            self.hostadd.as_ref().map(|hostadd| {
                [
                    "hostadd".to_string(),
                    hostadd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping netns in query parameter serialization

            // Skipping network_options in query parameter serialization
            // Skipping network_options in query parameter serialization

            // Skipping portmappings in query parameter serialization


            self.publish_image_ports.as_ref().map(|publish_image_ports| {
                [
                    "publish_image_ports".to_string(),
                    publish_image_ports.to_string(),
                ].join(",")
            }),


            self.use_image_hosts.as_ref().map(|use_image_hosts| {
                [
                    "use_image_hosts".to_string(),
                    use_image_hosts.to_string(),
                ].join(",")
            }),


            self.use_image_resolve_conf.as_ref().map(|use_image_resolve_conf| {
                [
                    "use_image_resolve_conf".to_string(),
                    use_image_resolve_conf.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerNetworkConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerNetworkConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub networks: Vec<std::collections::HashMap<String, models::PerNetworkOptions>>,
            pub base_hosts_file: Vec<String>,
            pub cni_networks: Vec<Vec<String>>,
            pub dns_option: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub dns_server: Vec<Vec<String>>,
            pub expose: Vec<crate::types::Object>,
            pub hostadd: Vec<Vec<String>>,
            pub netns: Vec<models::Namespace>,
            pub network_options: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub portmappings: Vec<Vec<models::PortMapping>>,
            pub publish_image_ports: Vec<bool>,
            pub use_image_hosts: Vec<bool>,
            pub use_image_resolve_conf: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerNetworkConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNetworkConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "base_hosts_file" => intermediate_rep.base_hosts_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "cni_networks" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNetworkConfig".to_string()),
                    "dns_option" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNetworkConfig".to_string()),
                    "dns_search" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNetworkConfig".to_string()),
                    "dns_server" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNetworkConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "expose" => intermediate_rep.expose.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hostadd" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNetworkConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "netns" => intermediate_rep.netns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "network_options" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNetworkConfig".to_string()),
                    "portmappings" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNetworkConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "publish_image_ports" => intermediate_rep.publish_image_ports.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "use_image_hosts" => intermediate_rep.use_image_hosts.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "use_image_resolve_conf" => intermediate_rep.use_image_resolve_conf.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerNetworkConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerNetworkConfig {
            networks: intermediate_rep.networks.into_iter().next(),
            base_hosts_file: intermediate_rep.base_hosts_file.into_iter().next(),
            cni_networks: intermediate_rep.cni_networks.into_iter().next(),
            dns_option: intermediate_rep.dns_option.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            dns_server: intermediate_rep.dns_server.into_iter().next(),
            expose: intermediate_rep.expose.into_iter().next(),
            hostadd: intermediate_rep.hostadd.into_iter().next(),
            netns: intermediate_rep.netns.into_iter().next(),
            network_options: intermediate_rep.network_options.into_iter().next(),
            portmappings: intermediate_rep.portmappings.into_iter().next(),
            publish_image_ports: intermediate_rep.publish_image_ports.into_iter().next(),
            use_image_hosts: intermediate_rep.use_image_hosts.into_iter().next(),
            use_image_resolve_conf: intermediate_rep.use_image_resolve_conf.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerNetworkConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerNetworkConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerNetworkConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerNetworkConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerNetworkConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerNetworkConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerNetworkConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Statistics for an individual container network interface



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerNetworkStats {
    #[serde(rename = "RxBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rx_bytes: Option<i32>,

    #[serde(rename = "RxDropped")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rx_dropped: Option<i32>,

    #[serde(rename = "RxErrors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rx_errors: Option<i32>,

    #[serde(rename = "RxPackets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rx_packets: Option<i32>,

    #[serde(rename = "TxBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tx_bytes: Option<i32>,

    #[serde(rename = "TxDropped")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tx_dropped: Option<i32>,

    #[serde(rename = "TxErrors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tx_errors: Option<i32>,

    #[serde(rename = "TxPackets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tx_packets: Option<i32>,

}


impl ContainerNetworkStats {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerNetworkStats {
        ContainerNetworkStats {
            rx_bytes: None,
            rx_dropped: None,
            rx_errors: None,
            rx_packets: None,
            tx_bytes: None,
            tx_dropped: None,
            tx_errors: None,
            tx_packets: None,
        }
    }
}

/// Converts the ContainerNetworkStats value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerNetworkStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.rx_bytes.as_ref().map(|rx_bytes| {
                [
                    "RxBytes".to_string(),
                    rx_bytes.to_string(),
                ].join(",")
            }),


            self.rx_dropped.as_ref().map(|rx_dropped| {
                [
                    "RxDropped".to_string(),
                    rx_dropped.to_string(),
                ].join(",")
            }),


            self.rx_errors.as_ref().map(|rx_errors| {
                [
                    "RxErrors".to_string(),
                    rx_errors.to_string(),
                ].join(",")
            }),


            self.rx_packets.as_ref().map(|rx_packets| {
                [
                    "RxPackets".to_string(),
                    rx_packets.to_string(),
                ].join(",")
            }),


            self.tx_bytes.as_ref().map(|tx_bytes| {
                [
                    "TxBytes".to_string(),
                    tx_bytes.to_string(),
                ].join(",")
            }),


            self.tx_dropped.as_ref().map(|tx_dropped| {
                [
                    "TxDropped".to_string(),
                    tx_dropped.to_string(),
                ].join(",")
            }),


            self.tx_errors.as_ref().map(|tx_errors| {
                [
                    "TxErrors".to_string(),
                    tx_errors.to_string(),
                ].join(",")
            }),


            self.tx_packets.as_ref().map(|tx_packets| {
                [
                    "TxPackets".to_string(),
                    tx_packets.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerNetworkStats value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerNetworkStats {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rx_bytes: Vec<i32>,
            pub rx_dropped: Vec<i32>,
            pub rx_errors: Vec<i32>,
            pub rx_packets: Vec<i32>,
            pub tx_bytes: Vec<i32>,
            pub tx_dropped: Vec<i32>,
            pub tx_errors: Vec<i32>,
            pub tx_packets: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerNetworkStats".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "RxBytes" => intermediate_rep.rx_bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RxDropped" => intermediate_rep.rx_dropped.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RxErrors" => intermediate_rep.rx_errors.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RxPackets" => intermediate_rep.rx_packets.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TxBytes" => intermediate_rep.tx_bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TxDropped" => intermediate_rep.tx_dropped.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TxErrors" => intermediate_rep.tx_errors.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TxPackets" => intermediate_rep.tx_packets.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerNetworkStats".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerNetworkStats {
            rx_bytes: intermediate_rep.rx_bytes.into_iter().next(),
            rx_dropped: intermediate_rep.rx_dropped.into_iter().next(),
            rx_errors: intermediate_rep.rx_errors.into_iter().next(),
            rx_packets: intermediate_rep.rx_packets.into_iter().next(),
            tx_bytes: intermediate_rep.tx_bytes.into_iter().next(),
            tx_dropped: intermediate_rep.tx_dropped.into_iter().next(),
            tx_errors: intermediate_rep.tx_errors.into_iter().next(),
            tx_packets: intermediate_rep.tx_packets.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerNetworkStats> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerNetworkStats>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerNetworkStats>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerNetworkStats - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerNetworkStats> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerNetworkStats as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerNetworkStats - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerNode stores information about the node that a container is running on.  It's only used by the Docker Swarm standalone API



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerNode {
    #[serde(rename = "Addr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub addr: Option<String>,

    #[serde(rename = "Cpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpus: Option<i64>,

    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "IP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip: Option<String>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Memory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory: Option<i64>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl ContainerNode {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerNode {
        ContainerNode {
            addr: None,
            cpus: None,
            id: None,
            ip: None,
            labels: None,
            memory: None,
            name: None,
        }
    }
}

/// Converts the ContainerNode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.addr.as_ref().map(|addr| {
                [
                    "Addr".to_string(),
                    addr.to_string(),
                ].join(",")
            }),


            self.cpus.as_ref().map(|cpus| {
                [
                    "Cpus".to_string(),
                    cpus.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.ip.as_ref().map(|ip| {
                [
                    "IP".to_string(),
                    ip.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.memory.as_ref().map(|memory| {
                [
                    "Memory".to_string(),
                    memory.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerNode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerNode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub addr: Vec<String>,
            pub cpus: Vec<i64>,
            pub id: Vec<String>,
            pub ip: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub memory: Vec<i64>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerNode".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Addr" => intermediate_rep.addr.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Cpus" => intermediate_rep.cpus.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IP" => intermediate_rep.ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerNode".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Memory" => intermediate_rep.memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerNode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerNode {
            addr: intermediate_rep.addr.into_iter().next(),
            cpus: intermediate_rep.cpus.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            ip: intermediate_rep.ip.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            memory: intermediate_rep.memory.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerNode> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerNode>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerNode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerNode - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerNode> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerNode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerNode - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerResourceConfig {
    #[serde(rename = "intelRdt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub intel_rdt: Option<models::LinuxIntelRdt>,

/// OOMScoreAdj adjusts the score used by the OOM killer to determine processes to kill for the container's process. Optional.
    #[serde(rename = "oom_score_adj")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_score_adj: Option<i64>,

/// Rlimits are POSIX rlimits to apply to the container. Optional.
    #[serde(rename = "r_limits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_limits: Option<Vec<models::PosixRlimit>>,

    #[serde(rename = "resource_limits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_limits: Option<models::LinuxResources>,

/// IO read rate limit per cgroup per device, bytes per second
    #[serde(rename = "throttleReadBpsDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_read_bps_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

/// IO read rate limit per cgroup per device, IO per second
    #[serde(rename = "throttleReadIOPSDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_read_iops_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

/// IO write rate limit per cgroup per device, bytes per second
    #[serde(rename = "throttleWriteBpsDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_write_bps_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

/// IO write rate limit per cgroup per device, IO per second
    #[serde(rename = "throttleWriteIOPSDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_write_iops_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

/// CgroupConf are key-value options passed into the container runtime that are used to configure cgroup v2. Optional.
    #[serde(rename = "unified")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unified: Option<std::collections::HashMap<String, String>>,

/// Weight per cgroup per device, can override BlkioWeight
    #[serde(rename = "weightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_device: Option<std::collections::HashMap<String, models::LinuxWeightDevice>>,

}


impl ContainerResourceConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerResourceConfig {
        ContainerResourceConfig {
            intel_rdt: None,
            oom_score_adj: None,
            r_limits: None,
            resource_limits: None,
            throttle_read_bps_device: None,
            throttle_read_iops_device: None,
            throttle_write_bps_device: None,
            throttle_write_iops_device: None,
            unified: None,
            weight_device: None,
        }
    }
}

/// Converts the ContainerResourceConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerResourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping intelRdt in query parameter serialization


            self.oom_score_adj.as_ref().map(|oom_score_adj| {
                [
                    "oom_score_adj".to_string(),
                    oom_score_adj.to_string(),
                ].join(",")
            }),

            // Skipping r_limits in query parameter serialization

            // Skipping resource_limits in query parameter serialization

            // Skipping throttleReadBpsDevice in query parameter serialization
            // Skipping throttleReadBpsDevice in query parameter serialization

            // Skipping throttleReadIOPSDevice in query parameter serialization
            // Skipping throttleReadIOPSDevice in query parameter serialization

            // Skipping throttleWriteBpsDevice in query parameter serialization
            // Skipping throttleWriteBpsDevice in query parameter serialization

            // Skipping throttleWriteIOPSDevice in query parameter serialization
            // Skipping throttleWriteIOPSDevice in query parameter serialization

            // Skipping unified in query parameter serialization

            // Skipping weightDevice in query parameter serialization
            // Skipping weightDevice in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerResourceConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerResourceConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub intel_rdt: Vec<models::LinuxIntelRdt>,
            pub oom_score_adj: Vec<i64>,
            pub r_limits: Vec<Vec<models::PosixRlimit>>,
            pub resource_limits: Vec<models::LinuxResources>,
            pub throttle_read_bps_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub throttle_read_iops_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub throttle_write_bps_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub throttle_write_iops_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub unified: Vec<std::collections::HashMap<String, String>>,
            pub weight_device: Vec<std::collections::HashMap<String, models::LinuxWeightDevice>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerResourceConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "intelRdt" => intermediate_rep.intel_rdt.push(<models::LinuxIntelRdt as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oom_score_adj" => intermediate_rep.oom_score_adj.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "r_limits" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerResourceConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "resource_limits" => intermediate_rep.resource_limits.push(<models::LinuxResources as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "throttleReadBpsDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerResourceConfig".to_string()),
                    "throttleReadIOPSDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerResourceConfig".to_string()),
                    "throttleWriteBpsDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerResourceConfig".to_string()),
                    "throttleWriteIOPSDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerResourceConfig".to_string()),
                    "unified" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerResourceConfig".to_string()),
                    "weightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerResourceConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerResourceConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerResourceConfig {
            intel_rdt: intermediate_rep.intel_rdt.into_iter().next(),
            oom_score_adj: intermediate_rep.oom_score_adj.into_iter().next(),
            r_limits: intermediate_rep.r_limits.into_iter().next(),
            resource_limits: intermediate_rep.resource_limits.into_iter().next(),
            throttle_read_bps_device: intermediate_rep.throttle_read_bps_device.into_iter().next(),
            throttle_read_iops_device: intermediate_rep.throttle_read_iops_device.into_iter().next(),
            throttle_write_bps_device: intermediate_rep.throttle_write_bps_device.into_iter().next(),
            throttle_write_iops_device: intermediate_rep.throttle_write_iops_device.into_iter().next(),
            unified: intermediate_rep.unified.into_iter().next(),
            weight_device: intermediate_rep.weight_device.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerResourceConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerResourceConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerResourceConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerResourceConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerResourceConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerResourceConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerResourceConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerSecurityConfig is a container's security features, including SELinux, Apparmor, and Seccomp.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerSecurityConfig {
/// ApparmorProfile is the name of the Apparmor profile the container will use. Optional.
    #[serde(rename = "apparmor_profile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub apparmor_profile: Option<String>,

/// CapAdd are capabilities which will be added to the container. Conflicts with Privileged. Optional.
    #[serde(rename = "cap_add")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_add: Option<Vec<String>>,

/// CapDrop are capabilities which will be removed from the container. Conflicts with Privileged. Optional.
    #[serde(rename = "cap_drop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_drop: Option<Vec<String>>,

/// Groups are a list of supplemental groups the container's user will be granted access to. Optional.
    #[serde(rename = "groups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub groups: Option<Vec<String>>,

    #[serde(rename = "idmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub idmappings: Option<models::IdMappingOptions>,

/// LabelNested indicates whether or not the container is allowed to run fully nested containers including SELinux labelling. Optional.
    #[serde(rename = "label_nested")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub label_nested: Option<bool>,

/// Mask is the path we want to mask in the container. This masks the paths given in addition to the default list. Optional
    #[serde(rename = "mask")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mask: Option<Vec<String>>,

/// NoNewPrivileges is whether the container will set the no new privileges flag on create, which disables gaining additional privileges (e.g. via setuid) in the container. Optional.
    #[serde(rename = "no_new_privileges")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_new_privileges: Option<bool>,

/// Privileged is whether the container is privileged. Privileged does the following: Adds all devices on the system to the container. Adds all capabilities to the container. Disables Seccomp, SELinux, and Apparmor confinement. (Though SELinux can be manually re-enabled). TODO: this conflicts with things. TODO: this does more. Optional.
    #[serde(rename = "privileged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privileged: Option<bool>,

/// ProcOpts are the options used for the proc mount.
    #[serde(rename = "procfs_opts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub procfs_opts: Option<Vec<String>>,

/// ReadOnlyFilesystem indicates that everything will be mounted as read-only. Optional.
    #[serde(rename = "read_only_filesystem")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only_filesystem: Option<bool>,

/// ReadWriteTmpfs indicates that when running with a ReadOnlyFilesystem mount temporary file systems. Optional.
    #[serde(rename = "read_write_tmpfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_write_tmpfs: Option<bool>,

/// SeccompPolicy determines which seccomp profile gets applied the container. valid values: empty,default,image
    #[serde(rename = "seccomp_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seccomp_policy: Option<String>,

/// SeccompProfilePath is the path to a JSON file containing the container's Seccomp profile. If not specified, no Seccomp profile will be used. Optional.
    #[serde(rename = "seccomp_profile_path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seccomp_profile_path: Option<String>,

/// SelinuxProcessLabel is the process label the container will use. If SELinux is enabled and this is not specified, a label will be automatically generated if not specified. Optional.
    #[serde(rename = "selinux_opts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub selinux_opts: Option<Vec<String>>,

/// Umask is the umask the init process of the container will be run with.
    #[serde(rename = "umask")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub umask: Option<String>,

/// Unmask a path in the container. Some paths are masked by default, preventing them from being accessed within the container; this undoes that masking. If ALL is passed, all paths will be unmasked. Optional.
    #[serde(rename = "unmask")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unmask: Option<Vec<String>>,

/// User is the user the container will be run as. Can be given as a UID or a username; if a username, it will be resolved within the container, using the container's /etc/passwd. If unset, the container will be run as root. Optional.
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

    #[serde(rename = "userns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub userns: Option<models::Namespace>,

}


impl ContainerSecurityConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerSecurityConfig {
        ContainerSecurityConfig {
            apparmor_profile: None,
            cap_add: None,
            cap_drop: None,
            groups: None,
            idmappings: None,
            label_nested: None,
            mask: None,
            no_new_privileges: None,
            privileged: None,
            procfs_opts: None,
            read_only_filesystem: None,
            read_write_tmpfs: None,
            seccomp_policy: None,
            seccomp_profile_path: None,
            selinux_opts: None,
            umask: None,
            unmask: None,
            user: None,
            userns: None,
        }
    }
}

/// Converts the ContainerSecurityConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerSecurityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.apparmor_profile.as_ref().map(|apparmor_profile| {
                [
                    "apparmor_profile".to_string(),
                    apparmor_profile.to_string(),
                ].join(",")
            }),


            self.cap_add.as_ref().map(|cap_add| {
                [
                    "cap_add".to_string(),
                    cap_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cap_drop.as_ref().map(|cap_drop| {
                [
                    "cap_drop".to_string(),
                    cap_drop.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.groups.as_ref().map(|groups| {
                [
                    "groups".to_string(),
                    groups.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping idmappings in query parameter serialization


            self.label_nested.as_ref().map(|label_nested| {
                [
                    "label_nested".to_string(),
                    label_nested.to_string(),
                ].join(",")
            }),


            self.mask.as_ref().map(|mask| {
                [
                    "mask".to_string(),
                    mask.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.no_new_privileges.as_ref().map(|no_new_privileges| {
                [
                    "no_new_privileges".to_string(),
                    no_new_privileges.to_string(),
                ].join(",")
            }),


            self.privileged.as_ref().map(|privileged| {
                [
                    "privileged".to_string(),
                    privileged.to_string(),
                ].join(",")
            }),


            self.procfs_opts.as_ref().map(|procfs_opts| {
                [
                    "procfs_opts".to_string(),
                    procfs_opts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.read_only_filesystem.as_ref().map(|read_only_filesystem| {
                [
                    "read_only_filesystem".to_string(),
                    read_only_filesystem.to_string(),
                ].join(",")
            }),


            self.read_write_tmpfs.as_ref().map(|read_write_tmpfs| {
                [
                    "read_write_tmpfs".to_string(),
                    read_write_tmpfs.to_string(),
                ].join(",")
            }),


            self.seccomp_policy.as_ref().map(|seccomp_policy| {
                [
                    "seccomp_policy".to_string(),
                    seccomp_policy.to_string(),
                ].join(",")
            }),


            self.seccomp_profile_path.as_ref().map(|seccomp_profile_path| {
                [
                    "seccomp_profile_path".to_string(),
                    seccomp_profile_path.to_string(),
                ].join(",")
            }),


            self.selinux_opts.as_ref().map(|selinux_opts| {
                [
                    "selinux_opts".to_string(),
                    selinux_opts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.umask.as_ref().map(|umask| {
                [
                    "umask".to_string(),
                    umask.to_string(),
                ].join(",")
            }),


            self.unmask.as_ref().map(|unmask| {
                [
                    "unmask".to_string(),
                    unmask.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping userns in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerSecurityConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerSecurityConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub apparmor_profile: Vec<String>,
            pub cap_add: Vec<Vec<String>>,
            pub cap_drop: Vec<Vec<String>>,
            pub groups: Vec<Vec<String>>,
            pub idmappings: Vec<models::IdMappingOptions>,
            pub label_nested: Vec<bool>,
            pub mask: Vec<Vec<String>>,
            pub no_new_privileges: Vec<bool>,
            pub privileged: Vec<bool>,
            pub procfs_opts: Vec<Vec<String>>,
            pub read_only_filesystem: Vec<bool>,
            pub read_write_tmpfs: Vec<bool>,
            pub seccomp_policy: Vec<String>,
            pub seccomp_profile_path: Vec<String>,
            pub selinux_opts: Vec<Vec<String>>,
            pub umask: Vec<String>,
            pub unmask: Vec<Vec<String>>,
            pub user: Vec<String>,
            pub userns: Vec<models::Namespace>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerSecurityConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apparmor_profile" => intermediate_rep.apparmor_profile.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "cap_add" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerSecurityConfig".to_string()),
                    "cap_drop" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerSecurityConfig".to_string()),
                    "groups" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerSecurityConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "idmappings" => intermediate_rep.idmappings.push(<models::IdMappingOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "label_nested" => intermediate_rep.label_nested.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "mask" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerSecurityConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "no_new_privileges" => intermediate_rep.no_new_privileges.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "privileged" => intermediate_rep.privileged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "procfs_opts" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerSecurityConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "read_only_filesystem" => intermediate_rep.read_only_filesystem.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "read_write_tmpfs" => intermediate_rep.read_write_tmpfs.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seccomp_policy" => intermediate_rep.seccomp_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seccomp_profile_path" => intermediate_rep.seccomp_profile_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "selinux_opts" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerSecurityConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "umask" => intermediate_rep.umask.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "unmask" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerSecurityConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userns" => intermediate_rep.userns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerSecurityConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerSecurityConfig {
            apparmor_profile: intermediate_rep.apparmor_profile.into_iter().next(),
            cap_add: intermediate_rep.cap_add.into_iter().next(),
            cap_drop: intermediate_rep.cap_drop.into_iter().next(),
            groups: intermediate_rep.groups.into_iter().next(),
            idmappings: intermediate_rep.idmappings.into_iter().next(),
            label_nested: intermediate_rep.label_nested.into_iter().next(),
            mask: intermediate_rep.mask.into_iter().next(),
            no_new_privileges: intermediate_rep.no_new_privileges.into_iter().next(),
            privileged: intermediate_rep.privileged.into_iter().next(),
            procfs_opts: intermediate_rep.procfs_opts.into_iter().next(),
            read_only_filesystem: intermediate_rep.read_only_filesystem.into_iter().next(),
            read_write_tmpfs: intermediate_rep.read_write_tmpfs.into_iter().next(),
            seccomp_policy: intermediate_rep.seccomp_policy.into_iter().next(),
            seccomp_profile_path: intermediate_rep.seccomp_profile_path.into_iter().next(),
            selinux_opts: intermediate_rep.selinux_opts.into_iter().next(),
            umask: intermediate_rep.umask.into_iter().next(),
            unmask: intermediate_rep.unmask.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            userns: intermediate_rep.userns.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerSecurityConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerSecurityConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerSecurityConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerSecurityConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerSecurityConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerSecurityConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerSecurityConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerSize holds the size of the container's root filesystem and top read-write layer.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerSize {
    #[serde(rename = "rootFsSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub root_fs_size: Option<i64>,

    #[serde(rename = "rwSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rw_size: Option<i64>,

}


impl ContainerSize {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerSize {
        ContainerSize {
            root_fs_size: None,
            rw_size: None,
        }
    }
}

/// Converts the ContainerSize value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerSize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.root_fs_size.as_ref().map(|root_fs_size| {
                [
                    "rootFsSize".to_string(),
                    root_fs_size.to_string(),
                ].join(",")
            }),


            self.rw_size.as_ref().map(|rw_size| {
                [
                    "rwSize".to_string(),
                    rw_size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerSize value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerSize {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub root_fs_size: Vec<i64>,
            pub rw_size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerSize".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rootFsSize" => intermediate_rep.root_fs_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rwSize" => intermediate_rep.rw_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerSize".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerSize {
            root_fs_size: intermediate_rep.root_fs_size.into_iter().next(),
            rw_size: intermediate_rep.rw_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerSize> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerSize>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerSize>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerSize - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerSize> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerSize as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerSize - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerState stores container's running state it's part of ContainerJSONBase and will return by \"inspect\" command



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerState {
    #[serde(rename = "Dead")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dead: Option<bool>,

    #[serde(rename = "Error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,

    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i64>,

    #[serde(rename = "FinishedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub finished_at: Option<String>,

    #[serde(rename = "Health")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub health: Option<models::Health>,

    #[serde(rename = "OOMKilled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_killed: Option<bool>,

    #[serde(rename = "Paused")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paused: Option<bool>,

    #[serde(rename = "Pid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid: Option<i64>,

    #[serde(rename = "Restarting")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restarting: Option<bool>,

    #[serde(rename = "Running")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub running: Option<bool>,

    #[serde(rename = "StartedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<String>,

    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl ContainerState {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerState {
        ContainerState {
            dead: None,
            error: None,
            exit_code: None,
            finished_at: None,
            health: None,
            oom_killed: None,
            paused: None,
            pid: None,
            restarting: None,
            running: None,
            started_at: None,
            status: None,
        }
    }
}

/// Converts the ContainerState value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.dead.as_ref().map(|dead| {
                [
                    "Dead".to_string(),
                    dead.to_string(),
                ].join(",")
            }),


            self.error.as_ref().map(|error| {
                [
                    "Error".to_string(),
                    error.to_string(),
                ].join(",")
            }),


            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),


            self.finished_at.as_ref().map(|finished_at| {
                [
                    "FinishedAt".to_string(),
                    finished_at.to_string(),
                ].join(",")
            }),

            // Skipping Health in query parameter serialization


            self.oom_killed.as_ref().map(|oom_killed| {
                [
                    "OOMKilled".to_string(),
                    oom_killed.to_string(),
                ].join(",")
            }),


            self.paused.as_ref().map(|paused| {
                [
                    "Paused".to_string(),
                    paused.to_string(),
                ].join(",")
            }),


            self.pid.as_ref().map(|pid| {
                [
                    "Pid".to_string(),
                    pid.to_string(),
                ].join(",")
            }),


            self.restarting.as_ref().map(|restarting| {
                [
                    "Restarting".to_string(),
                    restarting.to_string(),
                ].join(",")
            }),


            self.running.as_ref().map(|running| {
                [
                    "Running".to_string(),
                    running.to_string(),
                ].join(",")
            }),


            self.started_at.as_ref().map(|started_at| {
                [
                    "StartedAt".to_string(),
                    started_at.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerState value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerState {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dead: Vec<bool>,
            pub error: Vec<String>,
            pub exit_code: Vec<i64>,
            pub finished_at: Vec<String>,
            pub health: Vec<models::Health>,
            pub oom_killed: Vec<bool>,
            pub paused: Vec<bool>,
            pub pid: Vec<i64>,
            pub restarting: Vec<bool>,
            pub running: Vec<bool>,
            pub started_at: Vec<String>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerState".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Dead" => intermediate_rep.dead.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Error" => intermediate_rep.error.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "FinishedAt" => intermediate_rep.finished_at.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Health" => intermediate_rep.health.push(<models::Health as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OOMKilled" => intermediate_rep.oom_killed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Paused" => intermediate_rep.paused.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Pid" => intermediate_rep.pid.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Restarting" => intermediate_rep.restarting.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Running" => intermediate_rep.running.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartedAt" => intermediate_rep.started_at.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerState".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerState {
            dead: intermediate_rep.dead.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            finished_at: intermediate_rep.finished_at.into_iter().next(),
            health: intermediate_rep.health.into_iter().next(),
            oom_killed: intermediate_rep.oom_killed.into_iter().next(),
            paused: intermediate_rep.paused.into_iter().next(),
            pid: intermediate_rep.pid.into_iter().next(),
            restarting: intermediate_rep.restarting.into_iter().next(),
            running: intermediate_rep.running.into_iter().next(),
            started_at: intermediate_rep.started_at.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerState> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerState>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerState>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerState - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerState> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerState as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerState - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerStats contains the statistics information for a running container



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerStats {
    #[serde(rename = "AvgCPU")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub avg_cpu: Option<f64>,

    #[serde(rename = "BlockInput")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_input: Option<i32>,

    #[serde(rename = "BlockOutput")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_output: Option<i32>,

    #[serde(rename = "CPU")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu: Option<f64>,

    #[serde(rename = "CPUNano")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_nano: Option<i32>,

    #[serde(rename = "CPUSystemNano")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_system_nano: Option<i32>,

    #[serde(rename = "ContainerID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_id: Option<String>,

    #[serde(rename = "Duration")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration: Option<i32>,

    #[serde(rename = "MemLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem_limit: Option<i32>,

    #[serde(rename = "MemPerc")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem_perc: Option<f64>,

    #[serde(rename = "MemUsage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem_usage: Option<i32>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Map of interface name to network statistics for that interface.
    #[serde(rename = "Network")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network: Option<std::collections::HashMap<String, models::ContainerNetworkStats>>,

    #[serde(rename = "PIDs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids: Option<i32>,

    #[serde(rename = "PerCPU")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub per_cpu: Option<Vec<i32>>,

    #[serde(rename = "SystemNano")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_nano: Option<i32>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "UpTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub up_time: Option<i64>,

}


impl ContainerStats {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerStats {
        ContainerStats {
            avg_cpu: None,
            block_input: None,
            block_output: None,
            cpu: None,
            cpu_nano: None,
            cpu_system_nano: None,
            container_id: None,
            duration: None,
            mem_limit: None,
            mem_perc: None,
            mem_usage: None,
            name: None,
            network: None,
            pids: None,
            per_cpu: None,
            system_nano: None,
            up_time: None,
        }
    }
}

/// Converts the ContainerStats value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerStats {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.avg_cpu.as_ref().map(|avg_cpu| {
                [
                    "AvgCPU".to_string(),
                    avg_cpu.to_string(),
                ].join(",")
            }),


            self.block_input.as_ref().map(|block_input| {
                [
                    "BlockInput".to_string(),
                    block_input.to_string(),
                ].join(",")
            }),


            self.block_output.as_ref().map(|block_output| {
                [
                    "BlockOutput".to_string(),
                    block_output.to_string(),
                ].join(",")
            }),


            self.cpu.as_ref().map(|cpu| {
                [
                    "CPU".to_string(),
                    cpu.to_string(),
                ].join(",")
            }),


            self.cpu_nano.as_ref().map(|cpu_nano| {
                [
                    "CPUNano".to_string(),
                    cpu_nano.to_string(),
                ].join(",")
            }),


            self.cpu_system_nano.as_ref().map(|cpu_system_nano| {
                [
                    "CPUSystemNano".to_string(),
                    cpu_system_nano.to_string(),
                ].join(",")
            }),


            self.container_id.as_ref().map(|container_id| {
                [
                    "ContainerID".to_string(),
                    container_id.to_string(),
                ].join(",")
            }),


            self.duration.as_ref().map(|duration| {
                [
                    "Duration".to_string(),
                    duration.to_string(),
                ].join(",")
            }),


            self.mem_limit.as_ref().map(|mem_limit| {
                [
                    "MemLimit".to_string(),
                    mem_limit.to_string(),
                ].join(",")
            }),


            self.mem_perc.as_ref().map(|mem_perc| {
                [
                    "MemPerc".to_string(),
                    mem_perc.to_string(),
                ].join(",")
            }),


            self.mem_usage.as_ref().map(|mem_usage| {
                [
                    "MemUsage".to_string(),
                    mem_usage.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping Network in query parameter serialization
            // Skipping Network in query parameter serialization


            self.pids.as_ref().map(|pids| {
                [
                    "PIDs".to_string(),
                    pids.to_string(),
                ].join(",")
            }),


            self.per_cpu.as_ref().map(|per_cpu| {
                [
                    "PerCPU".to_string(),
                    per_cpu.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.system_nano.as_ref().map(|system_nano| {
                [
                    "SystemNano".to_string(),
                    system_nano.to_string(),
                ].join(",")
            }),


            self.up_time.as_ref().map(|up_time| {
                [
                    "UpTime".to_string(),
                    up_time.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerStats value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerStats {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub avg_cpu: Vec<f64>,
            pub block_input: Vec<i32>,
            pub block_output: Vec<i32>,
            pub cpu: Vec<f64>,
            pub cpu_nano: Vec<i32>,
            pub cpu_system_nano: Vec<i32>,
            pub container_id: Vec<String>,
            pub duration: Vec<i32>,
            pub mem_limit: Vec<i32>,
            pub mem_perc: Vec<f64>,
            pub mem_usage: Vec<i32>,
            pub name: Vec<String>,
            pub network: Vec<std::collections::HashMap<String, models::ContainerNetworkStats>>,
            pub pids: Vec<i32>,
            pub per_cpu: Vec<Vec<i32>>,
            pub system_nano: Vec<i32>,
            pub up_time: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerStats".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AvgCPU" => intermediate_rep.avg_cpu.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "BlockInput" => intermediate_rep.block_input.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "BlockOutput" => intermediate_rep.block_output.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CPU" => intermediate_rep.cpu.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CPUNano" => intermediate_rep.cpu_nano.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CPUSystemNano" => intermediate_rep.cpu_system_nano.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ContainerID" => intermediate_rep.container_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Duration" => intermediate_rep.duration.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemLimit" => intermediate_rep.mem_limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemPerc" => intermediate_rep.mem_perc.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemUsage" => intermediate_rep.mem_usage.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Network" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStats".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "PIDs" => intermediate_rep.pids.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "PerCPU" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStats".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SystemNano" => intermediate_rep.system_nano.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UpTime" => intermediate_rep.up_time.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerStats".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerStats {
            avg_cpu: intermediate_rep.avg_cpu.into_iter().next(),
            block_input: intermediate_rep.block_input.into_iter().next(),
            block_output: intermediate_rep.block_output.into_iter().next(),
            cpu: intermediate_rep.cpu.into_iter().next(),
            cpu_nano: intermediate_rep.cpu_nano.into_iter().next(),
            cpu_system_nano: intermediate_rep.cpu_system_nano.into_iter().next(),
            container_id: intermediate_rep.container_id.into_iter().next(),
            duration: intermediate_rep.duration.into_iter().next(),
            mem_limit: intermediate_rep.mem_limit.into_iter().next(),
            mem_perc: intermediate_rep.mem_perc.into_iter().next(),
            mem_usage: intermediate_rep.mem_usage.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            network: intermediate_rep.network.into_iter().next(),
            pids: intermediate_rep.pids.into_iter().next(),
            per_cpu: intermediate_rep.per_cpu.into_iter().next(),
            system_nano: intermediate_rep.system_nano.into_iter().next(),
            up_time: intermediate_rep.up_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerStats> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerStats>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerStats>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerStats - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerStats> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerStats as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerStats - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerStorageConfig contains information on the storage configuration of a container.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerStorageConfig {
/// ChrootDirs is an additional set of directories that need to be treated as root directories. Standard bind mounts will be mounted into paths relative to these directories. Optional.
    #[serde(rename = "chroot_directories")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chroot_directories: Option<Vec<String>>,

/// Create the working directory if it doesn't exist. If unset, it doesn't create it. Optional.
    #[serde(rename = "create_working_dir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_working_dir: Option<bool>,

/// DeviceCgroupRule are device cgroup rules that allow containers to use additional types of devices.
    #[serde(rename = "device_cgroup_rule")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_cgroup_rule: Option<Vec<models::LinuxDeviceCgroup>>,

/// Devices are devices that will be added to the container. Optional.
    #[serde(rename = "devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::LinuxDevice>>,

/// DevicesFrom specifies that this container will mount the device(s) from other container(s). Optional.
    #[serde(rename = "devices_from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices_from: Option<Vec<String>>,

/// HostDeviceList is used to recreate the mounted device on inherited containers
    #[serde(rename = "host_device_list")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_device_list: Option<Vec<models::LinuxDevice>>,

/// Image is the image the container will be based on. The image will be used as the container's root filesystem, and its environment vars, volumes, and other configuration will be applied to the container. Conflicts with Rootfs. At least one of Image or Rootfs must be specified.
    #[serde(rename = "image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

/// ImageArch is the user-specified image architecture. Used to select a different variant from a manifest list. Optional.
    #[serde(rename = "image_arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_arch: Option<String>,

/// ImageOS is the user-specified OS of the image. Used to select a different variant from a manifest list. Optional.
    #[serde(rename = "image_os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_os: Option<String>,

/// ImageVariant is the user-specified image variant. Used to select a different variant from a manifest list. Optional.
    #[serde(rename = "image_variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_variant: Option<String>,

/// ImageVolumeMode indicates how image volumes will be created. Supported modes are \"ignore\" (do not create), \"tmpfs\" (create as tmpfs), and \"anonymous\" (create as anonymous volumes). The default if unset is anonymous. Optional.
    #[serde(rename = "image_volume_mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_volume_mode: Option<String>,

/// Image volumes bind-mount a container-image mount into the container. Optional.
    #[serde(rename = "image_volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_volumes: Option<Vec<models::ImageVolume>>,

/// Init specifies that an init binary will be mounted into the container, and will be used as PID1. Optional.
    #[serde(rename = "init")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init: Option<bool>,

/// InitPath specifies the path to the init binary that will be added if Init is specified above. If not specified, the default set in the Libpod config will be used. Ignored if Init above is not set. Optional.
    #[serde(rename = "init_path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init_path: Option<String>,

    #[serde(rename = "ipcns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipcns: Option<models::Namespace>,

/// Mounts are mounts that will be added to the container. These will supersede Image Volumes and VolumesFrom volumes where there are conflicts. Optional.
    #[serde(rename = "mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::Mount>>,

/// Overlay volumes are named volumes that will be added to the container. Optional.
    #[serde(rename = "overlay_volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub overlay_volumes: Option<Vec<models::OverlayVolume>>,

/// RawImageName is the user-specified and unprocessed input referring to a local or a remote image. Optional, but strongly encouraged to be set if Image is set.
    #[serde(rename = "raw_image_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_image_name: Option<String>,

/// Rootfs is the path to a directory that will be used as the container's root filesystem. No modification will be made to the directory, it will be directly mounted into the container as root. Conflicts with Image. At least one of Image or Rootfs must be specified.
    #[serde(rename = "rootfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs: Option<String>,

/// RootfsMapping specifies if there are UID/GID mappings to apply to the rootfs. Optional.
    #[serde(rename = "rootfs_mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs_mapping: Option<String>,

/// RootfsOverlay tells if rootfs is actually an overlay on top of base path. Optional.
    #[serde(rename = "rootfs_overlay")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs_overlay: Option<bool>,

/// RootfsPropagation is the rootfs propagation mode for the container. If not set, the default of rslave will be used. Optional.
    #[serde(rename = "rootfs_propagation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs_propagation: Option<String>,

/// Secrets are the secrets that will be added to the container Optional.
    #[serde(rename = "secrets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<models::Secret>>,

/// ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes. Conflicts with ShmSize if IpcNS is not private. Optional.
    #[serde(rename = "shm_size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size: Option<i64>,

/// ShmSizeSystemd is the size of systemd-specific tmpfs mounts specifically /run, /run/lock, /var/log/journal and /tmp. Optional
    #[serde(rename = "shm_size_systemd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size_systemd: Option<i64>,

/// StorageOpts is the container's storage options Optional.
    #[serde(rename = "storage_opts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_opts: Option<std::collections::HashMap<String, String>>,

/// Volatile specifies whether the container storage can be optimized at the cost of not syncing all the dirty files in memory. Optional.
    #[serde(rename = "volatile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volatile: Option<bool>,

/// Volumes are named volumes that will be added to the container. These will supersede Image Volumes and VolumesFrom volumes where there are conflicts. Optional.
    #[serde(rename = "volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<Vec<models::NamedVolume>>,

/// VolumesFrom is a set of containers whose volumes will be added to this container. The name or ID of the container must be provided, and may optionally be followed by a : and then one or more comma-separated options. Valid options are 'ro', 'rw', and 'z'. Options will be used for all volumes sourced from the container. Optional.
    #[serde(rename = "volumes_from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

/// WorkDir is the container's working directory. If unset, the default, /, will be used. Optional.
    #[serde(rename = "work_dir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub work_dir: Option<String>,

}


impl ContainerStorageConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerStorageConfig {
        ContainerStorageConfig {
            chroot_directories: None,
            create_working_dir: None,
            device_cgroup_rule: None,
            devices: None,
            devices_from: None,
            host_device_list: None,
            image: None,
            image_arch: None,
            image_os: None,
            image_variant: None,
            image_volume_mode: None,
            image_volumes: None,
            init: None,
            init_path: None,
            ipcns: None,
            mounts: None,
            overlay_volumes: None,
            raw_image_name: None,
            rootfs: None,
            rootfs_mapping: None,
            rootfs_overlay: None,
            rootfs_propagation: None,
            secrets: None,
            shm_size: None,
            shm_size_systemd: None,
            storage_opts: None,
            volatile: None,
            volumes: None,
            volumes_from: None,
            work_dir: None,
        }
    }
}

/// Converts the ContainerStorageConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerStorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.chroot_directories.as_ref().map(|chroot_directories| {
                [
                    "chroot_directories".to_string(),
                    chroot_directories.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.create_working_dir.as_ref().map(|create_working_dir| {
                [
                    "create_working_dir".to_string(),
                    create_working_dir.to_string(),
                ].join(",")
            }),

            // Skipping device_cgroup_rule in query parameter serialization

            // Skipping devices in query parameter serialization


            self.devices_from.as_ref().map(|devices_from| {
                [
                    "devices_from".to_string(),
                    devices_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping host_device_list in query parameter serialization


            self.image.as_ref().map(|image| {
                [
                    "image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.image_arch.as_ref().map(|image_arch| {
                [
                    "image_arch".to_string(),
                    image_arch.to_string(),
                ].join(",")
            }),


            self.image_os.as_ref().map(|image_os| {
                [
                    "image_os".to_string(),
                    image_os.to_string(),
                ].join(",")
            }),


            self.image_variant.as_ref().map(|image_variant| {
                [
                    "image_variant".to_string(),
                    image_variant.to_string(),
                ].join(",")
            }),


            self.image_volume_mode.as_ref().map(|image_volume_mode| {
                [
                    "image_volume_mode".to_string(),
                    image_volume_mode.to_string(),
                ].join(",")
            }),

            // Skipping image_volumes in query parameter serialization


            self.init.as_ref().map(|init| {
                [
                    "init".to_string(),
                    init.to_string(),
                ].join(",")
            }),


            self.init_path.as_ref().map(|init_path| {
                [
                    "init_path".to_string(),
                    init_path.to_string(),
                ].join(",")
            }),

            // Skipping ipcns in query parameter serialization

            // Skipping mounts in query parameter serialization

            // Skipping overlay_volumes in query parameter serialization


            self.raw_image_name.as_ref().map(|raw_image_name| {
                [
                    "raw_image_name".to_string(),
                    raw_image_name.to_string(),
                ].join(",")
            }),


            self.rootfs.as_ref().map(|rootfs| {
                [
                    "rootfs".to_string(),
                    rootfs.to_string(),
                ].join(",")
            }),


            self.rootfs_mapping.as_ref().map(|rootfs_mapping| {
                [
                    "rootfs_mapping".to_string(),
                    rootfs_mapping.to_string(),
                ].join(",")
            }),


            self.rootfs_overlay.as_ref().map(|rootfs_overlay| {
                [
                    "rootfs_overlay".to_string(),
                    rootfs_overlay.to_string(),
                ].join(",")
            }),


            self.rootfs_propagation.as_ref().map(|rootfs_propagation| {
                [
                    "rootfs_propagation".to_string(),
                    rootfs_propagation.to_string(),
                ].join(",")
            }),

            // Skipping secrets in query parameter serialization


            self.shm_size.as_ref().map(|shm_size| {
                [
                    "shm_size".to_string(),
                    shm_size.to_string(),
                ].join(",")
            }),


            self.shm_size_systemd.as_ref().map(|shm_size_systemd| {
                [
                    "shm_size_systemd".to_string(),
                    shm_size_systemd.to_string(),
                ].join(",")
            }),

            // Skipping storage_opts in query parameter serialization


            self.volatile.as_ref().map(|volatile| {
                [
                    "volatile".to_string(),
                    volatile.to_string(),
                ].join(",")
            }),

            // Skipping volumes in query parameter serialization


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "volumes_from".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.work_dir.as_ref().map(|work_dir| {
                [
                    "work_dir".to_string(),
                    work_dir.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerStorageConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerStorageConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub chroot_directories: Vec<Vec<String>>,
            pub create_working_dir: Vec<bool>,
            pub device_cgroup_rule: Vec<Vec<models::LinuxDeviceCgroup>>,
            pub devices: Vec<Vec<models::LinuxDevice>>,
            pub devices_from: Vec<Vec<String>>,
            pub host_device_list: Vec<Vec<models::LinuxDevice>>,
            pub image: Vec<String>,
            pub image_arch: Vec<String>,
            pub image_os: Vec<String>,
            pub image_variant: Vec<String>,
            pub image_volume_mode: Vec<String>,
            pub image_volumes: Vec<Vec<models::ImageVolume>>,
            pub init: Vec<bool>,
            pub init_path: Vec<String>,
            pub ipcns: Vec<models::Namespace>,
            pub mounts: Vec<Vec<models::Mount>>,
            pub overlay_volumes: Vec<Vec<models::OverlayVolume>>,
            pub raw_image_name: Vec<String>,
            pub rootfs: Vec<String>,
            pub rootfs_mapping: Vec<String>,
            pub rootfs_overlay: Vec<bool>,
            pub rootfs_propagation: Vec<String>,
            pub secrets: Vec<Vec<models::Secret>>,
            pub shm_size: Vec<i64>,
            pub shm_size_systemd: Vec<i64>,
            pub storage_opts: Vec<std::collections::HashMap<String, String>>,
            pub volatile: Vec<bool>,
            pub volumes: Vec<Vec<models::NamedVolume>>,
            pub volumes_from: Vec<Vec<String>>,
            pub work_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerStorageConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "chroot_directories" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "create_working_dir" => intermediate_rep.create_working_dir.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "device_cgroup_rule" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    "devices" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    "devices_from" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    "host_device_list" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_arch" => intermediate_rep.image_arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_os" => intermediate_rep.image_os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_variant" => intermediate_rep.image_variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_volume_mode" => intermediate_rep.image_volume_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "image_volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "init" => intermediate_rep.init.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "init_path" => intermediate_rep.init_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipcns" => intermediate_rep.ipcns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    "overlay_volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "raw_image_name" => intermediate_rep.raw_image_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs" => intermediate_rep.rootfs.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs_mapping" => intermediate_rep.rootfs_mapping.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs_overlay" => intermediate_rep.rootfs_overlay.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs_propagation" => intermediate_rep.rootfs_propagation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "secrets" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shm_size" => intermediate_rep.shm_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shm_size_systemd" => intermediate_rep.shm_size_systemd.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "storage_opts" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "volatile" => intermediate_rep.volatile.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    "volumes_from" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerStorageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "work_dir" => intermediate_rep.work_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerStorageConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerStorageConfig {
            chroot_directories: intermediate_rep.chroot_directories.into_iter().next(),
            create_working_dir: intermediate_rep.create_working_dir.into_iter().next(),
            device_cgroup_rule: intermediate_rep.device_cgroup_rule.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            devices_from: intermediate_rep.devices_from.into_iter().next(),
            host_device_list: intermediate_rep.host_device_list.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            image_arch: intermediate_rep.image_arch.into_iter().next(),
            image_os: intermediate_rep.image_os.into_iter().next(),
            image_variant: intermediate_rep.image_variant.into_iter().next(),
            image_volume_mode: intermediate_rep.image_volume_mode.into_iter().next(),
            image_volumes: intermediate_rep.image_volumes.into_iter().next(),
            init: intermediate_rep.init.into_iter().next(),
            init_path: intermediate_rep.init_path.into_iter().next(),
            ipcns: intermediate_rep.ipcns.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            overlay_volumes: intermediate_rep.overlay_volumes.into_iter().next(),
            raw_image_name: intermediate_rep.raw_image_name.into_iter().next(),
            rootfs: intermediate_rep.rootfs.into_iter().next(),
            rootfs_mapping: intermediate_rep.rootfs_mapping.into_iter().next(),
            rootfs_overlay: intermediate_rep.rootfs_overlay.into_iter().next(),
            rootfs_propagation: intermediate_rep.rootfs_propagation.into_iter().next(),
            secrets: intermediate_rep.secrets.into_iter().next(),
            shm_size: intermediate_rep.shm_size.into_iter().next(),
            shm_size_systemd: intermediate_rep.shm_size_systemd.into_iter().next(),
            storage_opts: intermediate_rep.storage_opts.into_iter().next(),
            volatile: intermediate_rep.volatile.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
            work_dir: intermediate_rep.work_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerStorageConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerStorageConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerStorageConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerStorageConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerStorageConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerStorageConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerStorageConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerStore describes the quantity of containers in the store by status



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerStore {
    #[serde(rename = "number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,

    #[serde(rename = "paused")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paused: Option<i64>,

    #[serde(rename = "running")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub running: Option<i64>,

    #[serde(rename = "stopped")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stopped: Option<i64>,

}


impl ContainerStore {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerStore {
        ContainerStore {
            number: None,
            paused: None,
            running: None,
            stopped: None,
        }
    }
}

/// Converts the ContainerStore value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerStore {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.number.as_ref().map(|number| {
                [
                    "number".to_string(),
                    number.to_string(),
                ].join(",")
            }),


            self.paused.as_ref().map(|paused| {
                [
                    "paused".to_string(),
                    paused.to_string(),
                ].join(",")
            }),


            self.running.as_ref().map(|running| {
                [
                    "running".to_string(),
                    running.to_string(),
                ].join(",")
            }),


            self.stopped.as_ref().map(|stopped| {
                [
                    "stopped".to_string(),
                    stopped.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerStore value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerStore {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub number: Vec<i64>,
            pub paused: Vec<i64>,
            pub running: Vec<i64>,
            pub stopped: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerStore".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "number" => intermediate_rep.number.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "paused" => intermediate_rep.paused.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "running" => intermediate_rep.running.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stopped" => intermediate_rep.stopped.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerStore".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerStore {
            number: intermediate_rep.number.into_iter().next(),
            paused: intermediate_rep.paused.into_iter().next(),
            running: intermediate_rep.running.into_iter().next(),
            stopped: intermediate_rep.stopped.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerStore> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerStore>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerStore>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerStore - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerStore> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerStore as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerStore - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerTopOKBody OK response to ContainerTop operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerTopOkBody {
/// Each process running in the container, where each is process is an array of values corresponding to the titles.
    #[serde(rename = "Processes")]
    pub processes: Vec<Vec<String>>,

/// The ps column titles
    #[serde(rename = "Titles")]
    pub titles: Vec<String>,

}


impl ContainerTopOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(processes: Vec<Vec<String>>, titles: Vec<String>, ) -> ContainerTopOkBody {
        ContainerTopOkBody {
            processes,
            titles,
        }
    }
}

/// Converts the ContainerTopOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerTopOkBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Processes in query parameter serialization


            Some("Titles".to_string()),
            Some(self.titles.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerTopOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerTopOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub processes: Vec<Vec<Vec<String>>>,
            pub titles: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerTopOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Processes" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerTopOkBody".to_string()),
                    "Titles" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerTopOkBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerTopOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerTopOkBody {
            processes: intermediate_rep.processes.into_iter().next().ok_or_else(|| "Processes missing in ContainerTopOkBody".to_string())?,
            titles: intermediate_rep.titles.into_iter().next().ok_or_else(|| "Titles missing in ContainerTopOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerTopOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerTopOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerTopOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerTopOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerTopOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerTopOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerTopOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerUpdateOKBody OK response to ContainerUpdate operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerUpdateOkBody {
/// warnings
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,

}


impl ContainerUpdateOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(warnings: Vec<String>, ) -> ContainerUpdateOkBody {
        ContainerUpdateOkBody {
            warnings,
        }
    }
}

/// Converts the ContainerUpdateOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerUpdateOkBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Warnings".to_string()),
            Some(self.warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerUpdateOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerUpdateOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerUpdateOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainerUpdateOkBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerUpdateOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerUpdateOkBody {
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "Warnings missing in ContainerUpdateOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerUpdateOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerUpdateOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerUpdateOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerUpdateOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerUpdateOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerUpdateOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerUpdateOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerUpdateRequest {
}


impl ContainerUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerUpdateRequest {
        ContainerUpdateRequest {
        }
    }
}

/// Converts the ContainerUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerUpdateRequest {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerWait200Response {
    #[serde(rename = "Error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<models::ContainerWait200ResponseError>,

/// container exit code
    #[serde(rename = "StatusCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_code: Option<i64>,

}


impl ContainerWait200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerWait200Response {
        ContainerWait200Response {
            error: None,
            status_code: None,
        }
    }
}

/// Converts the ContainerWait200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerWait200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Error in query parameter serialization


            self.status_code.as_ref().map(|status_code| {
                [
                    "StatusCode".to_string(),
                    status_code.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerWait200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerWait200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::ContainerWait200ResponseError>,
            pub status_code: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerWait200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Error" => intermediate_rep.error.push(<models::ContainerWait200ResponseError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StatusCode" => intermediate_rep.status_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerWait200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerWait200Response {
            error: intermediate_rep.error.into_iter().next(),
            status_code: intermediate_rep.status_code.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerWait200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerWait200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerWait200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerWait200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerWait200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerWait200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerWait200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainerWait200ResponseError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}


impl ContainerWait200ResponseError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainerWait200ResponseError {
        ContainerWait200ResponseError {
            message: None,
        }
    }
}

/// Converts the ContainerWait200ResponseError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainerWait200ResponseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.message.as_ref().map(|message| {
                [
                    "Message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainerWait200ResponseError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainerWait200ResponseError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainerWait200ResponseError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainerWait200ResponseError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainerWait200ResponseError {
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainerWait200ResponseError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainerWait200ResponseError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainerWait200ResponseError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainerWait200ResponseError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainerWait200ResponseError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainerWait200ResponseError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainerWait200ResponseError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainersPruneReport {
    #[serde(rename = "ContainersDeleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers_deleted: Option<Vec<String>>,

    #[serde(rename = "SpaceReclaimed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub space_reclaimed: Option<i32>,

}


impl ContainersPruneReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainersPruneReport {
        ContainersPruneReport {
            containers_deleted: None,
            space_reclaimed: None,
        }
    }
}

/// Converts the ContainersPruneReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainersPruneReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.containers_deleted.as_ref().map(|containers_deleted| {
                [
                    "ContainersDeleted".to_string(),
                    containers_deleted.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.space_reclaimed.as_ref().map(|space_reclaimed| {
                [
                    "SpaceReclaimed".to_string(),
                    space_reclaimed.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainersPruneReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainersPruneReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub containers_deleted: Vec<Vec<String>>,
            pub space_reclaimed: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainersPruneReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ContainersDeleted" => return std::result::Result::Err("Parsing a container in this style is not supported in ContainersPruneReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SpaceReclaimed" => intermediate_rep.space_reclaimed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainersPruneReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainersPruneReport {
            containers_deleted: intermediate_rep.containers_deleted.into_iter().next(),
            space_reclaimed: intermediate_rep.space_reclaimed.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainersPruneReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainersPruneReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainersPruneReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainersPruneReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainersPruneReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainersPruneReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainersPruneReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContainersPruneReportLibpod {
/// Error which occurred during prune operation (if any). This field is optional and may be omitted if no error occurred.
    #[serde(rename = "Err")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub err: Option<Nullable<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

}


impl ContainersPruneReportLibpod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ContainersPruneReportLibpod {
        ContainersPruneReportLibpod {
            err: None,
            id: None,
            size: None,
        }
    }
}

/// Converts the ContainersPruneReportLibpod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContainersPruneReportLibpod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.err.as_ref().map(|err| {
                [
                    "Err".to_string(),
                    err.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContainersPruneReportLibpod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContainersPruneReportLibpod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub err: Vec<String>,
            pub id: Vec<String>,
            pub size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContainersPruneReportLibpod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Err" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ContainersPruneReportLibpod".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContainersPruneReportLibpod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContainersPruneReportLibpod {
            err: std::result::Result::Err("Nullable types not supported in ContainersPruneReportLibpod".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContainersPruneReportLibpod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContainersPruneReportLibpod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContainersPruneReportLibpod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ContainersPruneReportLibpod - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContainersPruneReportLibpod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContainersPruneReportLibpod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ContainersPruneReportLibpod - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CpuUsage {
    #[serde(rename = "idlePercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_percent: Option<f64>,

    #[serde(rename = "systemPercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_percent: Option<f64>,

    #[serde(rename = "userPercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_percent: Option<f64>,

}


impl CpuUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CpuUsage {
        CpuUsage {
            idle_percent: None,
            system_percent: None,
            user_percent: None,
        }
    }
}

/// Converts the CpuUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CpuUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.idle_percent.as_ref().map(|idle_percent| {
                [
                    "idlePercent".to_string(),
                    idle_percent.to_string(),
                ].join(",")
            }),


            self.system_percent.as_ref().map(|system_percent| {
                [
                    "systemPercent".to_string(),
                    system_percent.to_string(),
                ].join(",")
            }),


            self.user_percent.as_ref().map(|user_percent| {
                [
                    "userPercent".to_string(),
                    user_percent.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CpuUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CpuUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub idle_percent: Vec<f64>,
            pub system_percent: Vec<f64>,
            pub user_percent: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CpuUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "idlePercent" => intermediate_rep.idle_percent.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "systemPercent" => intermediate_rep.system_percent.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userPercent" => intermediate_rep.user_percent.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CpuUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CpuUsage {
            idle_percent: intermediate_rep.idle_percent.into_iter().next(),
            system_percent: intermediate_rep.system_percent.into_iter().next(),
            user_percent: intermediate_rep.user_percent.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CpuUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CpuUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CpuUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CpuUsage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CpuUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CpuUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CpuUsage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ContainerCreate used when compatible endpoint creates a container



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate, Default)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateContainerConfig {
    #[serde(rename = "ArgsEscaped")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args_escaped: Option<bool>,

    #[serde(rename = "AttachStderr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stderr: Option<bool>,

    #[serde(rename = "AttachStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdin: Option<bool>,

    #[serde(rename = "AttachStdout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdout: Option<bool>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Cmd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cmd: Option<Vec<String>>,

    #[serde(rename = "Domainname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub domainname: Option<String>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Entrypoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrypoint: Option<Vec<String>>,

    #[serde(rename = "Env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<String>>,

    #[serde(rename = "EnvMerge")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env_merge: Option<Vec<String>>,

/// PortSet is a collection of structs indexed by Port
    #[serde(rename = "ExposedPorts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exposed_ports: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "Healthcheck")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healthcheck: Option<models::HealthcheckConfig>,

    #[serde(rename = "HostConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_config: Option<models::HostConfig>,

    #[serde(rename = "Hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// Mac Address of the container.  Deprecated: this field is deprecated since API v1.44. Use EndpointSettings.MacAddress instead.
    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "NetworkDisabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_disabled: Option<bool>,

    #[serde(rename = "NetworkingConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networking_config: Option<models::NetworkingConfig>,

    #[serde(rename = "OnBuild")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_build: Option<Vec<String>>,

    #[serde(rename = "OpenStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_stdin: Option<bool>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "Shell")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shell: Option<Vec<String>>,

    #[serde(rename = "StdinOnce")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin_once: Option<bool>,

    #[serde(rename = "StopSignal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_signal: Option<String>,

    #[serde(rename = "StopTimeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_timeout: Option<i64>,

    #[serde(rename = "Tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

    #[serde(rename = "UnsetEnv")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unset_env: Option<Vec<String>>,

    #[serde(rename = "UnsetEnvAll")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unset_env_all: Option<bool>,

    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

    #[serde(rename = "Volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "WorkingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

}


impl CreateContainerConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateContainerConfig {
        CreateContainerConfig {
            args_escaped: None,
            attach_stderr: None,
            attach_stdin: None,
            attach_stdout: None,
            cmd: None,
            domainname: None,
            entrypoint: None,
            env: None,
            env_merge: None,
            exposed_ports: None,
            healthcheck: None,
            host_config: None,
            hostname: None,
            image: None,
            labels: None,
            mac_address: None,
            name: None,
            network_disabled: None,
            networking_config: None,
            on_build: None,
            open_stdin: None,
            shell: None,
            stdin_once: None,
            stop_signal: None,
            stop_timeout: None,
            tty: None,
            unset_env: None,
            unset_env_all: None,
            user: None,
            volumes: None,
            working_dir: None,
        }
    }
}

/// Converts the CreateContainerConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateContainerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.args_escaped.as_ref().map(|args_escaped| {
                [
                    "ArgsEscaped".to_string(),
                    args_escaped.to_string(),
                ].join(",")
            }),


            self.attach_stderr.as_ref().map(|attach_stderr| {
                [
                    "AttachStderr".to_string(),
                    attach_stderr.to_string(),
                ].join(",")
            }),


            self.attach_stdin.as_ref().map(|attach_stdin| {
                [
                    "AttachStdin".to_string(),
                    attach_stdin.to_string(),
                ].join(",")
            }),


            self.attach_stdout.as_ref().map(|attach_stdout| {
                [
                    "AttachStdout".to_string(),
                    attach_stdout.to_string(),
                ].join(",")
            }),


            self.cmd.as_ref().map(|cmd| {
                [
                    "Cmd".to_string(),
                    cmd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.domainname.as_ref().map(|domainname| {
                [
                    "Domainname".to_string(),
                    domainname.to_string(),
                ].join(",")
            }),


            self.entrypoint.as_ref().map(|entrypoint| {
                [
                    "Entrypoint".to_string(),
                    entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.env.as_ref().map(|env| {
                [
                    "Env".to_string(),
                    env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.env_merge.as_ref().map(|env_merge| {
                [
                    "EnvMerge".to_string(),
                    env_merge.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping ExposedPorts in query parameter serialization
            // Skipping ExposedPorts in query parameter serialization

            // Skipping Healthcheck in query parameter serialization

            // Skipping HostConfig in query parameter serialization


            self.hostname.as_ref().map(|hostname| {
                [
                    "Hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.network_disabled.as_ref().map(|network_disabled| {
                [
                    "NetworkDisabled".to_string(),
                    network_disabled.to_string(),
                ].join(",")
            }),

            // Skipping NetworkingConfig in query parameter serialization


            self.on_build.as_ref().map(|on_build| {
                [
                    "OnBuild".to_string(),
                    on_build.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.open_stdin.as_ref().map(|open_stdin| {
                [
                    "OpenStdin".to_string(),
                    open_stdin.to_string(),
                ].join(",")
            }),


            self.shell.as_ref().map(|shell| {
                [
                    "Shell".to_string(),
                    shell.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.stdin_once.as_ref().map(|stdin_once| {
                [
                    "StdinOnce".to_string(),
                    stdin_once.to_string(),
                ].join(",")
            }),


            self.stop_signal.as_ref().map(|stop_signal| {
                [
                    "StopSignal".to_string(),
                    stop_signal.to_string(),
                ].join(",")
            }),


            self.stop_timeout.as_ref().map(|stop_timeout| {
                [
                    "StopTimeout".to_string(),
                    stop_timeout.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "Tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),


            self.unset_env.as_ref().map(|unset_env| {
                [
                    "UnsetEnv".to_string(),
                    unset_env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.unset_env_all.as_ref().map(|unset_env_all| {
                [
                    "UnsetEnvAll".to_string(),
                    unset_env_all.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "User".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping Volumes in query parameter serialization
            // Skipping Volumes in query parameter serialization


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "WorkingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateContainerConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateContainerConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args_escaped: Vec<bool>,
            pub attach_stderr: Vec<bool>,
            pub attach_stdin: Vec<bool>,
            pub attach_stdout: Vec<bool>,
            pub cmd: Vec<Vec<String>>,
            pub domainname: Vec<String>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<Vec<String>>,
            pub env_merge: Vec<Vec<String>>,
            pub exposed_ports: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub healthcheck: Vec<models::HealthcheckConfig>,
            pub host_config: Vec<models::HostConfig>,
            pub hostname: Vec<String>,
            pub image: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub mac_address: Vec<String>,
            pub name: Vec<String>,
            pub network_disabled: Vec<bool>,
            pub networking_config: Vec<models::NetworkingConfig>,
            pub on_build: Vec<Vec<String>>,
            pub open_stdin: Vec<bool>,
            pub shell: Vec<Vec<String>>,
            pub stdin_once: Vec<bool>,
            pub stop_signal: Vec<String>,
            pub stop_timeout: Vec<i64>,
            pub tty: Vec<bool>,
            pub unset_env: Vec<Vec<String>>,
            pub unset_env_all: Vec<bool>,
            pub user: Vec<String>,
            pub volumes: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub working_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateContainerConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ArgsEscaped" => intermediate_rep.args_escaped.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStderr" => intermediate_rep.attach_stderr.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdin" => intermediate_rep.attach_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdout" => intermediate_rep.attach_stdout.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Cmd" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Domainname" => intermediate_rep.domainname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    "EnvMerge" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    "ExposedPorts" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Healthcheck" => intermediate_rep.healthcheck.push(<models::HealthcheckConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostConfig" => intermediate_rep.host_config.push(<models::HostConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkDisabled" => intermediate_rep.network_disabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkingConfig" => intermediate_rep.networking_config.push(<models::NetworkingConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "OnBuild" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "OpenStdin" => intermediate_rep.open_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Shell" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "StdinOnce" => intermediate_rep.stdin_once.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StopSignal" => intermediate_rep.stop_signal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StopTimeout" => intermediate_rep.stop_timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "UnsetEnv" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "UnsetEnvAll" => intermediate_rep.unset_env_all.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "WorkingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateContainerConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateContainerConfig {
            args_escaped: intermediate_rep.args_escaped.into_iter().next(),
            attach_stderr: intermediate_rep.attach_stderr.into_iter().next(),
            attach_stdin: intermediate_rep.attach_stdin.into_iter().next(),
            attach_stdout: intermediate_rep.attach_stdout.into_iter().next(),
            cmd: intermediate_rep.cmd.into_iter().next(),
            domainname: intermediate_rep.domainname.into_iter().next(),
            entrypoint: intermediate_rep.entrypoint.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            env_merge: intermediate_rep.env_merge.into_iter().next(),
            exposed_ports: intermediate_rep.exposed_ports.into_iter().next(),
            healthcheck: intermediate_rep.healthcheck.into_iter().next(),
            host_config: intermediate_rep.host_config.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            network_disabled: intermediate_rep.network_disabled.into_iter().next(),
            networking_config: intermediate_rep.networking_config.into_iter().next(),
            on_build: intermediate_rep.on_build.into_iter().next(),
            open_stdin: intermediate_rep.open_stdin.into_iter().next(),
            shell: intermediate_rep.shell.into_iter().next(),
            stdin_once: intermediate_rep.stdin_once.into_iter().next(),
            stop_signal: intermediate_rep.stop_signal.into_iter().next(),
            stop_timeout: intermediate_rep.stop_timeout.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            unset_env: intermediate_rep.unset_env.into_iter().next(),
            unset_env_all: intermediate_rep.unset_env_all.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateContainerConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateContainerConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateContainerConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateContainerConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateContainerConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateContainerConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateContainerConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Volume configuration



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateOptions {
    #[serde(rename = "ClusterVolumeSpec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cluster_volume_spec: Option<models::ClusterVolumeSpec>,

/// Name of the volume driver to use.
    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
    #[serde(rename = "DriverOpts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver_opts: Option<std::collections::HashMap<String, String>>,

/// User-defined key/value metadata.
    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// The new volume's name. If not specified, Docker generates a name.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl CreateOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateOptions {
        CreateOptions {
            cluster_volume_spec: None,
            driver: None,
            driver_opts: None,
            labels: None,
            name: None,
        }
    }
}

/// Converts the CreateOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ClusterVolumeSpec in query parameter serialization


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),

            // Skipping DriverOpts in query parameter serialization

            // Skipping Labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cluster_volume_spec: Vec<models::ClusterVolumeSpec>,
            pub driver: Vec<String>,
            pub driver_opts: Vec<std::collections::HashMap<String, String>>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ClusterVolumeSpec" => intermediate_rep.cluster_volume_spec.push(<models::ClusterVolumeSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DriverOpts" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateOptions".to_string()),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateOptions {
            cluster_volume_spec: intermediate_rep.cluster_volume_spec.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            driver_opts: intermediate_rep.driver_opts.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// OK response to ContainerCreate operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateResponse {
/// The ID of the created container
    #[serde(rename = "Id")]
    pub id: String,

/// Warnings encountered when creating the container
    #[serde(rename = "Warnings")]
    pub warnings: Vec<String>,

}


impl CreateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, warnings: Vec<String>, ) -> CreateResponse {
        CreateResponse {
            id,
            warnings,
        }
    }
}

/// Converts the CreateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Id".to_string()),
            Some(self.id.to_string()),


            Some("Warnings".to_string()),
            Some(self.warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in CreateResponse".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or_else(|| "Warnings missing in CreateResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// DeleteResponse delete response



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteResponse {
/// The image ID of an image that was deleted
    #[serde(rename = "Deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<String>,

/// The image ID of an image that was untagged
    #[serde(rename = "Untagged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub untagged: Option<String>,

}


impl DeleteResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DeleteResponse {
        DeleteResponse {
            deleted: None,
            untagged: None,
        }
    }
}

/// Converts the DeleteResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.deleted.as_ref().map(|deleted| {
                [
                    "Deleted".to_string(),
                    deleted.to_string(),
                ].join(",")
            }),


            self.untagged.as_ref().map(|untagged| {
                [
                    "Untagged".to_string(),
                    untagged.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub deleted: Vec<String>,
            pub untagged: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Deleted" => intermediate_rep.deleted.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Untagged" => intermediate_rep.untagged.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteResponse {
            deleted: intermediate_rep.deleted.into_iter().next(),
            untagged: intermediate_rep.untagged.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeviceMapping {
    #[serde(rename = "CgroupPermissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_permissions: Option<String>,

    #[serde(rename = "PathInContainer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path_in_container: Option<String>,

    #[serde(rename = "PathOnHost")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path_on_host: Option<String>,

}


impl DeviceMapping {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DeviceMapping {
        DeviceMapping {
            cgroup_permissions: None,
            path_in_container: None,
            path_on_host: None,
        }
    }
}

/// Converts the DeviceMapping value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeviceMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup_permissions.as_ref().map(|cgroup_permissions| {
                [
                    "CgroupPermissions".to_string(),
                    cgroup_permissions.to_string(),
                ].join(",")
            }),


            self.path_in_container.as_ref().map(|path_in_container| {
                [
                    "PathInContainer".to_string(),
                    path_in_container.to_string(),
                ].join(",")
            }),


            self.path_on_host.as_ref().map(|path_on_host| {
                [
                    "PathOnHost".to_string(),
                    path_on_host.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeviceMapping value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeviceMapping {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup_permissions: Vec<String>,
            pub path_in_container: Vec<String>,
            pub path_on_host: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeviceMapping".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CgroupPermissions" => intermediate_rep.cgroup_permissions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PathInContainer" => intermediate_rep.path_in_container.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PathOnHost" => intermediate_rep.path_on_host.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeviceMapping".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeviceMapping {
            cgroup_permissions: intermediate_rep.cgroup_permissions.into_iter().next(),
            path_in_container: intermediate_rep.path_in_container.into_iter().next(),
            path_on_host: intermediate_rep.path_on_host.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeviceMapping> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeviceMapping>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeviceMapping>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeviceMapping - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeviceMapping> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeviceMapping as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeviceMapping - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Used by GPU device drivers.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeviceRequest {
    #[serde(rename = "Capabilities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub capabilities: Option<Vec<Vec<String>>>,

    #[serde(rename = "Count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i64>,

    #[serde(rename = "DeviceIDs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_ids: Option<Vec<String>>,

    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

}


impl DeviceRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DeviceRequest {
        DeviceRequest {
            capabilities: None,
            count: None,
            device_ids: None,
            driver: None,
            options: None,
        }
    }
}

/// Converts the DeviceRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeviceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Capabilities in query parameter serialization


            self.count.as_ref().map(|count| {
                [
                    "Count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.device_ids.as_ref().map(|device_ids| {
                [
                    "DeviceIDs".to_string(),
                    device_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeviceRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeviceRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub capabilities: Vec<Vec<Vec<String>>>,
            pub count: Vec<i64>,
            pub device_ids: Vec<Vec<String>>,
            pub driver: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeviceRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Capabilities" => return std::result::Result::Err("Parsing a container in this style is not supported in DeviceRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Count" => intermediate_rep.count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DeviceIDs" => return std::result::Result::Err("Parsing a container in this style is not supported in DeviceRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in DeviceRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeviceRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeviceRequest {
            capabilities: intermediate_rep.capabilities.into_iter().next(),
            count: intermediate_rep.count.into_iter().next(),
            device_ids: intermediate_rep.device_ids.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeviceRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeviceRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeviceRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeviceRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeviceRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeviceRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeviceRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The following is an example of the contents of Digest types:  sha256:7173b809ca12ec5dee4506cd86be934c4596dd234ee82c0662eac04a8c2c71dc  This allows to abstract the digest behind this type and work only in those terms.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Digest(String);

impl validator::Validate for Digest {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Digest {
    fn from(x: String) -> Self {
        Digest(x)
    }
}

impl std::fmt::Display for Digest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for Digest {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Digest(x.to_string()))
    }
}

impl std::convert::From<Digest> for String {
    fn from(x: Digest) -> Self {
        x.0
    }
}

impl std::ops::Deref for Digest {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Digest {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// DistributionInfo describes the host distribution for libpod



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DistributionInfo {
    #[serde(rename = "codename")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub codename: Option<String>,

    #[serde(rename = "distribution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub distribution: Option<String>,

    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl DistributionInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DistributionInfo {
        DistributionInfo {
            codename: None,
            distribution: None,
            variant: None,
            version: None,
        }
    }
}

/// Converts the DistributionInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DistributionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.codename.as_ref().map(|codename| {
                [
                    "codename".to_string(),
                    codename.to_string(),
                ].join(",")
            }),


            self.distribution.as_ref().map(|distribution| {
                [
                    "distribution".to_string(),
                    distribution.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DistributionInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DistributionInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub codename: Vec<String>,
            pub distribution: Vec<String>,
            pub variant: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DistributionInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "codename" => intermediate_rep.codename.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "distribution" => intermediate_rep.distribution.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DistributionInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DistributionInfo {
            codename: intermediate_rep.codename.into_iter().next(),
            distribution: intermediate_rep.distribution.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DistributionInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DistributionInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DistributionInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DistributionInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DistributionInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DistributionInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DistributionInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DnsNetworkInfo {
    #[serde(rename = "package")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<String>,

    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl DnsNetworkInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DnsNetworkInfo {
        DnsNetworkInfo {
            package: None,
            path: None,
            version: None,
        }
    }
}

/// Converts the DnsNetworkInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DnsNetworkInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.package.as_ref().map(|package| {
                [
                    "package".to_string(),
                    package.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DnsNetworkInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DnsNetworkInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub package: Vec<String>,
            pub path: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DnsNetworkInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "package" => intermediate_rep.package.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DnsNetworkInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DnsNetworkInfo {
            package: intermediate_rep.package.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DnsNetworkInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DnsNetworkInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DnsNetworkInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DnsNetworkInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DnsNetworkInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DnsNetworkInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DnsNetworkInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Driver {
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

}


impl Driver {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Driver {
        Driver {
            name: None,
            options: None,
        }
    }
}

/// Converts the Driver value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Driver {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Driver value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Driver {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Driver".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in Driver".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Driver".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Driver {
            name: intermediate_rep.name.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Driver> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Driver>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Driver>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Driver - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Driver> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Driver as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Driver - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// DriverData handles the data for a storage driver



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DriverData {
    #[serde(rename = "Data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl DriverData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> DriverData {
        DriverData {
            data: None,
            name: None,
        }
    }
}

/// Converts the DriverData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DriverData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Data in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DriverData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DriverData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DriverData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Data" => return std::result::Result::Err("Parsing a container in this style is not supported in DriverData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DriverData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DriverData {
            data: intermediate_rep.data.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DriverData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DriverData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DriverData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DriverData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DriverData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DriverData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DriverData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Duration(i64);

impl validator::Validate for Duration {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<i64> for Duration {
    fn from(x: i64) -> Self {
        Duration(x)
    }
}

impl std::convert::From<Duration> for i64 {
    fn from(x: Duration) -> Self {
        x.0
    }
}

impl std::ops::Deref for Duration {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for Duration {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}



/// EndpointIPAMConfig represents IPAM configurations for the endpoint



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EndpointIpamConfig {
    #[serde(rename = "IPv4Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv4_address: Option<String>,

    #[serde(rename = "IPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_address: Option<String>,

    #[serde(rename = "LinkLocalIPs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_local_ips: Option<Vec<String>>,

}


impl EndpointIpamConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EndpointIpamConfig {
        EndpointIpamConfig {
            ipv4_address: None,
            ipv6_address: None,
            link_local_ips: None,
        }
    }
}

/// Converts the EndpointIpamConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EndpointIpamConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ipv4_address.as_ref().map(|ipv4_address| {
                [
                    "IPv4Address".to_string(),
                    ipv4_address.to_string(),
                ].join(",")
            }),


            self.ipv6_address.as_ref().map(|ipv6_address| {
                [
                    "IPv6Address".to_string(),
                    ipv6_address.to_string(),
                ].join(",")
            }),


            self.link_local_ips.as_ref().map(|link_local_ips| {
                [
                    "LinkLocalIPs".to_string(),
                    link_local_ips.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EndpointIpamConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EndpointIpamConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ipv4_address: Vec<String>,
            pub ipv6_address: Vec<String>,
            pub link_local_ips: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EndpointIpamConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IPv4Address" => intermediate_rep.ipv4_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv6Address" => intermediate_rep.ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "LinkLocalIPs" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointIpamConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EndpointIpamConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EndpointIpamConfig {
            ipv4_address: intermediate_rep.ipv4_address.into_iter().next(),
            ipv6_address: intermediate_rep.ipv6_address.into_iter().next(),
            link_local_ips: intermediate_rep.link_local_ips.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EndpointIpamConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EndpointIpamConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EndpointIpamConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EndpointIpamConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EndpointIpamConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EndpointIpamConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EndpointIpamConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// EndpointResource contains network resources allocated and used for a container in a network



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EndpointResource {
    #[serde(rename = "EndpointID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_id: Option<String>,

    #[serde(rename = "IPv4Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv4_address: Option<String>,

    #[serde(rename = "IPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_address: Option<String>,

    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl EndpointResource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EndpointResource {
        EndpointResource {
            endpoint_id: None,
            ipv4_address: None,
            ipv6_address: None,
            mac_address: None,
            name: None,
        }
    }
}

/// Converts the EndpointResource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EndpointResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.endpoint_id.as_ref().map(|endpoint_id| {
                [
                    "EndpointID".to_string(),
                    endpoint_id.to_string(),
                ].join(",")
            }),


            self.ipv4_address.as_ref().map(|ipv4_address| {
                [
                    "IPv4Address".to_string(),
                    ipv4_address.to_string(),
                ].join(",")
            }),


            self.ipv6_address.as_ref().map(|ipv6_address| {
                [
                    "IPv6Address".to_string(),
                    ipv6_address.to_string(),
                ].join(",")
            }),


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EndpointResource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EndpointResource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub endpoint_id: Vec<String>,
            pub ipv4_address: Vec<String>,
            pub ipv6_address: Vec<String>,
            pub mac_address: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EndpointResource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "EndpointID" => intermediate_rep.endpoint_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv4Address" => intermediate_rep.ipv4_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv6Address" => intermediate_rep.ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EndpointResource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EndpointResource {
            endpoint_id: intermediate_rep.endpoint_id.into_iter().next(),
            ipv4_address: intermediate_rep.ipv4_address.into_iter().next(),
            ipv6_address: intermediate_rep.ipv6_address.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EndpointResource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EndpointResource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EndpointResource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EndpointResource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EndpointResource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EndpointResource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EndpointResource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// EndpointSettings stores the network endpoint details



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EndpointSettings {
    #[serde(rename = "Aliases")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aliases: Option<Vec<String>>,

/// DNSNames holds all the (non fully qualified) DNS names associated to this endpoint. First entry is used to generate PTR records.
    #[serde(rename = "DNSNames")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_names: Option<Vec<String>>,

    #[serde(rename = "DriverOpts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver_opts: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "EndpointID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_id: Option<String>,

    #[serde(rename = "Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

    #[serde(rename = "GlobalIPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_address: Option<String>,

    #[serde(rename = "GlobalIPv6PrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_prefix_len: Option<i64>,

    #[serde(rename = "IPAMConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipam_config: Option<models::EndpointIpamConfig>,

    #[serde(rename = "IPAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_address: Option<String>,

    #[serde(rename = "IPPrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_prefix_len: Option<i64>,

    #[serde(rename = "IPv6Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_gateway: Option<String>,

    #[serde(rename = "Links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub links: Option<Vec<String>>,

/// MacAddress may be used to specify a MAC address when the container is created. Once the container is running, it becomes operational data (it may contain a generated address).
    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

/// Operational data
    #[serde(rename = "NetworkID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_id: Option<String>,

}


impl EndpointSettings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EndpointSettings {
        EndpointSettings {
            aliases: None,
            dns_names: None,
            driver_opts: None,
            endpoint_id: None,
            gateway: None,
            global_ipv6_address: None,
            global_ipv6_prefix_len: None,
            ipam_config: None,
            ip_address: None,
            ip_prefix_len: None,
            ipv6_gateway: None,
            links: None,
            mac_address: None,
            network_id: None,
        }
    }
}

/// Converts the EndpointSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EndpointSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.aliases.as_ref().map(|aliases| {
                [
                    "Aliases".to_string(),
                    aliases.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_names.as_ref().map(|dns_names| {
                [
                    "DNSNames".to_string(),
                    dns_names.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping DriverOpts in query parameter serialization


            self.endpoint_id.as_ref().map(|endpoint_id| {
                [
                    "EndpointID".to_string(),
                    endpoint_id.to_string(),
                ].join(",")
            }),


            self.gateway.as_ref().map(|gateway| {
                [
                    "Gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),


            self.global_ipv6_address.as_ref().map(|global_ipv6_address| {
                [
                    "GlobalIPv6Address".to_string(),
                    global_ipv6_address.to_string(),
                ].join(",")
            }),


            self.global_ipv6_prefix_len.as_ref().map(|global_ipv6_prefix_len| {
                [
                    "GlobalIPv6PrefixLen".to_string(),
                    global_ipv6_prefix_len.to_string(),
                ].join(",")
            }),

            // Skipping IPAMConfig in query parameter serialization


            self.ip_address.as_ref().map(|ip_address| {
                [
                    "IPAddress".to_string(),
                    ip_address.to_string(),
                ].join(",")
            }),


            self.ip_prefix_len.as_ref().map(|ip_prefix_len| {
                [
                    "IPPrefixLen".to_string(),
                    ip_prefix_len.to_string(),
                ].join(",")
            }),


            self.ipv6_gateway.as_ref().map(|ipv6_gateway| {
                [
                    "IPv6Gateway".to_string(),
                    ipv6_gateway.to_string(),
                ].join(",")
            }),


            self.links.as_ref().map(|links| {
                [
                    "Links".to_string(),
                    links.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),


            self.network_id.as_ref().map(|network_id| {
                [
                    "NetworkID".to_string(),
                    network_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EndpointSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EndpointSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub aliases: Vec<Vec<String>>,
            pub dns_names: Vec<Vec<String>>,
            pub driver_opts: Vec<std::collections::HashMap<String, String>>,
            pub endpoint_id: Vec<String>,
            pub gateway: Vec<String>,
            pub global_ipv6_address: Vec<String>,
            pub global_ipv6_prefix_len: Vec<i64>,
            pub ipam_config: Vec<models::EndpointIpamConfig>,
            pub ip_address: Vec<String>,
            pub ip_prefix_len: Vec<i64>,
            pub ipv6_gateway: Vec<String>,
            pub links: Vec<Vec<String>>,
            pub mac_address: Vec<String>,
            pub network_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EndpointSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Aliases" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointSettings".to_string()),
                    "DNSNames" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointSettings".to_string()),
                    "DriverOpts" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointSettings".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "EndpointID" => intermediate_rep.endpoint_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6Address" => intermediate_rep.global_ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6PrefixLen" => intermediate_rep.global_ipv6_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPAMConfig" => intermediate_rep.ipam_config.push(<models::EndpointIpamConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPAddress" => intermediate_rep.ip_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPPrefixLen" => intermediate_rep.ip_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv6Gateway" => intermediate_rep.ipv6_gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Links" => return std::result::Result::Err("Parsing a container in this style is not supported in EndpointSettings".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkID" => intermediate_rep.network_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EndpointSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EndpointSettings {
            aliases: intermediate_rep.aliases.into_iter().next(),
            dns_names: intermediate_rep.dns_names.into_iter().next(),
            driver_opts: intermediate_rep.driver_opts.into_iter().next(),
            endpoint_id: intermediate_rep.endpoint_id.into_iter().next(),
            gateway: intermediate_rep.gateway.into_iter().next(),
            global_ipv6_address: intermediate_rep.global_ipv6_address.into_iter().next(),
            global_ipv6_prefix_len: intermediate_rep.global_ipv6_prefix_len.into_iter().next(),
            ipam_config: intermediate_rep.ipam_config.into_iter().next(),
            ip_address: intermediate_rep.ip_address.into_iter().next(),
            ip_prefix_len: intermediate_rep.ip_prefix_len.into_iter().next(),
            ipv6_gateway: intermediate_rep.ipv6_gateway.into_iter().next(),
            links: intermediate_rep.links.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            network_id: intermediate_rep.network_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EndpointSettings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EndpointSettings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EndpointSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for EndpointSettings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EndpointSettings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EndpointSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into EndpointSettings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ErrorModel is used in remote connections with podman



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ErrorModel {
/// API root cause formatted for automated parsing
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cause: Option<String>,

/// human error message, formatted for a human to read
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

/// HTTP response code
    #[serde(rename = "response")]
    #[validate(
            range(min = 400),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response: Option<i64>,

}


impl ErrorModel {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ErrorModel {
        ErrorModel {
            cause: None,
            message: None,
            response: None,
        }
    }
}

/// Converts the ErrorModel value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ErrorModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cause.as_ref().map(|cause| {
                [
                    "cause".to_string(),
                    cause.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.response.as_ref().map(|response| {
                [
                    "response".to_string(),
                    response.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ErrorModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ErrorModel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cause: Vec<String>,
            pub message: Vec<String>,
            pub response: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ErrorModel".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response" => intermediate_rep.response.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ErrorModel".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ErrorModel {
            cause: intermediate_rep.cause.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            response: intermediate_rep.response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ErrorModel> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ErrorModel>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ErrorModel>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ErrorModel - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ErrorModel> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ErrorModel as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ErrorModel - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ErrorResponse {
/// The error message.
    #[serde(rename = "message")]
    pub message: String,

}


impl ErrorResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(message: String, ) -> ErrorResponse {
        ErrorResponse {
            message,
        }
    }
}

/// Converts the ErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ErrorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ErrorResponse {
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in ErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ErrorResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ErrorResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExecStartLibpodRequest {
/// Detach from the command.
    #[serde(rename = "Detach")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detach: Option<bool>,

/// Allocate a pseudo-TTY.
    #[serde(rename = "Tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

/// Height of the TTY session in characters. Tty must be set to true to use it.
    #[serde(rename = "h")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub h: Option<i32>,

/// Width of the TTY session in characters. Tty must be set to true to use it.
    #[serde(rename = "w")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub w: Option<i32>,

}


impl ExecStartLibpodRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ExecStartLibpodRequest {
        ExecStartLibpodRequest {
            detach: None,
            tty: None,
            h: None,
            w: None,
        }
    }
}

/// Converts the ExecStartLibpodRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ExecStartLibpodRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.detach.as_ref().map(|detach| {
                [
                    "Detach".to_string(),
                    detach.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "Tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),


            self.h.as_ref().map(|h| {
                [
                    "h".to_string(),
                    h.to_string(),
                ].join(",")
            }),


            self.w.as_ref().map(|w| {
                [
                    "w".to_string(),
                    w.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExecStartLibpodRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExecStartLibpodRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub detach: Vec<bool>,
            pub tty: Vec<bool>,
            pub h: Vec<i32>,
            pub w: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ExecStartLibpodRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Detach" => intermediate_rep.detach.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "h" => intermediate_rep.h.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "w" => intermediate_rep.w.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExecStartLibpodRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExecStartLibpodRequest {
            detach: intermediate_rep.detach.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            h: intermediate_rep.h.into_iter().next(),
            w: intermediate_rep.w.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExecStartLibpodRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ExecStartLibpodRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ExecStartLibpodRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ExecStartLibpodRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ExecStartLibpodRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ExecStartLibpodRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ExecStartLibpodRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ExecStartRequest {
/// Detach from the command. Not presently supported.
    #[serde(rename = "Detach")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detach: Option<bool>,

/// Allocate a pseudo-TTY. Presently ignored.
    #[serde(rename = "Tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

}


impl ExecStartRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ExecStartRequest {
        ExecStartRequest {
            detach: None,
            tty: None,
        }
    }
}

/// Converts the ExecStartRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ExecStartRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.detach.as_ref().map(|detach| {
                [
                    "Detach".to_string(),
                    detach.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "Tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ExecStartRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ExecStartRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub detach: Vec<bool>,
            pub tty: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ExecStartRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Detach" => intermediate_rep.detach.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ExecStartRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ExecStartRequest {
            detach: intermediate_rep.detach.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ExecStartRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ExecStartRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ExecStartRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ExecStartRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ExecStartRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ExecStartRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ExecStartRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is [ModeDir] for directories.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FileMode(i32);

impl validator::Validate for FileMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<i32> for FileMode {
    fn from(x: i32) -> Self {
        FileMode(x)
    }
}

impl std::convert::From<FileMode> for i32 {
    fn from(x: FileMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for FileMode {
    type Target = i32;
    fn deref(&self) -> &i32 {
        &self.0
    }
}

impl std::ops::DerefMut for FileMode {
    fn deref_mut(&mut self) -> &mut i32 {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FilesystemChange {
/// Can be one of:  `0`: Modified (\"C\") `1`: Added (\"A\") `2`: Deleted (\"D\")
    #[serde(rename = "Kind")]
    pub kind: i32,

/// Path to file or directory that has changed.
    #[serde(rename = "Path")]
    pub path: String,

}


impl FilesystemChange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(kind: i32, path: String, ) -> FilesystemChange {
        FilesystemChange {
            kind,
            path,
        }
    }
}

/// Converts the FilesystemChange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FilesystemChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Kind".to_string()),
            Some(self.kind.to_string()),


            Some("Path".to_string()),
            Some(self.path.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FilesystemChange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FilesystemChange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub kind: Vec<i32>,
            pub path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FilesystemChange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Kind" => intermediate_rep.kind.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FilesystemChange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FilesystemChange {
            kind: intermediate_rep.kind.into_iter().next().ok_or_else(|| "Kind missing in FilesystemChange".to_string())?,
            path: intermediate_rep.path.into_iter().next().ok_or_else(|| "Path missing in FilesystemChange".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FilesystemChange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FilesystemChange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FilesystemChange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FilesystemChange - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FilesystemChange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FilesystemChange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FilesystemChange - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// GraphDriverData Information about the storage driver used to store the container's and image's filesystem.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GraphDriverData {
/// Low-level storage metadata, provided as key/value pairs.  This information is driver-specific, and depends on the storage-driver in use, and should be used for informational purposes only.
    #[serde(rename = "Data")]
    pub data: std::collections::HashMap<String, String>,

/// Name of the storage driver.
    #[serde(rename = "Name")]
    pub name: String,

}


impl GraphDriverData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: std::collections::HashMap<String, String>, name: String, ) -> GraphDriverData {
        GraphDriverData {
            data,
            name,
        }
    }
}

/// Converts the GraphDriverData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GraphDriverData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Data in query parameter serialization


            Some("Name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GraphDriverData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GraphDriverData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GraphDriverData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Data" => return std::result::Result::Err("Parsing a container in this style is not supported in GraphDriverData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GraphDriverData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GraphDriverData {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "Data missing in GraphDriverData".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in GraphDriverData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GraphDriverData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GraphDriverData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GraphDriverData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GraphDriverData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GraphDriverData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GraphDriverData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GraphDriverData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Health stores information about the container's healthcheck results



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Health {
    #[serde(rename = "FailingStreak")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub failing_streak: Option<i64>,

    #[serde(rename = "Log")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log: Option<Vec<models::HealthcheckResult>>,

    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl Health {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Health {
        Health {
            failing_streak: None,
            log: None,
            status: None,
        }
    }
}

/// Converts the Health value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Health {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.failing_streak.as_ref().map(|failing_streak| {
                [
                    "FailingStreak".to_string(),
                    failing_streak.to_string(),
                ].join(",")
            }),

            // Skipping Log in query parameter serialization


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Health value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Health {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub failing_streak: Vec<i64>,
            pub log: Vec<Vec<models::HealthcheckResult>>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Health".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "FailingStreak" => intermediate_rep.failing_streak.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Log" => return std::result::Result::Err("Parsing a container in this style is not supported in Health".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Health".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Health {
            failing_streak: intermediate_rep.failing_streak.into_iter().next(),
            log: intermediate_rep.log.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Health> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Health>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Health>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Health - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Health> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Health as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Health - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HealthCheckLog describes the results of a single healthcheck



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HealthCheckLog {
/// End time as a string
    #[serde(rename = "End")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end: Option<String>,

/// Exitcode is 0 or 1
    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i64>,

/// Output is the stdout/stderr from the healthcheck command
    #[serde(rename = "Output")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<String>,

/// Start time as string
    #[serde(rename = "Start")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start: Option<String>,

}


impl HealthCheckLog {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HealthCheckLog {
        HealthCheckLog {
            end: None,
            exit_code: None,
            output: None,
            start: None,
        }
    }
}

/// Converts the HealthCheckLog value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HealthCheckLog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.end.as_ref().map(|end| {
                [
                    "End".to_string(),
                    end.to_string(),
                ].join(",")
            }),


            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),


            self.output.as_ref().map(|output| {
                [
                    "Output".to_string(),
                    output.to_string(),
                ].join(",")
            }),


            self.start.as_ref().map(|start| {
                [
                    "Start".to_string(),
                    start.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HealthCheckLog value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HealthCheckLog {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub end: Vec<String>,
            pub exit_code: Vec<i64>,
            pub output: Vec<String>,
            pub start: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HealthCheckLog".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "End" => intermediate_rep.end.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Output" => intermediate_rep.output.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Start" => intermediate_rep.start.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HealthCheckLog".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HealthCheckLog {
            end: intermediate_rep.end.into_iter().next(),
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            output: intermediate_rep.output.into_iter().next(),
            start: intermediate_rep.start.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HealthCheckLog> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HealthCheckLog>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HealthCheckLog>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HealthCheckLog - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HealthCheckLog> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HealthCheckLog as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HealthCheckLog - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HealthCheckOnFailureAction defines how Podman reacts when a container's health status turns unhealthy.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HealthCheckOnFailureAction(i64);

impl validator::Validate for HealthCheckOnFailureAction {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<i64> for HealthCheckOnFailureAction {
    fn from(x: i64) -> Self {
        HealthCheckOnFailureAction(x)
    }
}

impl std::convert::From<HealthCheckOnFailureAction> for i64 {
    fn from(x: HealthCheckOnFailureAction) -> Self {
        x.0
    }
}

impl std::ops::Deref for HealthCheckOnFailureAction {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for HealthCheckOnFailureAction {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}



/// HealthCheckResults describes the results/logs from a healthcheck



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HealthCheckResults {
/// FailingStreak is the number of consecutive failed healthchecks
    #[serde(rename = "FailingStreak")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub failing_streak: Option<i64>,

/// Log describes healthcheck attempts and results
    #[serde(rename = "Log")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log: Option<Vec<models::HealthCheckLog>>,

/// Status starting, healthy or unhealthy
    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl HealthCheckResults {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HealthCheckResults {
        HealthCheckResults {
            failing_streak: None,
            log: None,
            status: None,
        }
    }
}

/// Converts the HealthCheckResults value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HealthCheckResults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.failing_streak.as_ref().map(|failing_streak| {
                [
                    "FailingStreak".to_string(),
                    failing_streak.to_string(),
                ].join(",")
            }),

            // Skipping Log in query parameter serialization


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HealthCheckResults value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HealthCheckResults {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub failing_streak: Vec<i64>,
            pub log: Vec<Vec<models::HealthCheckLog>>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HealthCheckResults".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "FailingStreak" => intermediate_rep.failing_streak.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Log" => return std::result::Result::Err("Parsing a container in this style is not supported in HealthCheckResults".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HealthCheckResults".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HealthCheckResults {
            failing_streak: intermediate_rep.failing_streak.into_iter().next(),
            log: intermediate_rep.log.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HealthCheckResults> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HealthCheckResults>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HealthCheckResults>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HealthCheckResults - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HealthCheckResults> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HealthCheckResults as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HealthCheckResults - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HealthcheckConfig {
/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "Interval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interval: Option<i64>,

/// Retries is the number of consecutive failures needed to consider a container as unhealthy. Zero means inherit.
    #[serde(rename = "Retries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retries: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "StartInterval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_interval: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "StartPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_period: Option<i64>,

/// Test is the test to perform to check that the container is healthy. An empty slice means to inherit the default. The options are: {} : inherit healthcheck {\"NONE\"} : disable healthcheck {\"CMD\", args...} : exec arguments directly {\"CMD-SHELL\", command} : run command with system's default shell
    #[serde(rename = "Test")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub test: Option<Vec<String>>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "Timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i64>,

}


impl HealthcheckConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HealthcheckConfig {
        HealthcheckConfig {
            interval: None,
            retries: None,
            start_interval: None,
            start_period: None,
            test: None,
            timeout: None,
        }
    }
}

/// Converts the HealthcheckConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HealthcheckConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.interval.as_ref().map(|interval| {
                [
                    "Interval".to_string(),
                    interval.to_string(),
                ].join(",")
            }),


            self.retries.as_ref().map(|retries| {
                [
                    "Retries".to_string(),
                    retries.to_string(),
                ].join(",")
            }),


            self.start_interval.as_ref().map(|start_interval| {
                [
                    "StartInterval".to_string(),
                    start_interval.to_string(),
                ].join(",")
            }),


            self.start_period.as_ref().map(|start_period| {
                [
                    "StartPeriod".to_string(),
                    start_period.to_string(),
                ].join(",")
            }),


            self.test.as_ref().map(|test| {
                [
                    "Test".to_string(),
                    test.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "Timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HealthcheckConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HealthcheckConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub interval: Vec<i64>,
            pub retries: Vec<i64>,
            pub start_interval: Vec<i64>,
            pub start_period: Vec<i64>,
            pub test: Vec<Vec<String>>,
            pub timeout: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HealthcheckConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Interval" => intermediate_rep.interval.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Retries" => intermediate_rep.retries.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartInterval" => intermediate_rep.start_interval.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartPeriod" => intermediate_rep.start_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Test" => return std::result::Result::Err("Parsing a container in this style is not supported in HealthcheckConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Timeout" => intermediate_rep.timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HealthcheckConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HealthcheckConfig {
            interval: intermediate_rep.interval.into_iter().next(),
            retries: intermediate_rep.retries.into_iter().next(),
            start_interval: intermediate_rep.start_interval.into_iter().next(),
            start_period: intermediate_rep.start_period.into_iter().next(),
            test: intermediate_rep.test.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HealthcheckConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HealthcheckConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HealthcheckConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HealthcheckConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HealthcheckConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HealthcheckConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HealthcheckConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HealthcheckResult stores information about a single run of a healthcheck probe



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HealthcheckResult {
    #[serde(rename = "End")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i64>,

    #[serde(rename = "Output")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<String>,

    #[serde(rename = "Start")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start: Option<chrono::DateTime::<chrono::Utc>>,

}


impl HealthcheckResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HealthcheckResult {
        HealthcheckResult {
            end: None,
            exit_code: None,
            output: None,
            start: None,
        }
    }
}

/// Converts the HealthcheckResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HealthcheckResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping End in query parameter serialization


            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),


            self.output.as_ref().map(|output| {
                [
                    "Output".to_string(),
                    output.to_string(),
                ].join(",")
            }),

            // Skipping Start in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HealthcheckResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HealthcheckResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub end: Vec<chrono::DateTime::<chrono::Utc>>,
            pub exit_code: Vec<i64>,
            pub output: Vec<String>,
            pub start: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HealthcheckResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "End" => intermediate_rep.end.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Output" => intermediate_rep.output.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Start" => intermediate_rep.start.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HealthcheckResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HealthcheckResult {
            end: intermediate_rep.end.into_iter().next(),
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            output: intermediate_rep.output.into_iter().next(),
            start: intermediate_rep.start.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HealthcheckResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HealthcheckResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HealthcheckResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HealthcheckResult - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HealthcheckResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HealthcheckResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HealthcheckResult - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct History {
/// Author is the author of the build point.
    #[serde(rename = "author")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<String>,

/// Comment is a custom message set when creating the layer.
    #[serde(rename = "comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

/// Created is the combined date and time at which the layer was created, formatted as defined by RFC 3339, section 5.6.
    #[serde(rename = "created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

/// CreatedBy is the command which created the layer.
    #[serde(rename = "created_by")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_by: Option<String>,

/// EmptyLayer is used to mark if the history item created a filesystem diff.
    #[serde(rename = "empty_layer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub empty_layer: Option<bool>,

}


impl History {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> History {
        History {
            author: None,
            comment: None,
            created: None,
            created_by: None,
            empty_layer: None,
        }
    }
}

/// Converts the History value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for History {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.author.as_ref().map(|author| {
                [
                    "author".to_string(),
                    author.to_string(),
                ].join(",")
            }),


            self.comment.as_ref().map(|comment| {
                [
                    "comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),

            // Skipping created in query parameter serialization


            self.created_by.as_ref().map(|created_by| {
                [
                    "created_by".to_string(),
                    created_by.to_string(),
                ].join(",")
            }),


            self.empty_layer.as_ref().map(|empty_layer| {
                [
                    "empty_layer".to_string(),
                    empty_layer.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a History value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for History {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub author: Vec<String>,
            pub comment: Vec<String>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_by: Vec<String>,
            pub empty_layer: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing History".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "author" => intermediate_rep.author.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_by" => intermediate_rep.created_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "empty_layer" => intermediate_rep.empty_layer.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing History".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(History {
            author: intermediate_rep.author.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            created_by: intermediate_rep.created_by.into_iter().next(),
            empty_layer: intermediate_rep.empty_layer.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<History> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<History>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<History>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for History - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<History> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <History as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into History - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HistoryResponse provides details on image layers



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HistoryResponse {
    #[serde(rename = "Comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<i64>,

    #[serde(rename = "CreatedBy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_by: Option<String>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

    #[serde(rename = "Tags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,

}


impl HistoryResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HistoryResponse {
        HistoryResponse {
            comment: None,
            created: None,
            created_by: None,
            id: None,
            size: None,
            tags: None,
        }
    }
}

/// Converts the HistoryResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HistoryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.comment.as_ref().map(|comment| {
                [
                    "Comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),


            self.created.as_ref().map(|created| {
                [
                    "Created".to_string(),
                    created.to_string(),
                ].join(",")
            }),


            self.created_by.as_ref().map(|created_by| {
                [
                    "CreatedBy".to_string(),
                    created_by.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "Tags".to_string(),
                    tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HistoryResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HistoryResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub comment: Vec<String>,
            pub created: Vec<i64>,
            pub created_by: Vec<String>,
            pub id: Vec<String>,
            pub size: Vec<i64>,
            pub tags: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HistoryResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CreatedBy" => intermediate_rep.created_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Tags" => return std::result::Result::Err("Parsing a container in this style is not supported in HistoryResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing HistoryResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HistoryResponse {
            comment: intermediate_rep.comment.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            created_by: intermediate_rep.created_by.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            tags: intermediate_rep.tags.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HistoryResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HistoryResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HistoryResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HistoryResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HistoryResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HistoryResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HistoryResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HistoryResponseItem individual image layer information in response to ImageHistory operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HistoryResponseItem {
/// comment
    #[serde(rename = "Comment")]
    pub comment: String,

/// created
    #[serde(rename = "Created")]
    pub created: i64,

/// created by
    #[serde(rename = "CreatedBy")]
    pub created_by: String,

/// Id
    #[serde(rename = "Id")]
    pub id: String,

/// size
    #[serde(rename = "Size")]
    pub size: i64,

/// tags
    #[serde(rename = "Tags")]
    pub tags: Vec<String>,

}


impl HistoryResponseItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(comment: String, created: i64, created_by: String, id: String, size: i64, tags: Vec<String>, ) -> HistoryResponseItem {
        HistoryResponseItem {
            comment,
            created,
            created_by,
            id,
            size,
            tags,
        }
    }
}

/// Converts the HistoryResponseItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HistoryResponseItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Comment".to_string()),
            Some(self.comment.to_string()),


            Some("Created".to_string()),
            Some(self.created.to_string()),


            Some("CreatedBy".to_string()),
            Some(self.created_by.to_string()),


            Some("Id".to_string()),
            Some(self.id.to_string()),


            Some("Size".to_string()),
            Some(self.size.to_string()),


            Some("Tags".to_string()),
            Some(self.tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HistoryResponseItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HistoryResponseItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub comment: Vec<String>,
            pub created: Vec<i64>,
            pub created_by: Vec<String>,
            pub id: Vec<String>,
            pub size: Vec<i64>,
            pub tags: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HistoryResponseItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CreatedBy" => intermediate_rep.created_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Tags" => return std::result::Result::Err("Parsing a container in this style is not supported in HistoryResponseItem".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing HistoryResponseItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HistoryResponseItem {
            comment: intermediate_rep.comment.into_iter().next().ok_or_else(|| "Comment missing in HistoryResponseItem".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "Created missing in HistoryResponseItem".to_string())?,
            created_by: intermediate_rep.created_by.into_iter().next().ok_or_else(|| "CreatedBy missing in HistoryResponseItem".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in HistoryResponseItem".to_string())?,
            size: intermediate_rep.size.into_iter().next().ok_or_else(|| "Size missing in HistoryResponseItem".to_string())?,
            tags: intermediate_rep.tags.into_iter().next().ok_or_else(|| "Tags missing in HistoryResponseItem".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HistoryResponseItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HistoryResponseItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HistoryResponseItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HistoryResponseItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HistoryResponseItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HistoryResponseItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HistoryResponseItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Here, \"non-portable\" means \"dependent of the host we are running on\". Portable information *should* appear in Config.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HostConfig {
    #[serde(rename = "Annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "AutoRemove")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_remove: Option<bool>,

/// Applicable to all platforms
    #[serde(rename = "Binds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub binds: Option<Vec<String>>,

    #[serde(rename = "BlkioDeviceReadBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceReadIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioWeight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight: Option<i32>,

    #[serde(rename = "BlkioWeightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight_device: Option<Vec<models::WeightDevice>>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "CapAdd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_add: Option<Vec<String>>,

/// We need to override the json decoder to accept both options.
    #[serde(rename = "CapDrop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_drop: Option<Vec<String>>,

    #[serde(rename = "Cgroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup: Option<String>,

/// Applicable to UNIX platforms
    #[serde(rename = "CgroupParent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

/// CgroupnsMode represents the cgroup namespace mode of the container
    #[serde(rename = "CgroupnsMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroupns_mode: Option<String>,

    #[serde(rename = "ConsoleSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub console_size: Option<Vec<i32>>,

    #[serde(rename = "ContainerIDFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_id_file: Option<String>,

/// Applicable to Windows
    #[serde(rename = "CpuCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_count: Option<i64>,

    #[serde(rename = "CpuPercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_percent: Option<i64>,

    #[serde(rename = "CpuPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i64>,

    #[serde(rename = "CpuQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

    #[serde(rename = "CpuRealtimePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_period: Option<i64>,

    #[serde(rename = "CpuRealtimeRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_runtime: Option<i64>,

/// Applicable to all platforms
    #[serde(rename = "CpuShares")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_shares: Option<i64>,

    #[serde(rename = "CpusetCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

    #[serde(rename = "CpusetMems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_mems: Option<String>,

    #[serde(rename = "DeviceCgroupRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_cgroup_rules: Option<Vec<String>>,

    #[serde(rename = "DeviceRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_requests: Option<Vec<models::DeviceRequest>>,

    #[serde(rename = "Devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::DeviceMapping>>,

    #[serde(rename = "Dns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns: Option<Vec<String>>,

    #[serde(rename = "DnsOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_options: Option<Vec<String>>,

    #[serde(rename = "DnsSearch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

    #[serde(rename = "ExtraHosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub extra_hosts: Option<Vec<String>>,

    #[serde(rename = "GroupAdd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_add: Option<Vec<String>>,

    #[serde(rename = "IOMaximumBandwidth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_bandwidth: Option<i32>,

    #[serde(rename = "IOMaximumIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_i_ops: Option<i32>,

/// Run a custom init inside the container, if null, use the daemon's configured settings
    #[serde(rename = "Init")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init: Option<bool>,

    #[serde(rename = "IpcMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipc_mode: Option<String>,

/// Isolation represents the isolation technology of a container. The supported values are platform specific
    #[serde(rename = "Isolation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub isolation: Option<String>,

/// KernelMemory specifies the kernel memory limit (in bytes) for the container. Deprecated: kernel 5.4 deprecated kmem.limit_in_bytes.
    #[serde(rename = "KernelMemory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory: Option<i64>,

    #[serde(rename = "KernelMemoryTCP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory_tcp: Option<i64>,

    #[serde(rename = "Links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub links: Option<Vec<String>>,

    #[serde(rename = "LogConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_config: Option<models::LogConfig>,

/// MaskedPaths is the list of paths to be masked inside the container (this overrides the default set of paths)
    #[serde(rename = "MaskedPaths")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub masked_paths: Option<Vec<String>>,

    #[serde(rename = "Memory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory: Option<i64>,

    #[serde(rename = "MemoryReservation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_reservation: Option<i64>,

    #[serde(rename = "MemorySwap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swap: Option<i64>,

    #[serde(rename = "MemorySwappiness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swappiness: Option<i64>,

/// Mounts specs used by the container
    #[serde(rename = "Mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::Mount>>,

    #[serde(rename = "NanoCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nano_cpus: Option<i64>,

    #[serde(rename = "NetworkMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_mode: Option<String>,

    #[serde(rename = "OomKillDisable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_kill_disable: Option<bool>,

    #[serde(rename = "OomScoreAdj")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_score_adj: Option<i64>,

    #[serde(rename = "PidMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid_mode: Option<String>,

    #[serde(rename = "PidsLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids_limit: Option<i64>,

/// PortMap is a collection of PortBinding indexed by Port
    #[serde(rename = "PortBindings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub port_bindings: Option<std::collections::HashMap<String, Vec<models::PortBinding>>>,

    #[serde(rename = "Privileged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privileged: Option<bool>,

    #[serde(rename = "PublishAllPorts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_all_ports: Option<bool>,

/// ReadonlyPaths is the list of paths to be set as read-only inside the container (this overrides the default set of paths)
    #[serde(rename = "ReadonlyPaths")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readonly_paths: Option<Vec<String>>,

    #[serde(rename = "ReadonlyRootfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readonly_rootfs: Option<bool>,

    #[serde(rename = "RestartPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<models::RestartPolicy>,

    #[serde(rename = "Runtime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub runtime: Option<String>,

    #[serde(rename = "SecurityOpt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_opt: Option<Vec<String>>,

    #[serde(rename = "ShmSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size: Option<i64>,

    #[serde(rename = "StorageOpt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_opt: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Sysctls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sysctls: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Tmpfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tmpfs: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "UTSMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uts_mode: Option<String>,

    #[serde(rename = "Ulimits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ulimits: Option<Vec<models::Ulimit>>,

    #[serde(rename = "UsernsMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub userns_mode: Option<String>,

    #[serde(rename = "VolumeDriver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_driver: Option<String>,

    #[serde(rename = "VolumesFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

}


impl HostConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HostConfig {
        HostConfig {
            annotations: None,
            auto_remove: None,
            binds: None,
            blkio_device_read_bps: None,
            blkio_device_read_i_ops: None,
            blkio_device_write_bps: None,
            blkio_device_write_i_ops: None,
            blkio_weight: None,
            blkio_weight_device: None,
            cap_add: None,
            cap_drop: None,
            cgroup: None,
            cgroup_parent: None,
            cgroupns_mode: None,
            console_size: None,
            container_id_file: None,
            cpu_count: None,
            cpu_percent: None,
            cpu_period: None,
            cpu_quota: None,
            cpu_realtime_period: None,
            cpu_realtime_runtime: None,
            cpu_shares: None,
            cpuset_cpus: None,
            cpuset_mems: None,
            device_cgroup_rules: None,
            device_requests: None,
            devices: None,
            dns: None,
            dns_options: None,
            dns_search: None,
            extra_hosts: None,
            group_add: None,
            io_maximum_bandwidth: None,
            io_maximum_i_ops: None,
            init: None,
            ipc_mode: None,
            isolation: None,
            kernel_memory: None,
            kernel_memory_tcp: None,
            links: None,
            log_config: None,
            masked_paths: None,
            memory: None,
            memory_reservation: None,
            memory_swap: None,
            memory_swappiness: None,
            mounts: None,
            nano_cpus: None,
            network_mode: None,
            oom_kill_disable: None,
            oom_score_adj: None,
            pid_mode: None,
            pids_limit: None,
            port_bindings: None,
            privileged: None,
            publish_all_ports: None,
            readonly_paths: None,
            readonly_rootfs: None,
            restart_policy: None,
            runtime: None,
            security_opt: None,
            shm_size: None,
            storage_opt: None,
            sysctls: None,
            tmpfs: None,
            uts_mode: None,
            ulimits: None,
            userns_mode: None,
            volume_driver: None,
            volumes_from: None,
        }
    }
}

/// Converts the HostConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HostConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Annotations in query parameter serialization


            self.auto_remove.as_ref().map(|auto_remove| {
                [
                    "AutoRemove".to_string(),
                    auto_remove.to_string(),
                ].join(",")
            }),


            self.binds.as_ref().map(|binds| {
                [
                    "Binds".to_string(),
                    binds.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping BlkioDeviceReadBps in query parameter serialization

            // Skipping BlkioDeviceReadIOps in query parameter serialization

            // Skipping BlkioDeviceWriteBps in query parameter serialization

            // Skipping BlkioDeviceWriteIOps in query parameter serialization


            self.blkio_weight.as_ref().map(|blkio_weight| {
                [
                    "BlkioWeight".to_string(),
                    blkio_weight.to_string(),
                ].join(",")
            }),

            // Skipping BlkioWeightDevice in query parameter serialization


            self.cap_add.as_ref().map(|cap_add| {
                [
                    "CapAdd".to_string(),
                    cap_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cap_drop.as_ref().map(|cap_drop| {
                [
                    "CapDrop".to_string(),
                    cap_drop.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cgroup.as_ref().map(|cgroup| {
                [
                    "Cgroup".to_string(),
                    cgroup.to_string(),
                ].join(",")
            }),


            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "CgroupParent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.cgroupns_mode.as_ref().map(|cgroupns_mode| {
                [
                    "CgroupnsMode".to_string(),
                    cgroupns_mode.to_string(),
                ].join(",")
            }),


            self.console_size.as_ref().map(|console_size| {
                [
                    "ConsoleSize".to_string(),
                    console_size.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.container_id_file.as_ref().map(|container_id_file| {
                [
                    "ContainerIDFile".to_string(),
                    container_id_file.to_string(),
                ].join(",")
            }),


            self.cpu_count.as_ref().map(|cpu_count| {
                [
                    "CpuCount".to_string(),
                    cpu_count.to_string(),
                ].join(",")
            }),


            self.cpu_percent.as_ref().map(|cpu_percent| {
                [
                    "CpuPercent".to_string(),
                    cpu_percent.to_string(),
                ].join(",")
            }),


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "CpuPeriod".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "CpuQuota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_period.as_ref().map(|cpu_realtime_period| {
                [
                    "CpuRealtimePeriod".to_string(),
                    cpu_realtime_period.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_runtime.as_ref().map(|cpu_realtime_runtime| {
                [
                    "CpuRealtimeRuntime".to_string(),
                    cpu_realtime_runtime.to_string(),
                ].join(",")
            }),


            self.cpu_shares.as_ref().map(|cpu_shares| {
                [
                    "CpuShares".to_string(),
                    cpu_shares.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "CpusetCpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.cpuset_mems.as_ref().map(|cpuset_mems| {
                [
                    "CpusetMems".to_string(),
                    cpuset_mems.to_string(),
                ].join(",")
            }),


            self.device_cgroup_rules.as_ref().map(|device_cgroup_rules| {
                [
                    "DeviceCgroupRules".to_string(),
                    device_cgroup_rules.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping DeviceRequests in query parameter serialization

            // Skipping Devices in query parameter serialization


            self.dns.as_ref().map(|dns| {
                [
                    "Dns".to_string(),
                    dns.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_options.as_ref().map(|dns_options| {
                [
                    "DnsOptions".to_string(),
                    dns_options.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "DnsSearch".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.extra_hosts.as_ref().map(|extra_hosts| {
                [
                    "ExtraHosts".to_string(),
                    extra_hosts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.group_add.as_ref().map(|group_add| {
                [
                    "GroupAdd".to_string(),
                    group_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.io_maximum_bandwidth.as_ref().map(|io_maximum_bandwidth| {
                [
                    "IOMaximumBandwidth".to_string(),
                    io_maximum_bandwidth.to_string(),
                ].join(",")
            }),


            self.io_maximum_i_ops.as_ref().map(|io_maximum_i_ops| {
                [
                    "IOMaximumIOps".to_string(),
                    io_maximum_i_ops.to_string(),
                ].join(",")
            }),


            self.init.as_ref().map(|init| {
                [
                    "Init".to_string(),
                    init.to_string(),
                ].join(",")
            }),


            self.ipc_mode.as_ref().map(|ipc_mode| {
                [
                    "IpcMode".to_string(),
                    ipc_mode.to_string(),
                ].join(",")
            }),


            self.isolation.as_ref().map(|isolation| {
                [
                    "Isolation".to_string(),
                    isolation.to_string(),
                ].join(",")
            }),


            self.kernel_memory.as_ref().map(|kernel_memory| {
                [
                    "KernelMemory".to_string(),
                    kernel_memory.to_string(),
                ].join(",")
            }),


            self.kernel_memory_tcp.as_ref().map(|kernel_memory_tcp| {
                [
                    "KernelMemoryTCP".to_string(),
                    kernel_memory_tcp.to_string(),
                ].join(",")
            }),


            self.links.as_ref().map(|links| {
                [
                    "Links".to_string(),
                    links.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping LogConfig in query parameter serialization


            self.masked_paths.as_ref().map(|masked_paths| {
                [
                    "MaskedPaths".to_string(),
                    masked_paths.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.memory.as_ref().map(|memory| {
                [
                    "Memory".to_string(),
                    memory.to_string(),
                ].join(",")
            }),


            self.memory_reservation.as_ref().map(|memory_reservation| {
                [
                    "MemoryReservation".to_string(),
                    memory_reservation.to_string(),
                ].join(",")
            }),


            self.memory_swap.as_ref().map(|memory_swap| {
                [
                    "MemorySwap".to_string(),
                    memory_swap.to_string(),
                ].join(",")
            }),


            self.memory_swappiness.as_ref().map(|memory_swappiness| {
                [
                    "MemorySwappiness".to_string(),
                    memory_swappiness.to_string(),
                ].join(",")
            }),

            // Skipping Mounts in query parameter serialization


            self.nano_cpus.as_ref().map(|nano_cpus| {
                [
                    "NanoCpus".to_string(),
                    nano_cpus.to_string(),
                ].join(",")
            }),


            self.network_mode.as_ref().map(|network_mode| {
                [
                    "NetworkMode".to_string(),
                    network_mode.to_string(),
                ].join(",")
            }),


            self.oom_kill_disable.as_ref().map(|oom_kill_disable| {
                [
                    "OomKillDisable".to_string(),
                    oom_kill_disable.to_string(),
                ].join(",")
            }),


            self.oom_score_adj.as_ref().map(|oom_score_adj| {
                [
                    "OomScoreAdj".to_string(),
                    oom_score_adj.to_string(),
                ].join(",")
            }),


            self.pid_mode.as_ref().map(|pid_mode| {
                [
                    "PidMode".to_string(),
                    pid_mode.to_string(),
                ].join(",")
            }),


            self.pids_limit.as_ref().map(|pids_limit| {
                [
                    "PidsLimit".to_string(),
                    pids_limit.to_string(),
                ].join(",")
            }),

            // Skipping PortBindings in query parameter serialization
            // Skipping PortBindings in query parameter serialization


            self.privileged.as_ref().map(|privileged| {
                [
                    "Privileged".to_string(),
                    privileged.to_string(),
                ].join(",")
            }),


            self.publish_all_ports.as_ref().map(|publish_all_ports| {
                [
                    "PublishAllPorts".to_string(),
                    publish_all_ports.to_string(),
                ].join(",")
            }),


            self.readonly_paths.as_ref().map(|readonly_paths| {
                [
                    "ReadonlyPaths".to_string(),
                    readonly_paths.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.readonly_rootfs.as_ref().map(|readonly_rootfs| {
                [
                    "ReadonlyRootfs".to_string(),
                    readonly_rootfs.to_string(),
                ].join(",")
            }),

            // Skipping RestartPolicy in query parameter serialization


            self.runtime.as_ref().map(|runtime| {
                [
                    "Runtime".to_string(),
                    runtime.to_string(),
                ].join(",")
            }),


            self.security_opt.as_ref().map(|security_opt| {
                [
                    "SecurityOpt".to_string(),
                    security_opt.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.shm_size.as_ref().map(|shm_size| {
                [
                    "ShmSize".to_string(),
                    shm_size.to_string(),
                ].join(",")
            }),

            // Skipping StorageOpt in query parameter serialization

            // Skipping Sysctls in query parameter serialization

            // Skipping Tmpfs in query parameter serialization


            self.uts_mode.as_ref().map(|uts_mode| {
                [
                    "UTSMode".to_string(),
                    uts_mode.to_string(),
                ].join(",")
            }),

            // Skipping Ulimits in query parameter serialization


            self.userns_mode.as_ref().map(|userns_mode| {
                [
                    "UsernsMode".to_string(),
                    userns_mode.to_string(),
                ].join(",")
            }),


            self.volume_driver.as_ref().map(|volume_driver| {
                [
                    "VolumeDriver".to_string(),
                    volume_driver.to_string(),
                ].join(",")
            }),


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "VolumesFrom".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HostConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HostConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub auto_remove: Vec<bool>,
            pub binds: Vec<Vec<String>>,
            pub blkio_device_read_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_read_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_weight: Vec<i32>,
            pub blkio_weight_device: Vec<Vec<models::WeightDevice>>,
            pub cap_add: Vec<Vec<String>>,
            pub cap_drop: Vec<Vec<String>>,
            pub cgroup: Vec<String>,
            pub cgroup_parent: Vec<String>,
            pub cgroupns_mode: Vec<String>,
            pub console_size: Vec<Vec<i32>>,
            pub container_id_file: Vec<String>,
            pub cpu_count: Vec<i64>,
            pub cpu_percent: Vec<i64>,
            pub cpu_period: Vec<i64>,
            pub cpu_quota: Vec<i64>,
            pub cpu_realtime_period: Vec<i64>,
            pub cpu_realtime_runtime: Vec<i64>,
            pub cpu_shares: Vec<i64>,
            pub cpuset_cpus: Vec<String>,
            pub cpuset_mems: Vec<String>,
            pub device_cgroup_rules: Vec<Vec<String>>,
            pub device_requests: Vec<Vec<models::DeviceRequest>>,
            pub devices: Vec<Vec<models::DeviceMapping>>,
            pub dns: Vec<Vec<String>>,
            pub dns_options: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub extra_hosts: Vec<Vec<String>>,
            pub group_add: Vec<Vec<String>>,
            pub io_maximum_bandwidth: Vec<i32>,
            pub io_maximum_i_ops: Vec<i32>,
            pub init: Vec<bool>,
            pub ipc_mode: Vec<String>,
            pub isolation: Vec<String>,
            pub kernel_memory: Vec<i64>,
            pub kernel_memory_tcp: Vec<i64>,
            pub links: Vec<Vec<String>>,
            pub log_config: Vec<models::LogConfig>,
            pub masked_paths: Vec<Vec<String>>,
            pub memory: Vec<i64>,
            pub memory_reservation: Vec<i64>,
            pub memory_swap: Vec<i64>,
            pub memory_swappiness: Vec<i64>,
            pub mounts: Vec<Vec<models::Mount>>,
            pub nano_cpus: Vec<i64>,
            pub network_mode: Vec<String>,
            pub oom_kill_disable: Vec<bool>,
            pub oom_score_adj: Vec<i64>,
            pub pid_mode: Vec<String>,
            pub pids_limit: Vec<i64>,
            pub port_bindings: Vec<std::collections::HashMap<String, Vec<models::PortBinding>>>,
            pub privileged: Vec<bool>,
            pub publish_all_ports: Vec<bool>,
            pub readonly_paths: Vec<Vec<String>>,
            pub readonly_rootfs: Vec<bool>,
            pub restart_policy: Vec<models::RestartPolicy>,
            pub runtime: Vec<String>,
            pub security_opt: Vec<Vec<String>>,
            pub shm_size: Vec<i64>,
            pub storage_opt: Vec<std::collections::HashMap<String, String>>,
            pub sysctls: Vec<std::collections::HashMap<String, String>>,
            pub tmpfs: Vec<std::collections::HashMap<String, String>>,
            pub uts_mode: Vec<String>,
            pub ulimits: Vec<Vec<models::Ulimit>>,
            pub userns_mode: Vec<String>,
            pub volume_driver: Vec<String>,
            pub volumes_from: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HostConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "AutoRemove" => intermediate_rep.auto_remove.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Binds" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "BlkioDeviceReadBps" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "BlkioDeviceReadIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "BlkioDeviceWriteBps" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "BlkioDeviceWriteIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "BlkioWeight" => intermediate_rep.blkio_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "BlkioWeightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "CapAdd" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "CapDrop" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Cgroup" => intermediate_rep.cgroup.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CgroupParent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CgroupnsMode" => intermediate_rep.cgroupns_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ConsoleSize" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ContainerIDFile" => intermediate_rep.container_id_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuCount" => intermediate_rep.cpu_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPercent" => intermediate_rep.cpu_percent.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPeriod" => intermediate_rep.cpu_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuQuota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimePeriod" => intermediate_rep.cpu_realtime_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimeRuntime" => intermediate_rep.cpu_realtime_runtime.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuShares" => intermediate_rep.cpu_shares.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetCpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetMems" => intermediate_rep.cpuset_mems.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DeviceCgroupRules" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "DeviceRequests" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "Dns" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "DnsOptions" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "DnsSearch" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "ExtraHosts" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "GroupAdd" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumBandwidth" => intermediate_rep.io_maximum_bandwidth.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumIOps" => intermediate_rep.io_maximum_i_ops.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Init" => intermediate_rep.init.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IpcMode" => intermediate_rep.ipc_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Isolation" => intermediate_rep.isolation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemory" => intermediate_rep.kernel_memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemoryTCP" => intermediate_rep.kernel_memory_tcp.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Links" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "LogConfig" => intermediate_rep.log_config.push(<models::LogConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "MaskedPaths" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Memory" => intermediate_rep.memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemoryReservation" => intermediate_rep.memory_reservation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwap" => intermediate_rep.memory_swap.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwappiness" => intermediate_rep.memory_swappiness.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "NanoCpus" => intermediate_rep.nano_cpus.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkMode" => intermediate_rep.network_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomKillDisable" => intermediate_rep.oom_kill_disable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomScoreAdj" => intermediate_rep.oom_score_adj.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidMode" => intermediate_rep.pid_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidsLimit" => intermediate_rep.pids_limit.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "PortBindings" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Privileged" => intermediate_rep.privileged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PublishAllPorts" => intermediate_rep.publish_all_ports.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ReadonlyPaths" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ReadonlyRootfs" => intermediate_rep.readonly_rootfs.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestartPolicy" => intermediate_rep.restart_policy.push(<models::RestartPolicy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Runtime" => intermediate_rep.runtime.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "SecurityOpt" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ShmSize" => intermediate_rep.shm_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "StorageOpt" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "Sysctls" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    "Tmpfs" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "UTSMode" => intermediate_rep.uts_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ulimits" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "UsernsMode" => intermediate_rep.userns_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VolumeDriver" => intermediate_rep.volume_driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "VolumesFrom" => return std::result::Result::Err("Parsing a container in this style is not supported in HostConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing HostConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HostConfig {
            annotations: intermediate_rep.annotations.into_iter().next(),
            auto_remove: intermediate_rep.auto_remove.into_iter().next(),
            binds: intermediate_rep.binds.into_iter().next(),
            blkio_device_read_bps: intermediate_rep.blkio_device_read_bps.into_iter().next(),
            blkio_device_read_i_ops: intermediate_rep.blkio_device_read_i_ops.into_iter().next(),
            blkio_device_write_bps: intermediate_rep.blkio_device_write_bps.into_iter().next(),
            blkio_device_write_i_ops: intermediate_rep.blkio_device_write_i_ops.into_iter().next(),
            blkio_weight: intermediate_rep.blkio_weight.into_iter().next(),
            blkio_weight_device: intermediate_rep.blkio_weight_device.into_iter().next(),
            cap_add: intermediate_rep.cap_add.into_iter().next(),
            cap_drop: intermediate_rep.cap_drop.into_iter().next(),
            cgroup: intermediate_rep.cgroup.into_iter().next(),
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cgroupns_mode: intermediate_rep.cgroupns_mode.into_iter().next(),
            console_size: intermediate_rep.console_size.into_iter().next(),
            container_id_file: intermediate_rep.container_id_file.into_iter().next(),
            cpu_count: intermediate_rep.cpu_count.into_iter().next(),
            cpu_percent: intermediate_rep.cpu_percent.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            cpu_realtime_period: intermediate_rep.cpu_realtime_period.into_iter().next(),
            cpu_realtime_runtime: intermediate_rep.cpu_realtime_runtime.into_iter().next(),
            cpu_shares: intermediate_rep.cpu_shares.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            cpuset_mems: intermediate_rep.cpuset_mems.into_iter().next(),
            device_cgroup_rules: intermediate_rep.device_cgroup_rules.into_iter().next(),
            device_requests: intermediate_rep.device_requests.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            dns: intermediate_rep.dns.into_iter().next(),
            dns_options: intermediate_rep.dns_options.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            extra_hosts: intermediate_rep.extra_hosts.into_iter().next(),
            group_add: intermediate_rep.group_add.into_iter().next(),
            io_maximum_bandwidth: intermediate_rep.io_maximum_bandwidth.into_iter().next(),
            io_maximum_i_ops: intermediate_rep.io_maximum_i_ops.into_iter().next(),
            init: intermediate_rep.init.into_iter().next(),
            ipc_mode: intermediate_rep.ipc_mode.into_iter().next(),
            isolation: intermediate_rep.isolation.into_iter().next(),
            kernel_memory: intermediate_rep.kernel_memory.into_iter().next(),
            kernel_memory_tcp: intermediate_rep.kernel_memory_tcp.into_iter().next(),
            links: intermediate_rep.links.into_iter().next(),
            log_config: intermediate_rep.log_config.into_iter().next(),
            masked_paths: intermediate_rep.masked_paths.into_iter().next(),
            memory: intermediate_rep.memory.into_iter().next(),
            memory_reservation: intermediate_rep.memory_reservation.into_iter().next(),
            memory_swap: intermediate_rep.memory_swap.into_iter().next(),
            memory_swappiness: intermediate_rep.memory_swappiness.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            nano_cpus: intermediate_rep.nano_cpus.into_iter().next(),
            network_mode: intermediate_rep.network_mode.into_iter().next(),
            oom_kill_disable: intermediate_rep.oom_kill_disable.into_iter().next(),
            oom_score_adj: intermediate_rep.oom_score_adj.into_iter().next(),
            pid_mode: intermediate_rep.pid_mode.into_iter().next(),
            pids_limit: intermediate_rep.pids_limit.into_iter().next(),
            port_bindings: intermediate_rep.port_bindings.into_iter().next(),
            privileged: intermediate_rep.privileged.into_iter().next(),
            publish_all_ports: intermediate_rep.publish_all_ports.into_iter().next(),
            readonly_paths: intermediate_rep.readonly_paths.into_iter().next(),
            readonly_rootfs: intermediate_rep.readonly_rootfs.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            runtime: intermediate_rep.runtime.into_iter().next(),
            security_opt: intermediate_rep.security_opt.into_iter().next(),
            shm_size: intermediate_rep.shm_size.into_iter().next(),
            storage_opt: intermediate_rep.storage_opt.into_iter().next(),
            sysctls: intermediate_rep.sysctls.into_iter().next(),
            tmpfs: intermediate_rep.tmpfs.into_iter().next(),
            uts_mode: intermediate_rep.uts_mode.into_iter().next(),
            ulimits: intermediate_rep.ulimits.into_iter().next(),
            userns_mode: intermediate_rep.userns_mode.into_iter().next(),
            volume_driver: intermediate_rep.volume_driver.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HostConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HostConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HostConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HostConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HostConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HostConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HostConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// HostInfo describes the libpod host



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct HostInfo {
    #[serde(rename = "arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arch: Option<String>,

    #[serde(rename = "buildahVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buildah_version: Option<String>,

    #[serde(rename = "cgroupControllers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_controllers: Option<Vec<String>>,

    #[serde(rename = "cgroupManager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_manager: Option<String>,

    #[serde(rename = "cgroupVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_version: Option<String>,

    #[serde(rename = "conmon")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conmon: Option<models::ConmonInfo>,

    #[serde(rename = "cpuUtilization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_utilization: Option<models::CpuUsage>,

    #[serde(rename = "cpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpus: Option<i64>,

    #[serde(rename = "databaseBackend")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub database_backend: Option<String>,

    #[serde(rename = "distribution")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub distribution: Option<models::DistributionInfo>,

    #[serde(rename = "eventLogger")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_logger: Option<String>,

    #[serde(rename = "freeLocks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_locks: Option<i32>,

    #[serde(rename = "hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

    #[serde(rename = "idMappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id_mappings: Option<models::IdMappings>,

    #[serde(rename = "kernel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel: Option<String>,

    #[serde(rename = "linkmode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub linkmode: Option<String>,

    #[serde(rename = "logDriver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_driver: Option<String>,

    #[serde(rename = "memFree")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem_free: Option<i64>,

    #[serde(rename = "memTotal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem_total: Option<i64>,

    #[serde(rename = "networkBackend")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_backend: Option<String>,

    #[serde(rename = "networkBackendInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_backend_info: Option<models::NetworkInfo>,

    #[serde(rename = "ociRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oci_runtime: Option<models::OciRuntimeInfo>,

    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

    #[serde(rename = "pasta")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pasta: Option<models::PastaInfo>,

    #[serde(rename = "remoteSocket")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub remote_socket: Option<models::RemoteSocket>,

/// RootlessNetworkCmd returns the default rootless network command (slirp4netns or pasta)
    #[serde(rename = "rootlessNetworkCmd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootless_network_cmd: Option<String>,

    #[serde(rename = "runtimeInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub runtime_info: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "security")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security: Option<models::SecurityInfo>,

/// ServiceIsRemote is true when the podman/libpod service is remote to the client
    #[serde(rename = "serviceIsRemote")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_is_remote: Option<bool>,

    #[serde(rename = "slirp4netns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub slirp4netns: Option<models::SlirpInfo>,

    #[serde(rename = "swapFree")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub swap_free: Option<i64>,

    #[serde(rename = "swapTotal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub swap_total: Option<i64>,

    #[serde(rename = "uptime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uptime: Option<String>,

    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

}


impl HostInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> HostInfo {
        HostInfo {
            arch: None,
            buildah_version: None,
            cgroup_controllers: None,
            cgroup_manager: None,
            cgroup_version: None,
            conmon: None,
            cpu_utilization: None,
            cpus: None,
            database_backend: None,
            distribution: None,
            event_logger: None,
            free_locks: None,
            hostname: None,
            id_mappings: None,
            kernel: None,
            linkmode: None,
            log_driver: None,
            mem_free: None,
            mem_total: None,
            network_backend: None,
            network_backend_info: None,
            oci_runtime: None,
            os: None,
            pasta: None,
            remote_socket: None,
            rootless_network_cmd: None,
            runtime_info: None,
            security: None,
            service_is_remote: None,
            slirp4netns: None,
            swap_free: None,
            swap_total: None,
            uptime: None,
            variant: None,
        }
    }
}

/// Converts the HostInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for HostInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.arch.as_ref().map(|arch| {
                [
                    "arch".to_string(),
                    arch.to_string(),
                ].join(",")
            }),


            self.buildah_version.as_ref().map(|buildah_version| {
                [
                    "buildahVersion".to_string(),
                    buildah_version.to_string(),
                ].join(",")
            }),


            self.cgroup_controllers.as_ref().map(|cgroup_controllers| {
                [
                    "cgroupControllers".to_string(),
                    cgroup_controllers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cgroup_manager.as_ref().map(|cgroup_manager| {
                [
                    "cgroupManager".to_string(),
                    cgroup_manager.to_string(),
                ].join(",")
            }),


            self.cgroup_version.as_ref().map(|cgroup_version| {
                [
                    "cgroupVersion".to_string(),
                    cgroup_version.to_string(),
                ].join(",")
            }),

            // Skipping conmon in query parameter serialization

            // Skipping cpuUtilization in query parameter serialization


            self.cpus.as_ref().map(|cpus| {
                [
                    "cpus".to_string(),
                    cpus.to_string(),
                ].join(",")
            }),


            self.database_backend.as_ref().map(|database_backend| {
                [
                    "databaseBackend".to_string(),
                    database_backend.to_string(),
                ].join(",")
            }),

            // Skipping distribution in query parameter serialization


            self.event_logger.as_ref().map(|event_logger| {
                [
                    "eventLogger".to_string(),
                    event_logger.to_string(),
                ].join(",")
            }),


            self.free_locks.as_ref().map(|free_locks| {
                [
                    "freeLocks".to_string(),
                    free_locks.to_string(),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),

            // Skipping idMappings in query parameter serialization


            self.kernel.as_ref().map(|kernel| {
                [
                    "kernel".to_string(),
                    kernel.to_string(),
                ].join(",")
            }),


            self.linkmode.as_ref().map(|linkmode| {
                [
                    "linkmode".to_string(),
                    linkmode.to_string(),
                ].join(",")
            }),


            self.log_driver.as_ref().map(|log_driver| {
                [
                    "logDriver".to_string(),
                    log_driver.to_string(),
                ].join(",")
            }),


            self.mem_free.as_ref().map(|mem_free| {
                [
                    "memFree".to_string(),
                    mem_free.to_string(),
                ].join(",")
            }),


            self.mem_total.as_ref().map(|mem_total| {
                [
                    "memTotal".to_string(),
                    mem_total.to_string(),
                ].join(",")
            }),


            self.network_backend.as_ref().map(|network_backend| {
                [
                    "networkBackend".to_string(),
                    network_backend.to_string(),
                ].join(",")
            }),

            // Skipping networkBackendInfo in query parameter serialization

            // Skipping ociRuntime in query parameter serialization


            self.os.as_ref().map(|os| {
                [
                    "os".to_string(),
                    os.to_string(),
                ].join(",")
            }),

            // Skipping pasta in query parameter serialization

            // Skipping remoteSocket in query parameter serialization


            self.rootless_network_cmd.as_ref().map(|rootless_network_cmd| {
                [
                    "rootlessNetworkCmd".to_string(),
                    rootless_network_cmd.to_string(),
                ].join(",")
            }),

            // Skipping runtimeInfo in query parameter serialization
            // Skipping runtimeInfo in query parameter serialization

            // Skipping security in query parameter serialization


            self.service_is_remote.as_ref().map(|service_is_remote| {
                [
                    "serviceIsRemote".to_string(),
                    service_is_remote.to_string(),
                ].join(",")
            }),

            // Skipping slirp4netns in query parameter serialization


            self.swap_free.as_ref().map(|swap_free| {
                [
                    "swapFree".to_string(),
                    swap_free.to_string(),
                ].join(",")
            }),


            self.swap_total.as_ref().map(|swap_total| {
                [
                    "swapTotal".to_string(),
                    swap_total.to_string(),
                ].join(",")
            }),


            self.uptime.as_ref().map(|uptime| {
                [
                    "uptime".to_string(),
                    uptime.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a HostInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for HostInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub arch: Vec<String>,
            pub buildah_version: Vec<String>,
            pub cgroup_controllers: Vec<Vec<String>>,
            pub cgroup_manager: Vec<String>,
            pub cgroup_version: Vec<String>,
            pub conmon: Vec<models::ConmonInfo>,
            pub cpu_utilization: Vec<models::CpuUsage>,
            pub cpus: Vec<i64>,
            pub database_backend: Vec<String>,
            pub distribution: Vec<models::DistributionInfo>,
            pub event_logger: Vec<String>,
            pub free_locks: Vec<i32>,
            pub hostname: Vec<String>,
            pub id_mappings: Vec<models::IdMappings>,
            pub kernel: Vec<String>,
            pub linkmode: Vec<String>,
            pub log_driver: Vec<String>,
            pub mem_free: Vec<i64>,
            pub mem_total: Vec<i64>,
            pub network_backend: Vec<String>,
            pub network_backend_info: Vec<models::NetworkInfo>,
            pub oci_runtime: Vec<models::OciRuntimeInfo>,
            pub os: Vec<String>,
            pub pasta: Vec<models::PastaInfo>,
            pub remote_socket: Vec<models::RemoteSocket>,
            pub rootless_network_cmd: Vec<String>,
            pub runtime_info: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub security: Vec<models::SecurityInfo>,
            pub service_is_remote: Vec<bool>,
            pub slirp4netns: Vec<models::SlirpInfo>,
            pub swap_free: Vec<i64>,
            pub swap_total: Vec<i64>,
            pub uptime: Vec<String>,
            pub variant: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing HostInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "arch" => intermediate_rep.arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "buildahVersion" => intermediate_rep.buildah_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "cgroupControllers" => return std::result::Result::Err("Parsing a container in this style is not supported in HostInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cgroupManager" => intermediate_rep.cgroup_manager.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cgroupVersion" => intermediate_rep.cgroup_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conmon" => intermediate_rep.conmon.push(<models::ConmonInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpuUtilization" => intermediate_rep.cpu_utilization.push(<models::CpuUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpus" => intermediate_rep.cpus.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "databaseBackend" => intermediate_rep.database_backend.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "distribution" => intermediate_rep.distribution.push(<models::DistributionInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "eventLogger" => intermediate_rep.event_logger.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "freeLocks" => intermediate_rep.free_locks.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "idMappings" => intermediate_rep.id_mappings.push(<models::IdMappings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kernel" => intermediate_rep.kernel.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "linkmode" => intermediate_rep.linkmode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logDriver" => intermediate_rep.log_driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "memFree" => intermediate_rep.mem_free.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "memTotal" => intermediate_rep.mem_total.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "networkBackend" => intermediate_rep.network_backend.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "networkBackendInfo" => intermediate_rep.network_backend_info.push(<models::NetworkInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ociRuntime" => intermediate_rep.oci_runtime.push(<models::OciRuntimeInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pasta" => intermediate_rep.pasta.push(<models::PastaInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "remoteSocket" => intermediate_rep.remote_socket.push(<models::RemoteSocket as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootlessNetworkCmd" => intermediate_rep.rootless_network_cmd.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "runtimeInfo" => return std::result::Result::Err("Parsing a container in this style is not supported in HostInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "security" => intermediate_rep.security.push(<models::SecurityInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "serviceIsRemote" => intermediate_rep.service_is_remote.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "slirp4netns" => intermediate_rep.slirp4netns.push(<models::SlirpInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "swapFree" => intermediate_rep.swap_free.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "swapTotal" => intermediate_rep.swap_total.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uptime" => intermediate_rep.uptime.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing HostInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(HostInfo {
            arch: intermediate_rep.arch.into_iter().next(),
            buildah_version: intermediate_rep.buildah_version.into_iter().next(),
            cgroup_controllers: intermediate_rep.cgroup_controllers.into_iter().next(),
            cgroup_manager: intermediate_rep.cgroup_manager.into_iter().next(),
            cgroup_version: intermediate_rep.cgroup_version.into_iter().next(),
            conmon: intermediate_rep.conmon.into_iter().next(),
            cpu_utilization: intermediate_rep.cpu_utilization.into_iter().next(),
            cpus: intermediate_rep.cpus.into_iter().next(),
            database_backend: intermediate_rep.database_backend.into_iter().next(),
            distribution: intermediate_rep.distribution.into_iter().next(),
            event_logger: intermediate_rep.event_logger.into_iter().next(),
            free_locks: intermediate_rep.free_locks.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            id_mappings: intermediate_rep.id_mappings.into_iter().next(),
            kernel: intermediate_rep.kernel.into_iter().next(),
            linkmode: intermediate_rep.linkmode.into_iter().next(),
            log_driver: intermediate_rep.log_driver.into_iter().next(),
            mem_free: intermediate_rep.mem_free.into_iter().next(),
            mem_total: intermediate_rep.mem_total.into_iter().next(),
            network_backend: intermediate_rep.network_backend.into_iter().next(),
            network_backend_info: intermediate_rep.network_backend_info.into_iter().next(),
            oci_runtime: intermediate_rep.oci_runtime.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            pasta: intermediate_rep.pasta.into_iter().next(),
            remote_socket: intermediate_rep.remote_socket.into_iter().next(),
            rootless_network_cmd: intermediate_rep.rootless_network_cmd.into_iter().next(),
            runtime_info: intermediate_rep.runtime_info.into_iter().next(),
            security: intermediate_rep.security.into_iter().next(),
            service_is_remote: intermediate_rep.service_is_remote.into_iter().next(),
            slirp4netns: intermediate_rep.slirp4netns.into_iter().next(),
            swap_free: intermediate_rep.swap_free.into_iter().next(),
            swap_total: intermediate_rep.swap_total.into_iter().next(),
            uptime: intermediate_rep.uptime.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<HostInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<HostInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<HostInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for HostInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<HostInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <HostInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into HostInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// IDMap contains a single entry for user namespace range remapping. An array of IDMap entries represents the structure that will be provided to the Linux kernel for creating a user namespace.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdMap {
    #[serde(rename = "container_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_id: Option<i64>,

    #[serde(rename = "host_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_id: Option<i64>,

    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

}


impl IdMap {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IdMap {
        IdMap {
            container_id: None,
            host_id: None,
            size: None,
        }
    }
}

/// Converts the IdMap value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IdMap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.container_id.as_ref().map(|container_id| {
                [
                    "container_id".to_string(),
                    container_id.to_string(),
                ].join(",")
            }),


            self.host_id.as_ref().map(|host_id| {
                [
                    "host_id".to_string(),
                    host_id.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdMap value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdMap {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container_id: Vec<i64>,
            pub host_id: Vec<i64>,
            pub size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IdMap".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "container_id" => intermediate_rep.container_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "host_id" => intermediate_rep.host_id.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IdMap".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdMap {
            container_id: intermediate_rep.container_id.into_iter().next(),
            host_id: intermediate_rep.host_id.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdMap> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IdMap>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IdMap>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IdMap - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IdMap> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IdMap as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IdMap - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// IDMappingOptions are used for specifying how ID mapping should be set up for a layer or container.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdMappingOptions {
    #[serde(rename = "AutoUserNs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_user_ns: Option<bool>,

    #[serde(rename = "AutoUserNsOpts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_user_ns_opts: Option<models::AutoUserNsOptions>,

    #[serde(rename = "GIDMap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gid_map: Option<Vec<models::IdMap>>,

    #[serde(rename = "HostGIDMapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_gid_mapping: Option<bool>,

/// UIDMap and GIDMap are used for setting up a layer's root filesystem for use inside of a user namespace where ID mapping is being used. If HostUIDMapping/HostGIDMapping is true, no mapping of the respective type will be used.  Otherwise, if UIDMap and/or GIDMap contain at least one mapping, one or both will be used.  By default, if neither of those conditions apply, if the layer has a parent layer, the parent layer's mapping will be used, and if it does not have a parent layer, the mapping which was passed to the Store object when it was initialized will be used.
    #[serde(rename = "HostUIDMapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_uid_mapping: Option<bool>,

    #[serde(rename = "UIDMap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid_map: Option<Vec<models::IdMap>>,

}


impl IdMappingOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IdMappingOptions {
        IdMappingOptions {
            auto_user_ns: None,
            auto_user_ns_opts: None,
            gid_map: None,
            host_gid_mapping: None,
            host_uid_mapping: None,
            uid_map: None,
        }
    }
}

/// Converts the IdMappingOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IdMappingOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.auto_user_ns.as_ref().map(|auto_user_ns| {
                [
                    "AutoUserNs".to_string(),
                    auto_user_ns.to_string(),
                ].join(",")
            }),

            // Skipping AutoUserNsOpts in query parameter serialization

            // Skipping GIDMap in query parameter serialization


            self.host_gid_mapping.as_ref().map(|host_gid_mapping| {
                [
                    "HostGIDMapping".to_string(),
                    host_gid_mapping.to_string(),
                ].join(",")
            }),


            self.host_uid_mapping.as_ref().map(|host_uid_mapping| {
                [
                    "HostUIDMapping".to_string(),
                    host_uid_mapping.to_string(),
                ].join(",")
            }),

            // Skipping UIDMap in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdMappingOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdMappingOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auto_user_ns: Vec<bool>,
            pub auto_user_ns_opts: Vec<models::AutoUserNsOptions>,
            pub gid_map: Vec<Vec<models::IdMap>>,
            pub host_gid_mapping: Vec<bool>,
            pub host_uid_mapping: Vec<bool>,
            pub uid_map: Vec<Vec<models::IdMap>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IdMappingOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AutoUserNs" => intermediate_rep.auto_user_ns.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AutoUserNsOpts" => intermediate_rep.auto_user_ns_opts.push(<models::AutoUserNsOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "GIDMap" => return std::result::Result::Err("Parsing a container in this style is not supported in IdMappingOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "HostGIDMapping" => intermediate_rep.host_gid_mapping.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostUIDMapping" => intermediate_rep.host_uid_mapping.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "UIDMap" => return std::result::Result::Err("Parsing a container in this style is not supported in IdMappingOptions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing IdMappingOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdMappingOptions {
            auto_user_ns: intermediate_rep.auto_user_ns.into_iter().next(),
            auto_user_ns_opts: intermediate_rep.auto_user_ns_opts.into_iter().next(),
            gid_map: intermediate_rep.gid_map.into_iter().next(),
            host_gid_mapping: intermediate_rep.host_gid_mapping.into_iter().next(),
            host_uid_mapping: intermediate_rep.host_uid_mapping.into_iter().next(),
            uid_map: intermediate_rep.uid_map.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdMappingOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IdMappingOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IdMappingOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IdMappingOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IdMappingOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IdMappingOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IdMappingOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// IDMappings describe the GID and UID mappings



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdMappings {
    #[serde(rename = "gidmap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gidmap: Option<Vec<models::IdMap>>,

    #[serde(rename = "uidmap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uidmap: Option<Vec<models::IdMap>>,

}


impl IdMappings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IdMappings {
        IdMappings {
            gidmap: None,
            uidmap: None,
        }
    }
}

/// Converts the IdMappings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IdMappings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping gidmap in query parameter serialization

            // Skipping uidmap in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdMappings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdMappings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gidmap: Vec<Vec<models::IdMap>>,
            pub uidmap: Vec<Vec<models::IdMap>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IdMappings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "gidmap" => return std::result::Result::Err("Parsing a container in this style is not supported in IdMappings".to_string()),
                    "uidmap" => return std::result::Result::Err("Parsing a container in this style is not supported in IdMappings".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing IdMappings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdMappings {
            gidmap: intermediate_rep.gidmap.into_iter().next(),
            uidmap: intermediate_rep.uidmap.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdMappings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IdMappings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IdMappings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IdMappings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IdMappings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IdMappings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IdMappings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// IDResponse Response to an API call that returns just an Id



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IdResponse {
/// The id of the newly created object.
    #[serde(rename = "Id")]
    pub id: String,

}


impl IdResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, ) -> IdResponse {
        IdResponse {
            id,
        }
    }
}

/// Converts the IdResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IdResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Id".to_string()),
            Some(self.id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IdResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IdResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IdResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IdResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IdResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in IdResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IdResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IdResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IdResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IdResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IdResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IdResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IdResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageBuild200Response {
/// output from build process
    #[serde(rename = "stream")]
    pub stream: String,

}


impl ImageBuild200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(stream: String, ) -> ImageBuild200Response {
        ImageBuild200Response {
            stream,
        }
    }
}

/// Converts the ImageBuild200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageBuild200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("stream".to_string()),
            Some(self.stream.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageBuild200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageBuild200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub stream: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageBuild200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "stream" => intermediate_rep.stream.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageBuild200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageBuild200Response {
            stream: intermediate_rep.stream.into_iter().next().ok_or_else(|| "stream missing in ImageBuild200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageBuild200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageBuild200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageBuild200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageBuild200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageBuild200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageBuild200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageBuild200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageBuildLibpod200Response {
/// output from build process
    #[serde(rename = "stream")]
    pub stream: String,

}


impl ImageBuildLibpod200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(stream: String, ) -> ImageBuildLibpod200Response {
        ImageBuildLibpod200Response {
            stream,
        }
    }
}

/// Converts the ImageBuildLibpod200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageBuildLibpod200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("stream".to_string()),
            Some(self.stream.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageBuildLibpod200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageBuildLibpod200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub stream: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageBuildLibpod200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "stream" => intermediate_rep.stream.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageBuildLibpod200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageBuildLibpod200Response {
            stream: intermediate_rep.stream.into_iter().next().ok_or_else(|| "stream missing in ImageBuildLibpod200Response".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageBuildLibpod200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageBuildLibpod200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageBuildLibpod200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageBuildLibpod200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageBuildLibpod200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageBuildLibpod200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageBuildLibpod200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageConfig {
/// ArgsEscaped  Deprecated: This field is present only for legacy compatibility with Docker and should not be used by new image builders.  It is used by Docker for Windows images to indicate that the `Entrypoint` or `Cmd` or both, contains only a single element array, that is a pre-escaped, and combined into a single string `CommandLine`. If `true` the value in `Entrypoint` or `Cmd` should be used as-is to avoid double escaping. https://github.com/opencontainers/image-spec/pull/892
    #[serde(rename = "ArgsEscaped")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args_escaped: Option<bool>,

/// Cmd defines the default arguments to the entrypoint of the container.
    #[serde(rename = "Cmd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cmd: Option<Vec<String>>,

/// Entrypoint defines a list of arguments to use as the command to execute when the container starts.
    #[serde(rename = "Entrypoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrypoint: Option<Vec<String>>,

/// Env is a list of environment variables to be used in a container.
    #[serde(rename = "Env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<String>>,

/// ExposedPorts a set of ports to expose from a container running this image.
    #[serde(rename = "ExposedPorts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exposed_ports: Option<std::collections::HashMap<String, crate::types::Object>>,

/// Labels contains arbitrary metadata for the container.
    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// StopSignal contains the system call signal that will be sent to the container to exit.
    #[serde(rename = "StopSignal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_signal: Option<String>,

/// User defines the username or UID which the process in the container should run as.
    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

/// Volumes is a set of directories describing where the process is likely write data specific to a container instance.
    #[serde(rename = "Volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<std::collections::HashMap<String, crate::types::Object>>,

/// WorkingDir sets the current working directory of the entrypoint process in the container.
    #[serde(rename = "WorkingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

}


impl ImageConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageConfig {
        ImageConfig {
            args_escaped: None,
            cmd: None,
            entrypoint: None,
            env: None,
            exposed_ports: None,
            labels: None,
            stop_signal: None,
            user: None,
            volumes: None,
            working_dir: None,
        }
    }
}

/// Converts the ImageConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.args_escaped.as_ref().map(|args_escaped| {
                [
                    "ArgsEscaped".to_string(),
                    args_escaped.to_string(),
                ].join(",")
            }),


            self.cmd.as_ref().map(|cmd| {
                [
                    "Cmd".to_string(),
                    cmd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.entrypoint.as_ref().map(|entrypoint| {
                [
                    "Entrypoint".to_string(),
                    entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.env.as_ref().map(|env| {
                [
                    "Env".to_string(),
                    env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping ExposedPorts in query parameter serialization
            // Skipping ExposedPorts in query parameter serialization

            // Skipping Labels in query parameter serialization


            self.stop_signal.as_ref().map(|stop_signal| {
                [
                    "StopSignal".to_string(),
                    stop_signal.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "User".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping Volumes in query parameter serialization
            // Skipping Volumes in query parameter serialization


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "WorkingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args_escaped: Vec<bool>,
            pub cmd: Vec<Vec<String>>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<Vec<String>>,
            pub exposed_ports: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub stop_signal: Vec<String>,
            pub user: Vec<String>,
            pub volumes: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub working_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ArgsEscaped" => intermediate_rep.args_escaped.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Cmd" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageConfig".to_string()),
                    "Entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageConfig".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageConfig".to_string()),
                    "ExposedPorts" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageConfig".to_string()),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "StopSignal" => intermediate_rep.stop_signal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "WorkingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageConfig {
            args_escaped: intermediate_rep.args_escaped.into_iter().next(),
            cmd: intermediate_rep.cmd.into_iter().next(),
            entrypoint: intermediate_rep.entrypoint.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            exposed_ports: intermediate_rep.exposed_ports.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            stop_signal: intermediate_rep.stop_signal.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageData {
    #[serde(rename = "Annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Architecture")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub architecture: Option<String>,

    #[serde(rename = "Author")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<String>,

    #[serde(rename = "Comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<models::ImageConfig>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

/// The following is an example of the contents of Digest types:  sha256:7173b809ca12ec5dee4506cd86be934c4596dd234ee82c0662eac04a8c2c71dc  This allows to abstract the digest behind this type and work only in those terms.
    #[serde(rename = "Digest")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub digest: Option<String>,

    #[serde(rename = "GraphDriver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_driver: Option<models::DriverData>,

    #[serde(rename = "Healthcheck")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healthcheck: Option<models::Schema2HealthConfig>,

    #[serde(rename = "History")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub history: Option<Vec<models::History>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "ManifestType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifest_type: Option<String>,

    #[serde(rename = "NamesHistory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub names_history: Option<Vec<String>>,

    #[serde(rename = "Os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

    #[serde(rename = "Parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<String>,

    #[serde(rename = "RepoDigests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo_digests: Option<Vec<String>>,

    #[serde(rename = "RepoTags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo_tags: Option<Vec<String>>,

    #[serde(rename = "RootFS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub root_fs: Option<models::RootFs>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

    #[serde(rename = "Version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

    #[serde(rename = "VirtualSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub virtual_size: Option<i64>,

}


impl ImageData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageData {
        ImageData {
            annotations: None,
            architecture: None,
            author: None,
            comment: None,
            config: None,
            created: None,
            digest: None,
            graph_driver: None,
            healthcheck: None,
            history: None,
            id: None,
            labels: None,
            manifest_type: None,
            names_history: None,
            os: None,
            parent: None,
            repo_digests: None,
            repo_tags: None,
            root_fs: None,
            size: None,
            user: None,
            version: None,
            virtual_size: None,
        }
    }
}

/// Converts the ImageData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Annotations in query parameter serialization


            self.architecture.as_ref().map(|architecture| {
                [
                    "Architecture".to_string(),
                    architecture.to_string(),
                ].join(",")
            }),


            self.author.as_ref().map(|author| {
                [
                    "Author".to_string(),
                    author.to_string(),
                ].join(",")
            }),


            self.comment.as_ref().map(|comment| {
                [
                    "Comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),

            // Skipping Config in query parameter serialization

            // Skipping Created in query parameter serialization


            self.digest.as_ref().map(|digest| {
                [
                    "Digest".to_string(),
                    digest.to_string(),
                ].join(",")
            }),

            // Skipping GraphDriver in query parameter serialization

            // Skipping Healthcheck in query parameter serialization

            // Skipping History in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.manifest_type.as_ref().map(|manifest_type| {
                [
                    "ManifestType".to_string(),
                    manifest_type.to_string(),
                ].join(",")
            }),


            self.names_history.as_ref().map(|names_history| {
                [
                    "NamesHistory".to_string(),
                    names_history.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os.as_ref().map(|os| {
                [
                    "Os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.parent.as_ref().map(|parent| {
                [
                    "Parent".to_string(),
                    parent.to_string(),
                ].join(",")
            }),


            self.repo_digests.as_ref().map(|repo_digests| {
                [
                    "RepoDigests".to_string(),
                    repo_digests.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.repo_tags.as_ref().map(|repo_tags| {
                [
                    "RepoTags".to_string(),
                    repo_tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping RootFS in query parameter serialization


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "User".to_string(),
                    user.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "Version".to_string(),
                    version.to_string(),
                ].join(",")
            }),


            self.virtual_size.as_ref().map(|virtual_size| {
                [
                    "VirtualSize".to_string(),
                    virtual_size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub architecture: Vec<String>,
            pub author: Vec<String>,
            pub comment: Vec<String>,
            pub config: Vec<models::ImageConfig>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub digest: Vec<String>,
            pub graph_driver: Vec<models::DriverData>,
            pub healthcheck: Vec<models::Schema2HealthConfig>,
            pub history: Vec<Vec<models::History>>,
            pub id: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub manifest_type: Vec<String>,
            pub names_history: Vec<Vec<String>>,
            pub os: Vec<String>,
            pub parent: Vec<String>,
            pub repo_digests: Vec<Vec<String>>,
            pub repo_tags: Vec<Vec<String>>,
            pub root_fs: Vec<models::RootFs>,
            pub size: Vec<i64>,
            pub user: Vec<String>,
            pub version: Vec<String>,
            pub virtual_size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Architecture" => intermediate_rep.architecture.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Author" => intermediate_rep.author.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Config" => intermediate_rep.config.push(<models::ImageConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Digest" => intermediate_rep.digest.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GraphDriver" => intermediate_rep.graph_driver.push(<models::DriverData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Healthcheck" => intermediate_rep.healthcheck.push(<models::Schema2HealthConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "History" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ManifestType" => intermediate_rep.manifest_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "NamesHistory" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Parent" => intermediate_rep.parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "RepoDigests" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageData".to_string()),
                    "RepoTags" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "RootFS" => intermediate_rep.root_fs.push(<models::RootFs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VirtualSize" => intermediate_rep.virtual_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageData {
            annotations: intermediate_rep.annotations.into_iter().next(),
            architecture: intermediate_rep.architecture.into_iter().next(),
            author: intermediate_rep.author.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
            config: intermediate_rep.config.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            digest: intermediate_rep.digest.into_iter().next(),
            graph_driver: intermediate_rep.graph_driver.into_iter().next(),
            healthcheck: intermediate_rep.healthcheck.into_iter().next(),
            history: intermediate_rep.history.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            manifest_type: intermediate_rep.manifest_type.into_iter().next(),
            names_history: intermediate_rep.names_history.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            parent: intermediate_rep.parent.into_iter().next(),
            repo_digests: intermediate_rep.repo_digests.into_iter().next(),
            repo_tags: intermediate_rep.repo_tags.into_iter().next(),
            root_fs: intermediate_rep.root_fs.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
            virtual_size: intermediate_rep.virtual_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageDelete200ResponseInner {
    #[serde(rename = "deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<String>,

    #[serde(rename = "untagged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub untagged: Option<Vec<String>>,

}


impl ImageDelete200ResponseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageDelete200ResponseInner {
        ImageDelete200ResponseInner {
            deleted: None,
            untagged: None,
        }
    }
}

/// Converts the ImageDelete200ResponseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageDelete200ResponseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.deleted.as_ref().map(|deleted| {
                [
                    "deleted".to_string(),
                    deleted.to_string(),
                ].join(",")
            }),


            self.untagged.as_ref().map(|untagged| {
                [
                    "untagged".to_string(),
                    untagged.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageDelete200ResponseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageDelete200ResponseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub deleted: Vec<String>,
            pub untagged: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageDelete200ResponseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "untagged" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageDelete200ResponseInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageDelete200ResponseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageDelete200ResponseInner {
            deleted: intermediate_rep.deleted.into_iter().next(),
            untagged: intermediate_rep.untagged.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageDelete200ResponseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageDelete200ResponseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageDelete200ResponseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageDelete200ResponseInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageDelete200ResponseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageDelete200ResponseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageDelete200ResponseInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageImportReport {
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl ImageImportReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageImportReport {
        ImageImportReport {
            id: None,
        }
    }
}

/// Converts the ImageImportReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageImportReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageImportReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageImportReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageImportReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageImportReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageImportReport {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageImportReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageImportReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageImportReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageImportReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageImportReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageImportReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageImportReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageInspect {
/// Architecture is the hardware CPU architecture that the image runs on.
    #[serde(rename = "Architecture")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub architecture: Option<String>,

/// Author is the name of the author that was specified when committing the image, or as specified through MAINTAINER (deprecated) in the Dockerfile.
    #[serde(rename = "Author")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<String>,

/// Comment is an optional message that can be set when committing or importing the image.
    #[serde(rename = "Comment")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,

    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<models::Config>,

/// Container is for backwards compat but is basically unused
    #[serde(rename = "Container")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container: Option<String>,

    #[serde(rename = "ContainerConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_config: Option<models::Config>,

/// Created is the date and time at which the image was created, formatted in RFC 3339 nano-seconds (time.RFC3339Nano).  This information is only available if present in the image, and omitted otherwise.
    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<String>,

/// DockerVersion is the version of Docker that was used to build the image.  Depending on how the image was created, this field may be empty.
    #[serde(rename = "DockerVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker_version: Option<String>,

    #[serde(rename = "GraphDriver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_driver: Option<models::GraphDriverData>,

/// ID is the content-addressable ID of an image.  This identifier is a content-addressable digest calculated from the image's configuration (which includes the digests of layers used by the image).  Note that this digest differs from the `RepoDigests` below, which holds digests of image manifests that reference the image.
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<models::Metadata>,

/// OS is the Operating System the image is built to run on.
    #[serde(rename = "Os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

/// OsVersion is the version of the Operating System the image is built to run on (especially for Windows).
    #[serde(rename = "OsVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_version: Option<String>,

/// Parent is the ID of the parent image.  Depending on how the image was created, this field may be empty and is only set for images that were built/created locally. This field is empty if the image was pulled from an image registry.
    #[serde(rename = "Parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<String>,

/// RepoDigests is a list of content-addressable digests of locally available image manifests that the image is referenced from. Multiple manifests can refer to the same image.  These digests are usually only available if the image was either pulled from a registry, or if the image was pushed to a registry, which is when the manifest is generated and its digest calculated.
    #[serde(rename = "RepoDigests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo_digests: Option<Vec<String>>,

/// RepoTags is a list of image names/tags in the local image cache that reference this image.  Multiple image tags can refer to the same image, and this list may be empty if no tags reference the image, in which case the image is \"untagged\", in which case it can still be referenced by its ID.
    #[serde(rename = "RepoTags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo_tags: Option<Vec<String>>,

    #[serde(rename = "RootFS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub root_fs: Option<models::RootFs>,

/// Size is the total size of the image including all layers it is composed of.
    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

/// Variant is the CPU architecture variant (presently ARM-only).
    #[serde(rename = "Variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

/// VirtualSize is the total size of the image including all layers it is composed of.  Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
    #[serde(rename = "VirtualSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub virtual_size: Option<i64>,

}


impl ImageInspect {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageInspect {
        ImageInspect {
            architecture: None,
            author: None,
            comment: None,
            config: None,
            container: None,
            container_config: None,
            created: None,
            docker_version: None,
            graph_driver: None,
            id: None,
            metadata: None,
            os: None,
            os_version: None,
            parent: None,
            repo_digests: None,
            repo_tags: None,
            root_fs: None,
            size: None,
            variant: None,
            virtual_size: None,
        }
    }
}

/// Converts the ImageInspect value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageInspect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.architecture.as_ref().map(|architecture| {
                [
                    "Architecture".to_string(),
                    architecture.to_string(),
                ].join(",")
            }),


            self.author.as_ref().map(|author| {
                [
                    "Author".to_string(),
                    author.to_string(),
                ].join(",")
            }),


            self.comment.as_ref().map(|comment| {
                [
                    "Comment".to_string(),
                    comment.to_string(),
                ].join(",")
            }),

            // Skipping Config in query parameter serialization


            self.container.as_ref().map(|container| {
                [
                    "Container".to_string(),
                    container.to_string(),
                ].join(",")
            }),

            // Skipping ContainerConfig in query parameter serialization


            self.created.as_ref().map(|created| {
                [
                    "Created".to_string(),
                    created.to_string(),
                ].join(",")
            }),


            self.docker_version.as_ref().map(|docker_version| {
                [
                    "DockerVersion".to_string(),
                    docker_version.to_string(),
                ].join(",")
            }),

            // Skipping GraphDriver in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping Metadata in query parameter serialization


            self.os.as_ref().map(|os| {
                [
                    "Os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.os_version.as_ref().map(|os_version| {
                [
                    "OsVersion".to_string(),
                    os_version.to_string(),
                ].join(",")
            }),


            self.parent.as_ref().map(|parent| {
                [
                    "Parent".to_string(),
                    parent.to_string(),
                ].join(",")
            }),


            self.repo_digests.as_ref().map(|repo_digests| {
                [
                    "RepoDigests".to_string(),
                    repo_digests.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.repo_tags.as_ref().map(|repo_tags| {
                [
                    "RepoTags".to_string(),
                    repo_tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping RootFS in query parameter serialization


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "Variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),


            self.virtual_size.as_ref().map(|virtual_size| {
                [
                    "VirtualSize".to_string(),
                    virtual_size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageInspect value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageInspect {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub architecture: Vec<String>,
            pub author: Vec<String>,
            pub comment: Vec<String>,
            pub config: Vec<models::Config>,
            pub container: Vec<String>,
            pub container_config: Vec<models::Config>,
            pub created: Vec<String>,
            pub docker_version: Vec<String>,
            pub graph_driver: Vec<models::GraphDriverData>,
            pub id: Vec<String>,
            pub metadata: Vec<models::Metadata>,
            pub os: Vec<String>,
            pub os_version: Vec<String>,
            pub parent: Vec<String>,
            pub repo_digests: Vec<Vec<String>>,
            pub repo_tags: Vec<Vec<String>>,
            pub root_fs: Vec<models::RootFs>,
            pub size: Vec<i64>,
            pub variant: Vec<String>,
            pub virtual_size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageInspect".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Architecture" => intermediate_rep.architecture.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Author" => intermediate_rep.author.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Comment" => intermediate_rep.comment.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Config" => intermediate_rep.config.push(<models::Config as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Container" => intermediate_rep.container.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ContainerConfig" => intermediate_rep.container_config.push(<models::Config as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DockerVersion" => intermediate_rep.docker_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GraphDriver" => intermediate_rep.graph_driver.push(<models::GraphDriverData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Metadata" => intermediate_rep.metadata.push(<models::Metadata as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OsVersion" => intermediate_rep.os_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Parent" => intermediate_rep.parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "RepoDigests" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageInspect".to_string()),
                    "RepoTags" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageInspect".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "RootFS" => intermediate_rep.root_fs.push(<models::RootFs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VirtualSize" => intermediate_rep.virtual_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageInspect".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageInspect {
            architecture: intermediate_rep.architecture.into_iter().next(),
            author: intermediate_rep.author.into_iter().next(),
            comment: intermediate_rep.comment.into_iter().next(),
            config: intermediate_rep.config.into_iter().next(),
            container: intermediate_rep.container.into_iter().next(),
            container_config: intermediate_rep.container_config.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            docker_version: intermediate_rep.docker_version.into_iter().next(),
            graph_driver: intermediate_rep.graph_driver.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            os_version: intermediate_rep.os_version.into_iter().next(),
            parent: intermediate_rep.parent.into_iter().next(),
            repo_digests: intermediate_rep.repo_digests.into_iter().next(),
            repo_tags: intermediate_rep.repo_tags.into_iter().next(),
            root_fs: intermediate_rep.root_fs.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
            virtual_size: intermediate_rep.virtual_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageInspect> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageInspect>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageInspect>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageInspect - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageInspect> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageInspect as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageInspect - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageLoadReport {
    #[serde(rename = "Names")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub names: Option<Vec<String>>,

}


impl ImageLoadReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageLoadReport {
        ImageLoadReport {
            names: None,
        }
    }
}

/// Converts the ImageLoadReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageLoadReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.names.as_ref().map(|names| {
                [
                    "Names".to_string(),
                    names.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageLoadReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageLoadReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub names: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageLoadReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Names" => return std::result::Result::Err("Parsing a container in this style is not supported in ImageLoadReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageLoadReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageLoadReport {
            names: intermediate_rep.names.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageLoadReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageLoadReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageLoadReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageLoadReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageLoadReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageLoadReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageLoadReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageSearch200Response {
/// Automated indicates if the image was created by an automated build.
    #[serde(rename = "Automated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub automated: Option<String>,

/// Description of the image.
    #[serde(rename = "Description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

/// Index is the image index
    #[serde(rename = "Index")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<String>,

/// Name is the canonical name of the image
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Official indicates if it's an official image.
    #[serde(rename = "Official")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub official: Option<String>,

/// Stars is the number of stars of the image.
    #[serde(rename = "Stars")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stars: Option<i64>,

/// Tag is the image tag
    #[serde(rename = "Tag")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag: Option<String>,

}


impl ImageSearch200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageSearch200Response {
        ImageSearch200Response {
            automated: None,
            description: None,
            index: None,
            name: None,
            official: None,
            stars: None,
            tag: None,
        }
    }
}

/// Converts the ImageSearch200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageSearch200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.automated.as_ref().map(|automated| {
                [
                    "Automated".to_string(),
                    automated.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "Description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.index.as_ref().map(|index| {
                [
                    "Index".to_string(),
                    index.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.official.as_ref().map(|official| {
                [
                    "Official".to_string(),
                    official.to_string(),
                ].join(",")
            }),


            self.stars.as_ref().map(|stars| {
                [
                    "Stars".to_string(),
                    stars.to_string(),
                ].join(",")
            }),


            self.tag.as_ref().map(|tag| {
                [
                    "Tag".to_string(),
                    tag.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageSearch200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageSearch200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub automated: Vec<String>,
            pub description: Vec<String>,
            pub index: Vec<String>,
            pub name: Vec<String>,
            pub official: Vec<String>,
            pub stars: Vec<i64>,
            pub tag: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageSearch200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Automated" => intermediate_rep.automated.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Index" => intermediate_rep.index.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Official" => intermediate_rep.official.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Stars" => intermediate_rep.stars.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tag" => intermediate_rep.tag.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageSearch200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageSearch200Response {
            automated: intermediate_rep.automated.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            index: intermediate_rep.index.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            official: intermediate_rep.official.into_iter().next(),
            stars: intermediate_rep.stars.into_iter().next(),
            tag: intermediate_rep.tag.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageSearch200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageSearch200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageSearch200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageSearch200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageSearch200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageSearch200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageSearch200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ImageStore describes the image store.  Right now only the number of images present



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageStore {
    #[serde(rename = "number")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,

}


impl ImageStore {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageStore {
        ImageStore {
            number: None,
        }
    }
}

/// Converts the ImageStore value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageStore {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.number.as_ref().map(|number| {
                [
                    "number".to_string(),
                    number.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageStore value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageStore {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub number: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageStore".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "number" => intermediate_rep.number.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageStore".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageStore {
            number: intermediate_rep.number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageStore> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageStore>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageStore>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageStore - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageStore> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageStore as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageStore - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageTreeReport {
    #[serde(rename = "Tree")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<String>,

}


impl ImageTreeReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageTreeReport {
        ImageTreeReport {
            tree: None,
        }
    }
}

/// Converts the ImageTreeReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageTreeReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.tree.as_ref().map(|tree| {
                [
                    "Tree".to_string(),
                    tree.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageTreeReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageTreeReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tree: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageTreeReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Tree" => intermediate_rep.tree.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageTreeReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageTreeReport {
            tree: intermediate_rep.tree.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageTreeReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageTreeReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageTreeReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageTreeReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageTreeReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageTreeReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageTreeReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ImageVolume is a volume based on a container image.  The container image is first mounted on the host and is then bind-mounted into the container.  An ImageVolume is always mounted read-only.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageVolume {
/// Destination is the absolute path of the mount in the container.
    #[serde(rename = "Destination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination: Option<String>,

/// ReadWrite sets the volume writable.
    #[serde(rename = "ReadWrite")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_write: Option<bool>,

/// Source is the source of the image volume.  The image can be referred to by name and by ID.
    #[serde(rename = "Source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,

/// SubPath mounts a particular path within the image. If empty, the whole image is mounted.
    #[serde(rename = "subPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_path: Option<String>,

}


impl ImageVolume {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ImageVolume {
        ImageVolume {
            destination: None,
            read_write: None,
            source: None,
            sub_path: None,
        }
    }
}

/// Converts the ImageVolume value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImageVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.destination.as_ref().map(|destination| {
                [
                    "Destination".to_string(),
                    destination.to_string(),
                ].join(",")
            }),


            self.read_write.as_ref().map(|read_write| {
                [
                    "ReadWrite".to_string(),
                    read_write.to_string(),
                ].join(",")
            }),


            self.source.as_ref().map(|source| {
                [
                    "Source".to_string(),
                    source.to_string(),
                ].join(",")
            }),


            self.sub_path.as_ref().map(|sub_path| {
                [
                    "subPath".to_string(),
                    sub_path.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageVolume value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageVolume {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub destination: Vec<String>,
            pub read_write: Vec<bool>,
            pub source: Vec<String>,
            pub sub_path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageVolume".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Destination" => intermediate_rep.destination.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ReadWrite" => intermediate_rep.read_write.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Source" => intermediate_rep.source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subPath" => intermediate_rep.sub_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageVolume".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageVolume {
            destination: intermediate_rep.destination.into_iter().next(),
            read_write: intermediate_rep.read_write.into_iter().next(),
            source: intermediate_rep.source.into_iter().next(),
            sub_path: intermediate_rep.sub_path.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageVolume> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageVolume>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageVolume>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageVolume - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImageVolume> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageVolume as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageVolume - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Info contains information about the Volume as a whole as provided by the CSI storage plugin.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Info {
/// AccessibleTopolgoy is the topology this volume is actually accessible from.
    #[serde(rename = "AccessibleTopology")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accessible_topology: Option<Vec<models::Topology>>,

/// CapacityBytes is the capacity of the volume in bytes. A value of 0 indicates that the capacity is unknown.
    #[serde(rename = "CapacityBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub capacity_bytes: Option<i64>,

/// VolumeContext is the context originating from the CSI storage plugin when the Volume is created.
    #[serde(rename = "VolumeContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_context: Option<std::collections::HashMap<String, String>>,

/// VolumeID is the ID of the Volume as seen by the CSI storage plugin. This is distinct from the Volume's Swarm ID, which is the ID used by all of the Docker Engine to refer to the Volume. If this field is blank, then the Volume has not been successfully created yet.
    #[serde(rename = "VolumeID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_id: Option<String>,

}


impl Info {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Info {
        Info {
            accessible_topology: None,
            capacity_bytes: None,
            volume_context: None,
            volume_id: None,
        }
    }
}

/// Converts the Info value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Info {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping AccessibleTopology in query parameter serialization


            self.capacity_bytes.as_ref().map(|capacity_bytes| {
                [
                    "CapacityBytes".to_string(),
                    capacity_bytes.to_string(),
                ].join(",")
            }),

            // Skipping VolumeContext in query parameter serialization


            self.volume_id.as_ref().map(|volume_id| {
                [
                    "VolumeID".to_string(),
                    volume_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Info value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Info {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub accessible_topology: Vec<Vec<models::Topology>>,
            pub capacity_bytes: Vec<i64>,
            pub volume_context: Vec<std::collections::HashMap<String, String>>,
            pub volume_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Info".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "AccessibleTopology" => return std::result::Result::Err("Parsing a container in this style is not supported in Info".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "CapacityBytes" => intermediate_rep.capacity_bytes.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "VolumeContext" => return std::result::Result::Err("Parsing a container in this style is not supported in Info".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "VolumeID" => intermediate_rep.volume_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Info".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Info {
            accessible_topology: intermediate_rep.accessible_topology.into_iter().next(),
            capacity_bytes: intermediate_rep.capacity_bytes.into_iter().next(),
            volume_context: intermediate_rep.volume_context.into_iter().next(),
            volume_id: intermediate_rep.volume_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Info> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Info>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Info>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Info - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Info> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Info as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Info - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectAdditionalNetwork holds information about non-default networks the container has been connected to. As with InspectNetworkSettings, many fields are unused and maintained only for compatibility with Docker.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectAdditionalNetwork {
/// AdditionalMacAddresses is a set of additional MAC Addresses beyond the first. CNI may configure more than one interface for a single network, which can cause this.
    #[serde(rename = "AdditionalMACAddresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_mac_addresses: Option<Vec<String>>,

/// Aliases are any network aliases the container has in this network.
    #[serde(rename = "Aliases")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aliases: Option<Vec<String>>,

/// DriverOpts is presently unused and maintained exclusively for compatibility.
    #[serde(rename = "DriverOpts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver_opts: Option<std::collections::HashMap<String, String>>,

/// EndpointID is unused, maintained exclusively for compatibility.
    #[serde(rename = "EndpointID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_id: Option<String>,

/// Gateway is the IP address of the gateway this network will use.
    #[serde(rename = "Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

/// GlobalIPv6Address is the global-scope IPv6 Address for this network.
    #[serde(rename = "GlobalIPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_address: Option<String>,

/// GlobalIPv6PrefixLen is the length of the subnet mask of this network.
    #[serde(rename = "GlobalIPv6PrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_prefix_len: Option<i64>,

/// IPAMConfig is presently unused and maintained exclusively for compatibility.
    #[serde(rename = "IPAMConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipam_config: Option<std::collections::HashMap<String, String>>,

/// IPAddress is the IP address for this network.
    #[serde(rename = "IPAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_address: Option<String>,

/// IPPrefixLen is the length of the subnet mask of this network.
    #[serde(rename = "IPPrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_prefix_len: Option<i64>,

/// IPv6Gateway is the IPv6 gateway this network will use.
    #[serde(rename = "IPv6Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_gateway: Option<String>,

/// Links is presently unused and maintained exclusively for compatibility.
    #[serde(rename = "Links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub links: Option<Vec<String>>,

/// MacAddress is the MAC address for the interface in this network.
    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

/// Name of the network we're connecting to.
    #[serde(rename = "NetworkID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_id: Option<String>,

/// SecondaryIPAddresses is a list of extra IP Addresses that the container has been assigned in this network.
    #[serde(rename = "SecondaryIPAddresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secondary_ip_addresses: Option<Vec<models::Address>>,

/// SecondaryIPv6Addresses is a list of extra IPv6 Addresses that the container has been assigned in this network.
    #[serde(rename = "SecondaryIPv6Addresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secondary_ipv6_addresses: Option<Vec<models::Address>>,

}


impl InspectAdditionalNetwork {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectAdditionalNetwork {
        InspectAdditionalNetwork {
            additional_mac_addresses: None,
            aliases: None,
            driver_opts: None,
            endpoint_id: None,
            gateway: None,
            global_ipv6_address: None,
            global_ipv6_prefix_len: None,
            ipam_config: None,
            ip_address: None,
            ip_prefix_len: None,
            ipv6_gateway: None,
            links: None,
            mac_address: None,
            network_id: None,
            secondary_ip_addresses: None,
            secondary_ipv6_addresses: None,
        }
    }
}

/// Converts the InspectAdditionalNetwork value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectAdditionalNetwork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.additional_mac_addresses.as_ref().map(|additional_mac_addresses| {
                [
                    "AdditionalMACAddresses".to_string(),
                    additional_mac_addresses.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.aliases.as_ref().map(|aliases| {
                [
                    "Aliases".to_string(),
                    aliases.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping DriverOpts in query parameter serialization


            self.endpoint_id.as_ref().map(|endpoint_id| {
                [
                    "EndpointID".to_string(),
                    endpoint_id.to_string(),
                ].join(",")
            }),


            self.gateway.as_ref().map(|gateway| {
                [
                    "Gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),


            self.global_ipv6_address.as_ref().map(|global_ipv6_address| {
                [
                    "GlobalIPv6Address".to_string(),
                    global_ipv6_address.to_string(),
                ].join(",")
            }),


            self.global_ipv6_prefix_len.as_ref().map(|global_ipv6_prefix_len| {
                [
                    "GlobalIPv6PrefixLen".to_string(),
                    global_ipv6_prefix_len.to_string(),
                ].join(",")
            }),

            // Skipping IPAMConfig in query parameter serialization


            self.ip_address.as_ref().map(|ip_address| {
                [
                    "IPAddress".to_string(),
                    ip_address.to_string(),
                ].join(",")
            }),


            self.ip_prefix_len.as_ref().map(|ip_prefix_len| {
                [
                    "IPPrefixLen".to_string(),
                    ip_prefix_len.to_string(),
                ].join(",")
            }),


            self.ipv6_gateway.as_ref().map(|ipv6_gateway| {
                [
                    "IPv6Gateway".to_string(),
                    ipv6_gateway.to_string(),
                ].join(",")
            }),


            self.links.as_ref().map(|links| {
                [
                    "Links".to_string(),
                    links.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),


            self.network_id.as_ref().map(|network_id| {
                [
                    "NetworkID".to_string(),
                    network_id.to_string(),
                ].join(",")
            }),

            // Skipping SecondaryIPAddresses in query parameter serialization

            // Skipping SecondaryIPv6Addresses in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectAdditionalNetwork value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectAdditionalNetwork {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub additional_mac_addresses: Vec<Vec<String>>,
            pub aliases: Vec<Vec<String>>,
            pub driver_opts: Vec<std::collections::HashMap<String, String>>,
            pub endpoint_id: Vec<String>,
            pub gateway: Vec<String>,
            pub global_ipv6_address: Vec<String>,
            pub global_ipv6_prefix_len: Vec<i64>,
            pub ipam_config: Vec<std::collections::HashMap<String, String>>,
            pub ip_address: Vec<String>,
            pub ip_prefix_len: Vec<i64>,
            pub ipv6_gateway: Vec<String>,
            pub links: Vec<Vec<String>>,
            pub mac_address: Vec<String>,
            pub network_id: Vec<String>,
            pub secondary_ip_addresses: Vec<Vec<models::Address>>,
            pub secondary_ipv6_addresses: Vec<Vec<models::Address>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectAdditionalNetwork".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "AdditionalMACAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectAdditionalNetwork".to_string()),
                    "Aliases" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectAdditionalNetwork".to_string()),
                    "DriverOpts" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectAdditionalNetwork".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "EndpointID" => intermediate_rep.endpoint_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6Address" => intermediate_rep.global_ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6PrefixLen" => intermediate_rep.global_ipv6_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "IPAMConfig" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectAdditionalNetwork".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "IPAddress" => intermediate_rep.ip_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPPrefixLen" => intermediate_rep.ip_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv6Gateway" => intermediate_rep.ipv6_gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Links" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectAdditionalNetwork".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkID" => intermediate_rep.network_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "SecondaryIPAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectAdditionalNetwork".to_string()),
                    "SecondaryIPv6Addresses" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectAdditionalNetwork".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectAdditionalNetwork".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectAdditionalNetwork {
            additional_mac_addresses: intermediate_rep.additional_mac_addresses.into_iter().next(),
            aliases: intermediate_rep.aliases.into_iter().next(),
            driver_opts: intermediate_rep.driver_opts.into_iter().next(),
            endpoint_id: intermediate_rep.endpoint_id.into_iter().next(),
            gateway: intermediate_rep.gateway.into_iter().next(),
            global_ipv6_address: intermediate_rep.global_ipv6_address.into_iter().next(),
            global_ipv6_prefix_len: intermediate_rep.global_ipv6_prefix_len.into_iter().next(),
            ipam_config: intermediate_rep.ipam_config.into_iter().next(),
            ip_address: intermediate_rep.ip_address.into_iter().next(),
            ip_prefix_len: intermediate_rep.ip_prefix_len.into_iter().next(),
            ipv6_gateway: intermediate_rep.ipv6_gateway.into_iter().next(),
            links: intermediate_rep.links.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            network_id: intermediate_rep.network_id.into_iter().next(),
            secondary_ip_addresses: intermediate_rep.secondary_ip_addresses.into_iter().next(),
            secondary_ipv6_addresses: intermediate_rep.secondary_ipv6_addresses.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectAdditionalNetwork> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectAdditionalNetwork>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectAdditionalNetwork>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectAdditionalNetwork - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectAdditionalNetwork> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectAdditionalNetwork as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectAdditionalNetwork - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectBlkioThrottleDevice holds information about a speed cap for a device node. This cap applies to a specific operation (read, write, etc) on the given node.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectBlkioThrottleDevice {
/// Path is the path to the device this applies to.
    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// Rate is the maximum rate. It is in either bytes per second or iops per second, determined by where it is used - documentation will indicate which is appropriate.
    #[serde(rename = "Rate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate: Option<i32>,

}


impl InspectBlkioThrottleDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectBlkioThrottleDevice {
        InspectBlkioThrottleDevice {
            path: None,
            rate: None,
        }
    }
}

/// Converts the InspectBlkioThrottleDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectBlkioThrottleDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.rate.as_ref().map(|rate| {
                [
                    "Rate".to_string(),
                    rate.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectBlkioThrottleDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectBlkioThrottleDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub rate: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectBlkioThrottleDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Rate" => intermediate_rep.rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectBlkioThrottleDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectBlkioThrottleDevice {
            path: intermediate_rep.path.into_iter().next(),
            rate: intermediate_rep.rate.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectBlkioThrottleDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectBlkioThrottleDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectBlkioThrottleDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectBlkioThrottleDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectBlkioThrottleDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectBlkioThrottleDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectBlkioThrottleDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectBlkioWeightDevice holds information about the relative weight of an individual device node. Weights are used in the I/O scheduler to give relative priority to some accesses.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectBlkioWeightDevice {
/// Path is the path to the device this applies to.
    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// Weight is the relative weight the scheduler will use when scheduling I/O.
    #[serde(rename = "Weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<i32>,

}


impl InspectBlkioWeightDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectBlkioWeightDevice {
        InspectBlkioWeightDevice {
            path: None,
            weight: None,
        }
    }
}

/// Converts the InspectBlkioWeightDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectBlkioWeightDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.weight.as_ref().map(|weight| {
                [
                    "Weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectBlkioWeightDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectBlkioWeightDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub weight: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectBlkioWeightDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Weight" => intermediate_rep.weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectBlkioWeightDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectBlkioWeightDevice {
            path: intermediate_rep.path.into_iter().next(),
            weight: intermediate_rep.weight.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectBlkioWeightDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectBlkioWeightDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectBlkioWeightDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectBlkioWeightDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectBlkioWeightDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectBlkioWeightDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectBlkioWeightDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectContainerConfig holds further data about how a container was initially configured.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectContainerConfig {
/// Container annotations
    #[serde(rename = "Annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// Unused, at present
    #[serde(rename = "AttachStderr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stderr: Option<bool>,

/// Unused, at present
    #[serde(rename = "AttachStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdin: Option<bool>,

/// Unused, at present
    #[serde(rename = "AttachStdout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attach_stdout: Option<bool>,

/// ChrootDirs is an additional set of directories that need to be treated as root directories. Standard bind mounts will be mounted into paths relative to these directories.
    #[serde(rename = "ChrootDirs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chroot_dirs: Option<Vec<String>>,

/// Container command
    #[serde(rename = "Cmd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cmd: Option<Vec<String>>,

/// CreateCommand is the full command plus arguments of the process the container has been created with.
    #[serde(rename = "CreateCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_command: Option<Vec<String>>,

/// Container domain name - unused at present
    #[serde(rename = "Domainname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub domainname: Option<String>,

/// Container entrypoint
    #[serde(rename = "Entrypoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrypoint: Option<Vec<String>>,

/// Container environment variables
    #[serde(rename = "Env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<Vec<String>>,

    #[serde(rename = "Healthcheck")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healthcheck: Option<models::Schema2HealthConfig>,

/// HealthcheckOnFailureAction defines an action to take once the container turns unhealthy.
    #[serde(rename = "HealthcheckOnFailureAction")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healthcheck_on_failure_action: Option<String>,

/// Container hostname
    #[serde(rename = "Hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

/// Container image
    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

/// Container labels
    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// On-build arguments - presently unused. More of Buildah's domain.
    #[serde(rename = "OnBuild")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_build: Option<String>,

/// Whether the container leaves STDIN open
    #[serde(rename = "OpenStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_stdin: Option<bool>,

/// Passwd determines whether or not podman can add entries to /etc/passwd and /etc/group
    #[serde(rename = "Passwd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub passwd: Option<bool>,

/// Secrets are the secrets mounted in the container
    #[serde(rename = "Secrets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<models::InspectSecret>>,

/// Whether STDIN is only left open once. Presently not supported by Podman, unused.
    #[serde(rename = "StdinOnce")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin_once: Option<bool>,

/// Container stop signal
    #[serde(rename = "StopSignal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_signal: Option<String>,

/// StopTimeout is time before container is stopped when calling stop
    #[serde(rename = "StopTimeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_timeout: Option<i32>,

/// SystemdMode is whether the container is running in systemd mode. In systemd mode, the container configuration is customized to optimize running systemd in the container.
    #[serde(rename = "SystemdMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub systemd_mode: Option<bool>,

/// Timeout is time before container is killed by conmon
    #[serde(rename = "Timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i32>,

/// Timezone is the timezone inside the container. Local means it has the same timezone as the host machine
    #[serde(rename = "Timezone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timezone: Option<String>,

/// Whether the container creates a TTY
    #[serde(rename = "Tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

/// Umask is the umask inside the container.
    #[serde(rename = "Umask")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub umask: Option<String>,

/// User the container was launched with
    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

/// Unused, at present. I've never seen this field populated.
    #[serde(rename = "Volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<std::collections::HashMap<String, crate::types::Object>>,

/// Container working directory
    #[serde(rename = "WorkingDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_dir: Option<String>,

/// SdNotifyMode is the sd-notify mode of the container.
    #[serde(rename = "sdNotifyMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sd_notify_mode: Option<String>,

/// SdNotifySocket is the NOTIFY_SOCKET in use by/configured for the container.
    #[serde(rename = "sdNotifySocket")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sd_notify_socket: Option<String>,

}


impl InspectContainerConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectContainerConfig {
        InspectContainerConfig {
            annotations: None,
            attach_stderr: None,
            attach_stdin: None,
            attach_stdout: None,
            chroot_dirs: None,
            cmd: None,
            create_command: None,
            domainname: None,
            entrypoint: None,
            env: None,
            healthcheck: None,
            healthcheck_on_failure_action: None,
            hostname: None,
            image: None,
            labels: None,
            on_build: None,
            open_stdin: None,
            passwd: None,
            secrets: None,
            stdin_once: None,
            stop_signal: None,
            stop_timeout: None,
            systemd_mode: None,
            timeout: None,
            timezone: None,
            tty: None,
            umask: None,
            user: None,
            volumes: None,
            working_dir: None,
            sd_notify_mode: None,
            sd_notify_socket: None,
        }
    }
}

/// Converts the InspectContainerConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectContainerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Annotations in query parameter serialization


            self.attach_stderr.as_ref().map(|attach_stderr| {
                [
                    "AttachStderr".to_string(),
                    attach_stderr.to_string(),
                ].join(",")
            }),


            self.attach_stdin.as_ref().map(|attach_stdin| {
                [
                    "AttachStdin".to_string(),
                    attach_stdin.to_string(),
                ].join(",")
            }),


            self.attach_stdout.as_ref().map(|attach_stdout| {
                [
                    "AttachStdout".to_string(),
                    attach_stdout.to_string(),
                ].join(",")
            }),


            self.chroot_dirs.as_ref().map(|chroot_dirs| {
                [
                    "ChrootDirs".to_string(),
                    chroot_dirs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cmd.as_ref().map(|cmd| {
                [
                    "Cmd".to_string(),
                    cmd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.create_command.as_ref().map(|create_command| {
                [
                    "CreateCommand".to_string(),
                    create_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.domainname.as_ref().map(|domainname| {
                [
                    "Domainname".to_string(),
                    domainname.to_string(),
                ].join(",")
            }),


            self.entrypoint.as_ref().map(|entrypoint| {
                [
                    "Entrypoint".to_string(),
                    entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.env.as_ref().map(|env| {
                [
                    "Env".to_string(),
                    env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping Healthcheck in query parameter serialization


            self.healthcheck_on_failure_action.as_ref().map(|healthcheck_on_failure_action| {
                [
                    "HealthcheckOnFailureAction".to_string(),
                    healthcheck_on_failure_action.to_string(),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "Hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.on_build.as_ref().map(|on_build| {
                [
                    "OnBuild".to_string(),
                    on_build.to_string(),
                ].join(",")
            }),


            self.open_stdin.as_ref().map(|open_stdin| {
                [
                    "OpenStdin".to_string(),
                    open_stdin.to_string(),
                ].join(",")
            }),


            self.passwd.as_ref().map(|passwd| {
                [
                    "Passwd".to_string(),
                    passwd.to_string(),
                ].join(",")
            }),

            // Skipping Secrets in query parameter serialization


            self.stdin_once.as_ref().map(|stdin_once| {
                [
                    "StdinOnce".to_string(),
                    stdin_once.to_string(),
                ].join(",")
            }),


            self.stop_signal.as_ref().map(|stop_signal| {
                [
                    "StopSignal".to_string(),
                    stop_signal.to_string(),
                ].join(",")
            }),


            self.stop_timeout.as_ref().map(|stop_timeout| {
                [
                    "StopTimeout".to_string(),
                    stop_timeout.to_string(),
                ].join(",")
            }),


            self.systemd_mode.as_ref().map(|systemd_mode| {
                [
                    "SystemdMode".to_string(),
                    systemd_mode.to_string(),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "Timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),


            self.timezone.as_ref().map(|timezone| {
                [
                    "Timezone".to_string(),
                    timezone.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "Tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),


            self.umask.as_ref().map(|umask| {
                [
                    "Umask".to_string(),
                    umask.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "User".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping Volumes in query parameter serialization
            // Skipping Volumes in query parameter serialization


            self.working_dir.as_ref().map(|working_dir| {
                [
                    "WorkingDir".to_string(),
                    working_dir.to_string(),
                ].join(",")
            }),


            self.sd_notify_mode.as_ref().map(|sd_notify_mode| {
                [
                    "sdNotifyMode".to_string(),
                    sd_notify_mode.to_string(),
                ].join(",")
            }),


            self.sd_notify_socket.as_ref().map(|sd_notify_socket| {
                [
                    "sdNotifySocket".to_string(),
                    sd_notify_socket.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectContainerConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectContainerConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub attach_stderr: Vec<bool>,
            pub attach_stdin: Vec<bool>,
            pub attach_stdout: Vec<bool>,
            pub chroot_dirs: Vec<Vec<String>>,
            pub cmd: Vec<Vec<String>>,
            pub create_command: Vec<Vec<String>>,
            pub domainname: Vec<String>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<Vec<String>>,
            pub healthcheck: Vec<models::Schema2HealthConfig>,
            pub healthcheck_on_failure_action: Vec<String>,
            pub hostname: Vec<String>,
            pub image: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub on_build: Vec<String>,
            pub open_stdin: Vec<bool>,
            pub passwd: Vec<bool>,
            pub secrets: Vec<Vec<models::InspectSecret>>,
            pub stdin_once: Vec<bool>,
            pub stop_signal: Vec<String>,
            pub stop_timeout: Vec<i32>,
            pub systemd_mode: Vec<bool>,
            pub timeout: Vec<i32>,
            pub timezone: Vec<String>,
            pub tty: Vec<bool>,
            pub umask: Vec<String>,
            pub user: Vec<String>,
            pub volumes: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub working_dir: Vec<String>,
            pub sd_notify_mode: Vec<String>,
            pub sd_notify_socket: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectContainerConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "AttachStderr" => intermediate_rep.attach_stderr.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdin" => intermediate_rep.attach_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "AttachStdout" => intermediate_rep.attach_stdout.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ChrootDirs" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    "Cmd" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    "CreateCommand" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Domainname" => intermediate_rep.domainname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Healthcheck" => intermediate_rep.healthcheck.push(<models::Schema2HealthConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HealthcheckOnFailureAction" => intermediate_rep.healthcheck_on_failure_action.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "OnBuild" => intermediate_rep.on_build.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OpenStdin" => intermediate_rep.open_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Passwd" => intermediate_rep.passwd.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Secrets" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "StdinOnce" => intermediate_rep.stdin_once.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StopSignal" => intermediate_rep.stop_signal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StopTimeout" => intermediate_rep.stop_timeout.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SystemdMode" => intermediate_rep.systemd_mode.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Timeout" => intermediate_rep.timeout.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Timezone" => intermediate_rep.timezone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Umask" => intermediate_rep.umask.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "WorkingDir" => intermediate_rep.working_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sdNotifyMode" => intermediate_rep.sd_notify_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sdNotifySocket" => intermediate_rep.sd_notify_socket.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectContainerConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectContainerConfig {
            annotations: intermediate_rep.annotations.into_iter().next(),
            attach_stderr: intermediate_rep.attach_stderr.into_iter().next(),
            attach_stdin: intermediate_rep.attach_stdin.into_iter().next(),
            attach_stdout: intermediate_rep.attach_stdout.into_iter().next(),
            chroot_dirs: intermediate_rep.chroot_dirs.into_iter().next(),
            cmd: intermediate_rep.cmd.into_iter().next(),
            create_command: intermediate_rep.create_command.into_iter().next(),
            domainname: intermediate_rep.domainname.into_iter().next(),
            entrypoint: intermediate_rep.entrypoint.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            healthcheck: intermediate_rep.healthcheck.into_iter().next(),
            healthcheck_on_failure_action: intermediate_rep.healthcheck_on_failure_action.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            on_build: intermediate_rep.on_build.into_iter().next(),
            open_stdin: intermediate_rep.open_stdin.into_iter().next(),
            passwd: intermediate_rep.passwd.into_iter().next(),
            secrets: intermediate_rep.secrets.into_iter().next(),
            stdin_once: intermediate_rep.stdin_once.into_iter().next(),
            stop_signal: intermediate_rep.stop_signal.into_iter().next(),
            stop_timeout: intermediate_rep.stop_timeout.into_iter().next(),
            systemd_mode: intermediate_rep.systemd_mode.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
            timezone: intermediate_rep.timezone.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            umask: intermediate_rep.umask.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            working_dir: intermediate_rep.working_dir.into_iter().next(),
            sd_notify_mode: intermediate_rep.sd_notify_mode.into_iter().next(),
            sd_notify_socket: intermediate_rep.sd_notify_socket.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectContainerConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectContainerConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectContainerConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectContainerConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectContainerConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectContainerConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectContainerConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectContainerData provides a detailed record of a container's configuration and state as viewed by Libpod. Large portions of this structure are defined such that the output is compatible with `docker inspect` JSON, but additional fields have been added as required to share information not in the original output.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectContainerData {
    #[serde(rename = "AppArmorProfile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_armor_profile: Option<String>,

    #[serde(rename = "Args")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub args: Option<Vec<String>>,

    #[serde(rename = "BoundingCaps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bounding_caps: Option<Vec<String>>,

    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<models::InspectContainerConfig>,

    #[serde(rename = "ConmonPidFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conmon_pid_file: Option<String>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Dependencies")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependencies: Option<Vec<String>>,

    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

    #[serde(rename = "EffectiveCaps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_caps: Option<Vec<String>>,

    #[serde(rename = "ExecIDs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exec_ids: Option<Vec<String>>,

    #[serde(rename = "GraphDriver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_driver: Option<models::DriverData>,

    #[serde(rename = "HostConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_config: Option<models::InspectContainerHostConfig>,

    #[serde(rename = "HostnamePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname_path: Option<String>,

    #[serde(rename = "HostsPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hosts_path: Option<String>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

    #[serde(rename = "ImageDigest")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_digest: Option<String>,

    #[serde(rename = "ImageName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_name: Option<String>,

    #[serde(rename = "IsInfra")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_infra: Option<bool>,

    #[serde(rename = "IsService")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_service: Option<bool>,

    #[serde(rename = "KubeExitCodePropagation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kube_exit_code_propagation: Option<String>,

    #[serde(rename = "MountLabel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mount_label: Option<String>,

    #[serde(rename = "Mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::InspectMount>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Namespace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,

    #[serde(rename = "NetworkSettings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_settings: Option<models::InspectNetworkSettings>,

    #[serde(rename = "OCIConfigPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oci_config_path: Option<String>,

    #[serde(rename = "OCIRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oci_runtime: Option<String>,

    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "PidFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid_file: Option<String>,

    #[serde(rename = "Pod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod: Option<String>,

    #[serde(rename = "ProcessLabel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub process_label: Option<String>,

    #[serde(rename = "ResolvConfPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolv_conf_path: Option<String>,

    #[serde(rename = "RestartCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_count: Option<i32>,

    #[serde(rename = "Rootfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs: Option<String>,

    #[serde(rename = "SizeRootFs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_root_fs: Option<i64>,

    #[serde(rename = "SizeRw")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_rw: Option<i64>,

    #[serde(rename = "State")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<models::InspectContainerState>,

    #[serde(rename = "StaticDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub static_dir: Option<String>,

    #[serde(rename = "lockNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_number: Option<i32>,

}


impl InspectContainerData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectContainerData {
        InspectContainerData {
            app_armor_profile: None,
            args: None,
            bounding_caps: None,
            config: None,
            conmon_pid_file: None,
            created: None,
            dependencies: None,
            driver: None,
            effective_caps: None,
            exec_ids: None,
            graph_driver: None,
            host_config: None,
            hostname_path: None,
            hosts_path: None,
            id: None,
            image: None,
            image_digest: None,
            image_name: None,
            is_infra: None,
            is_service: None,
            kube_exit_code_propagation: None,
            mount_label: None,
            mounts: None,
            name: None,
            namespace: None,
            network_settings: None,
            oci_config_path: None,
            oci_runtime: None,
            path: None,
            pid_file: None,
            pod: None,
            process_label: None,
            resolv_conf_path: None,
            restart_count: None,
            rootfs: None,
            size_root_fs: None,
            size_rw: None,
            state: None,
            static_dir: None,
            lock_number: None,
        }
    }
}

/// Converts the InspectContainerData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectContainerData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.app_armor_profile.as_ref().map(|app_armor_profile| {
                [
                    "AppArmorProfile".to_string(),
                    app_armor_profile.to_string(),
                ].join(",")
            }),


            self.args.as_ref().map(|args| {
                [
                    "Args".to_string(),
                    args.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.bounding_caps.as_ref().map(|bounding_caps| {
                [
                    "BoundingCaps".to_string(),
                    bounding_caps.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping Config in query parameter serialization


            self.conmon_pid_file.as_ref().map(|conmon_pid_file| {
                [
                    "ConmonPidFile".to_string(),
                    conmon_pid_file.to_string(),
                ].join(",")
            }),

            // Skipping Created in query parameter serialization


            self.dependencies.as_ref().map(|dependencies| {
                [
                    "Dependencies".to_string(),
                    dependencies.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.effective_caps.as_ref().map(|effective_caps| {
                [
                    "EffectiveCaps".to_string(),
                    effective_caps.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.exec_ids.as_ref().map(|exec_ids| {
                [
                    "ExecIDs".to_string(),
                    exec_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping GraphDriver in query parameter serialization

            // Skipping HostConfig in query parameter serialization


            self.hostname_path.as_ref().map(|hostname_path| {
                [
                    "HostnamePath".to_string(),
                    hostname_path.to_string(),
                ].join(",")
            }),


            self.hosts_path.as_ref().map(|hosts_path| {
                [
                    "HostsPath".to_string(),
                    hosts_path.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.image_digest.as_ref().map(|image_digest| {
                [
                    "ImageDigest".to_string(),
                    image_digest.to_string(),
                ].join(",")
            }),


            self.image_name.as_ref().map(|image_name| {
                [
                    "ImageName".to_string(),
                    image_name.to_string(),
                ].join(",")
            }),


            self.is_infra.as_ref().map(|is_infra| {
                [
                    "IsInfra".to_string(),
                    is_infra.to_string(),
                ].join(",")
            }),


            self.is_service.as_ref().map(|is_service| {
                [
                    "IsService".to_string(),
                    is_service.to_string(),
                ].join(",")
            }),


            self.kube_exit_code_propagation.as_ref().map(|kube_exit_code_propagation| {
                [
                    "KubeExitCodePropagation".to_string(),
                    kube_exit_code_propagation.to_string(),
                ].join(",")
            }),


            self.mount_label.as_ref().map(|mount_label| {
                [
                    "MountLabel".to_string(),
                    mount_label.to_string(),
                ].join(",")
            }),

            // Skipping Mounts in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.namespace.as_ref().map(|namespace| {
                [
                    "Namespace".to_string(),
                    namespace.to_string(),
                ].join(",")
            }),

            // Skipping NetworkSettings in query parameter serialization


            self.oci_config_path.as_ref().map(|oci_config_path| {
                [
                    "OCIConfigPath".to_string(),
                    oci_config_path.to_string(),
                ].join(",")
            }),


            self.oci_runtime.as_ref().map(|oci_runtime| {
                [
                    "OCIRuntime".to_string(),
                    oci_runtime.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.pid_file.as_ref().map(|pid_file| {
                [
                    "PidFile".to_string(),
                    pid_file.to_string(),
                ].join(",")
            }),


            self.pod.as_ref().map(|pod| {
                [
                    "Pod".to_string(),
                    pod.to_string(),
                ].join(",")
            }),


            self.process_label.as_ref().map(|process_label| {
                [
                    "ProcessLabel".to_string(),
                    process_label.to_string(),
                ].join(",")
            }),


            self.resolv_conf_path.as_ref().map(|resolv_conf_path| {
                [
                    "ResolvConfPath".to_string(),
                    resolv_conf_path.to_string(),
                ].join(",")
            }),


            self.restart_count.as_ref().map(|restart_count| {
                [
                    "RestartCount".to_string(),
                    restart_count.to_string(),
                ].join(",")
            }),


            self.rootfs.as_ref().map(|rootfs| {
                [
                    "Rootfs".to_string(),
                    rootfs.to_string(),
                ].join(",")
            }),


            self.size_root_fs.as_ref().map(|size_root_fs| {
                [
                    "SizeRootFs".to_string(),
                    size_root_fs.to_string(),
                ].join(",")
            }),


            self.size_rw.as_ref().map(|size_rw| {
                [
                    "SizeRw".to_string(),
                    size_rw.to_string(),
                ].join(",")
            }),

            // Skipping State in query parameter serialization


            self.static_dir.as_ref().map(|static_dir| {
                [
                    "StaticDir".to_string(),
                    static_dir.to_string(),
                ].join(",")
            }),


            self.lock_number.as_ref().map(|lock_number| {
                [
                    "lockNumber".to_string(),
                    lock_number.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectContainerData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectContainerData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub app_armor_profile: Vec<String>,
            pub args: Vec<Vec<String>>,
            pub bounding_caps: Vec<Vec<String>>,
            pub config: Vec<models::InspectContainerConfig>,
            pub conmon_pid_file: Vec<String>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub dependencies: Vec<Vec<String>>,
            pub driver: Vec<String>,
            pub effective_caps: Vec<Vec<String>>,
            pub exec_ids: Vec<Vec<String>>,
            pub graph_driver: Vec<models::DriverData>,
            pub host_config: Vec<models::InspectContainerHostConfig>,
            pub hostname_path: Vec<String>,
            pub hosts_path: Vec<String>,
            pub id: Vec<String>,
            pub image: Vec<String>,
            pub image_digest: Vec<String>,
            pub image_name: Vec<String>,
            pub is_infra: Vec<bool>,
            pub is_service: Vec<bool>,
            pub kube_exit_code_propagation: Vec<String>,
            pub mount_label: Vec<String>,
            pub mounts: Vec<Vec<models::InspectMount>>,
            pub name: Vec<String>,
            pub namespace: Vec<String>,
            pub network_settings: Vec<models::InspectNetworkSettings>,
            pub oci_config_path: Vec<String>,
            pub oci_runtime: Vec<String>,
            pub path: Vec<String>,
            pub pid_file: Vec<String>,
            pub pod: Vec<String>,
            pub process_label: Vec<String>,
            pub resolv_conf_path: Vec<String>,
            pub restart_count: Vec<i32>,
            pub rootfs: Vec<String>,
            pub size_root_fs: Vec<i64>,
            pub size_rw: Vec<i64>,
            pub state: Vec<models::InspectContainerState>,
            pub static_dir: Vec<String>,
            pub lock_number: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectContainerData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AppArmorProfile" => intermediate_rep.app_armor_profile.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Args" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerData".to_string()),
                    "BoundingCaps" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Config" => intermediate_rep.config.push(<models::InspectContainerConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ConmonPidFile" => intermediate_rep.conmon_pid_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Dependencies" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "EffectiveCaps" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerData".to_string()),
                    "ExecIDs" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "GraphDriver" => intermediate_rep.graph_driver.push(<models::DriverData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostConfig" => intermediate_rep.host_config.push(<models::InspectContainerHostConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostnamePath" => intermediate_rep.hostname_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostsPath" => intermediate_rep.hosts_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ImageDigest" => intermediate_rep.image_digest.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ImageName" => intermediate_rep.image_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IsInfra" => intermediate_rep.is_infra.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IsService" => intermediate_rep.is_service.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KubeExitCodePropagation" => intermediate_rep.kube_exit_code_propagation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MountLabel" => intermediate_rep.mount_label.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Namespace" => intermediate_rep.namespace.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkSettings" => intermediate_rep.network_settings.push(<models::InspectNetworkSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OCIConfigPath" => intermediate_rep.oci_config_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OCIRuntime" => intermediate_rep.oci_runtime.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidFile" => intermediate_rep.pid_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Pod" => intermediate_rep.pod.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ProcessLabel" => intermediate_rep.process_label.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ResolvConfPath" => intermediate_rep.resolv_conf_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestartCount" => intermediate_rep.restart_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Rootfs" => intermediate_rep.rootfs.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SizeRootFs" => intermediate_rep.size_root_fs.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SizeRw" => intermediate_rep.size_rw.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "State" => intermediate_rep.state.push(<models::InspectContainerState as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StaticDir" => intermediate_rep.static_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lockNumber" => intermediate_rep.lock_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectContainerData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectContainerData {
            app_armor_profile: intermediate_rep.app_armor_profile.into_iter().next(),
            args: intermediate_rep.args.into_iter().next(),
            bounding_caps: intermediate_rep.bounding_caps.into_iter().next(),
            config: intermediate_rep.config.into_iter().next(),
            conmon_pid_file: intermediate_rep.conmon_pid_file.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            dependencies: intermediate_rep.dependencies.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            effective_caps: intermediate_rep.effective_caps.into_iter().next(),
            exec_ids: intermediate_rep.exec_ids.into_iter().next(),
            graph_driver: intermediate_rep.graph_driver.into_iter().next(),
            host_config: intermediate_rep.host_config.into_iter().next(),
            hostname_path: intermediate_rep.hostname_path.into_iter().next(),
            hosts_path: intermediate_rep.hosts_path.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            image_digest: intermediate_rep.image_digest.into_iter().next(),
            image_name: intermediate_rep.image_name.into_iter().next(),
            is_infra: intermediate_rep.is_infra.into_iter().next(),
            is_service: intermediate_rep.is_service.into_iter().next(),
            kube_exit_code_propagation: intermediate_rep.kube_exit_code_propagation.into_iter().next(),
            mount_label: intermediate_rep.mount_label.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            namespace: intermediate_rep.namespace.into_iter().next(),
            network_settings: intermediate_rep.network_settings.into_iter().next(),
            oci_config_path: intermediate_rep.oci_config_path.into_iter().next(),
            oci_runtime: intermediate_rep.oci_runtime.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            pid_file: intermediate_rep.pid_file.into_iter().next(),
            pod: intermediate_rep.pod.into_iter().next(),
            process_label: intermediate_rep.process_label.into_iter().next(),
            resolv_conf_path: intermediate_rep.resolv_conf_path.into_iter().next(),
            restart_count: intermediate_rep.restart_count.into_iter().next(),
            rootfs: intermediate_rep.rootfs.into_iter().next(),
            size_root_fs: intermediate_rep.size_root_fs.into_iter().next(),
            size_rw: intermediate_rep.size_rw.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
            static_dir: intermediate_rep.static_dir.into_iter().next(),
            lock_number: intermediate_rep.lock_number.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectContainerData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectContainerData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectContainerData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectContainerData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectContainerData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectContainerData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectContainerData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// nolint:revive,stylecheck // Field names are fixed for compatibility and cannot be changed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectContainerHostConfig {
/// Annotations are provided to the runtime when the container is started.
    #[serde(rename = "Annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// AutoRemove is whether the container will be automatically removed on exiting. It is not handled directly within libpod and is stored in an annotation.
    #[serde(rename = "AutoRemove")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_remove: Option<bool>,

/// Binds contains an array of user-added mounts. Both volume mounts and named volumes are included. Tmpfs mounts are NOT included. In 'docker inspect' this is separated into 'Binds' and 'Mounts' based on how a mount was added. We do not make this distinction and do not include a Mounts field in inspect. Format: <src>:<destination>[:<comma-separated options>]
    #[serde(rename = "Binds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub binds: Option<Vec<String>>,

/// BlkioDeviceReadBps is an array of I/O throttle parameters for individual device nodes. This specifically sets read rate cap in bytes per second for device nodes. As with BlkioWeightDevice, we pull the path from /sys/dev, and we don't guarantee the path will be identical to the original (though the node will be).
    #[serde(rename = "BlkioDeviceReadBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_bps: Option<Vec<models::InspectBlkioThrottleDevice>>,

/// BlkioDeviceReadIOps is an array of I/O throttle parameters for individual device nodes. This specifically sets the read rate cap in iops per second for device nodes. As with BlkioWeightDevice, we pull the path from /sys/dev, and we don't guarantee the path will be identical to the original (though the node will be).
    #[serde(rename = "BlkioDeviceReadIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_i_ops: Option<Vec<models::InspectBlkioThrottleDevice>>,

/// BlkioDeviceWriteBps is an array of I/O throttle parameters for individual device nodes. this specifically sets write rate cap in bytes per second for device nodes. as with BlkioWeightDevice, we pull the path from /sys/dev, and we don't guarantee the path will be identical to the original (though the node will be).
    #[serde(rename = "BlkioDeviceWriteBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_bps: Option<Vec<models::InspectBlkioThrottleDevice>>,

/// BlkioDeviceWriteIOps is an array of I/O throttle parameters for individual device nodes. This specifically sets the write rate cap in iops per second for device nodes. As with BlkioWeightDevice, we pull the path from /sys/dev, and we don't guarantee the path will be identical to the original (though the node will be).
    #[serde(rename = "BlkioDeviceWriteIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_i_ops: Option<Vec<models::InspectBlkioThrottleDevice>>,

/// BlkioWeight indicates the I/O resources allocated to the container. It is a relative weight in the scheduler for assigning I/O time versus other Cgroups.
    #[serde(rename = "BlkioWeight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight: Option<i32>,

/// BlkioWeightDevice is an array of I/O resource priorities for individual device nodes. Unfortunately, the spec only stores the device's Major/Minor numbers and not the path, which is used here. Fortunately, the kernel provides an interface for retrieving the path of a given node by major:minor at /sys/dev/. However, the exact path in use may not be what was used in the original CLI invocation - though it is guaranteed that the device node will be the same, and using the given path will be functionally identical.
    #[serde(rename = "BlkioWeightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight_device: Option<Vec<models::InspectBlkioWeightDevice>>,

/// CapAdd is a list of capabilities added to the container. It is not directly stored by Libpod, and instead computed from the capabilities listed in the container's spec, compared against a set of default capabilities.
    #[serde(rename = "CapAdd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_add: Option<Vec<String>>,

/// CapDrop is a list of capabilities removed from the container. It is not directly stored by libpod, and instead computed from the capabilities listed in the container's spec, compared against a set of default capabilities.
    #[serde(rename = "CapDrop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_drop: Option<Vec<String>>,

/// Cgroup contains the container's cgroup. It is presently not populated. TODO.
    #[serde(rename = "Cgroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup: Option<String>,

/// CgroupConf is the configuration for cgroup v2.
    #[serde(rename = "CgroupConf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_conf: Option<std::collections::HashMap<String, String>>,

/// CgroupManager is the cgroup manager used by the container. At present, allowed values are either \"cgroupfs\" or \"systemd\".
    #[serde(rename = "CgroupManager")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_manager: Option<String>,

/// CgroupMode is the configuration of the container's cgroup namespace. Populated as follows: private - a cgroup namespace has been created host - No cgroup namespace created container:<id> - Using another container's cgroup namespace ns:<path> - A path to a cgroup namespace has been specified
    #[serde(rename = "CgroupMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_mode: Option<String>,

/// CgroupParent is the Cgroup parent of the container. Only set if not default.
    #[serde(rename = "CgroupParent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

/// Cgroups contains the container's Cgroup mode. Allowed values are \"default\" (container is creating Cgroups) and \"disabled\" (container is not creating Cgroups). This is Libpod-specific and not included in `docker inspect`.
    #[serde(rename = "Cgroups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroups: Option<String>,

/// ConsoleSize is an array of 2 integers showing the size of the container's console. It is only set if the container is creating a terminal. TODO.
    #[serde(rename = "ConsoleSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub console_size: Option<Vec<i32>>,

/// ContainerIDFile is a file created during container creation to hold the ID of the created container. This is not handled within libpod and is stored in an annotation.
    #[serde(rename = "ContainerIDFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_id_file: Option<String>,

/// CpuCount is Windows-only and not presently implemented.
    #[serde(rename = "CpuCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_count: Option<i32>,

/// CpuPercent is Windows-only and not presently implemented.
    #[serde(rename = "CpuPercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_percent: Option<i32>,

/// CpuPeriod is the length of a CPU period in microseconds. It relates directly to CpuQuota.
    #[serde(rename = "CpuPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i32>,

/// CpuPeriod is the amount of time (in microseconds) that a container can use the CPU in every CpuPeriod.
    #[serde(rename = "CpuQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

/// CpuRealtimePeriod is the length of time (in microseconds) of the CPU realtime period. If set to 0, no time will be allocated to realtime tasks.
    #[serde(rename = "CpuRealtimePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_period: Option<i32>,

/// CpuRealtimeRuntime is the length of time (in microseconds) allocated for realtime tasks within every CpuRealtimePeriod.
    #[serde(rename = "CpuRealtimeRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_runtime: Option<i64>,

/// CpuShares indicates the CPU resources allocated to the container. It is a relative weight in the scheduler for assigning CPU time versus other Cgroups.
    #[serde(rename = "CpuShares")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_shares: Option<i32>,

/// CpusetCpus is the set of CPUs that the container will execute on. Formatted as `0-3` or `0,2`. Default (if unset) is all CPUs.
    #[serde(rename = "CpusetCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

/// CpusetMems is the set of memory nodes the container will use. Formatted as `0-3` or `0,2`. Default (if unset) is all memory nodes.
    #[serde(rename = "CpusetMems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_mems: Option<String>,

/// Devices is a list of device nodes that will be added to the container. These are stored in the OCI spec only as type, major, minor while we display the host path. We convert this with /sys/dev, but we cannot guarantee that the host path will be identical - only that the actual device will be.
    #[serde(rename = "Devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::InspectDevice>>,

/// DiskQuota is the maximum amount of disk space the container may use (in bytes). Presently not populated. TODO.
    #[serde(rename = "DiskQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disk_quota: Option<i32>,

/// Dns is a list of DNS nameservers that will be added to the container's resolv.conf
    #[serde(rename = "Dns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns: Option<Vec<String>>,

/// DnsOptions is a list of DNS options that will be set in the container's resolv.conf
    #[serde(rename = "DnsOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_options: Option<Vec<String>>,

/// DnsSearch is a list of DNS search domains that will be set in the container's resolv.conf
    #[serde(rename = "DnsSearch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

/// ExtraHosts contains hosts that will be added to the container's etc/hosts.
    #[serde(rename = "ExtraHosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub extra_hosts: Option<Vec<String>>,

/// GroupAdd contains groups that the user inside the container will be added to.
    #[serde(rename = "GroupAdd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_add: Option<Vec<String>>,

    #[serde(rename = "IDMappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id_mappings: Option<models::InspectIdMappings>,

/// IOMaximumBandwidth is Windows-only and not presently implemented.
    #[serde(rename = "IOMaximumBandwidth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_bandwidth: Option<i32>,

/// IOMaximumIOps is Windows-only and not presently implemented.
    #[serde(rename = "IOMaximumIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_i_ops: Option<i32>,

/// Init indicates whether the container has an init mounted into it.
    #[serde(rename = "Init")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init: Option<bool>,

/// IntelRdtClosID defines the Intel RDT CAT Class Of Service (COS) that all processes of the container should run in.
    #[serde(rename = "IntelRdtClosID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub intel_rdt_clos_id: Option<String>,

/// IpcMode represents the configuration of the container's IPC namespace. Populated as follows: \"\" (empty string) - Default, an IPC namespace will be created host - No IPC namespace created container:<id> - Using another container's IPC namespace ns:<path> - A path to an IPC namespace has been specified
    #[serde(rename = "IpcMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipc_mode: Option<String>,

/// Isolation is presently unused and provided solely for Docker compatibility.
    #[serde(rename = "Isolation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub isolation: Option<String>,

/// KernelMemory is the maximum amount of memory the kernel will devote to the container.
    #[serde(rename = "KernelMemory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory: Option<i64>,

/// Links is unused, and provided purely for Docker compatibility.
    #[serde(rename = "Links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub links: Option<Vec<String>>,

    #[serde(rename = "LogConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_config: Option<models::InspectLogConfig>,

/// Memory indicates the memory resources allocated to the container. This is the limit (in bytes) of RAM the container may use.
    #[serde(rename = "Memory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory: Option<i64>,

/// MemoryReservation is the reservation (soft limit) of memory available to the container. Soft limits are warnings only and can be exceeded.
    #[serde(rename = "MemoryReservation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_reservation: Option<i64>,

/// MemorySwap is the total limit for all memory available to the container, including swap. 0 indicates that there is no limit to the amount of memory available.
    #[serde(rename = "MemorySwap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swap: Option<i64>,

/// MemorySwappiness is the willingness of the kernel to page container memory to swap. It is an integer from 0 to 100, with low numbers being more likely to be put into swap. 1, the default, will not set swappiness and use the system defaults.
    #[serde(rename = "MemorySwappiness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swappiness: Option<i64>,

/// NanoCpus indicates number of CPUs allocated to the container. It is an integer where one full CPU is indicated by 1000000000 (one billion). Thus, 2.5 CPUs (fractional portions of CPUs are allowed) would be 2500000000 (2.5 billion). In 'docker inspect' this is set exclusively of two further options in the output (CpuPeriod and CpuQuota) which are both used to implement this functionality. We can't distinguish here, so if CpuQuota is set to the default of 100000, we will set both CpuQuota, CpuPeriod, and NanoCpus. If CpuQuota is not the default, we will not set NanoCpus.
    #[serde(rename = "NanoCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nano_cpus: Option<i64>,

/// NetworkMode is the configuration of the container's network namespace. Populated as follows: default - A network namespace is being created and configured via CNI none - A network namespace is being created, not configured via CNI host - No network namespace created container:<id> - Using another container's network namespace ns:<path> - A path to a network namespace has been specified
    #[serde(rename = "NetworkMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_mode: Option<String>,

/// OomKillDisable indicates whether the kernel OOM killer is disabled for the container.
    #[serde(rename = "OomKillDisable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_kill_disable: Option<bool>,

/// OOMScoreAdj is an adjustment that will be made to the container's OOM score.
    #[serde(rename = "OomScoreAdj")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_score_adj: Option<i64>,

/// PidMode represents the configuration of the container's PID namespace. Populated as follows: \"\" (empty string) - Default, a PID namespace will be created host - No PID namespace created container:<id> - Using another container's PID namespace ns:<path> - A path to a PID namespace has been specified
    #[serde(rename = "PidMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid_mode: Option<String>,

/// PidsLimit is the maximum number of PIDs that may be created within the container. 0, the default, indicates no limit.
    #[serde(rename = "PidsLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids_limit: Option<i64>,

/// PortBindings contains the container's port bindings. It is formatted as map[string][]InspectHostPort. The string key here is formatted as <integer port number>/<protocol> and represents the container port. A single container port may be bound to multiple host ports (on different IPs).
    #[serde(rename = "PortBindings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub port_bindings: Option<std::collections::HashMap<String, Vec<models::InspectHostPort>>>,

/// Privileged indicates whether the container is running with elevated privileges. This has a very specific meaning in the Docker sense, so it's very difficult to decode from the spec and config, and so is stored as an annotation.
    #[serde(rename = "Privileged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privileged: Option<bool>,

/// PublishAllPorts indicates whether image ports are being published. This is not directly stored in libpod and is saved as an annotation.
    #[serde(rename = "PublishAllPorts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_all_ports: Option<bool>,

/// ReadonlyRootfs is whether the container will be mounted read-only.
    #[serde(rename = "ReadonlyRootfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub readonly_rootfs: Option<bool>,

    #[serde(rename = "RestartPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<models::InspectRestartPolicy>,

/// Runtime is provided purely for Docker compatibility. It is set unconditionally to \"oci\" as Podman does not presently support non-OCI runtimes.
    #[serde(rename = "Runtime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub runtime: Option<String>,

/// SecurityOpt is a list of security-related options that are set in the container.
    #[serde(rename = "SecurityOpt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_opt: Option<Vec<String>>,

    #[serde(rename = "ShmSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size: Option<i64>,

/// Tmpfs is a list of tmpfs filesystems that will be mounted into the container. It is a map of destination path to options for the mount.
    #[serde(rename = "Tmpfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tmpfs: Option<std::collections::HashMap<String, String>>,

/// UTSMode represents the configuration of the container's UID namespace. Populated as follows: \"\" (empty string) - Default, a UTS namespace will be created host - no UTS namespace created container:<id> - Using another container's UTS namespace ns:<path> - A path to a UTS namespace has been specified
    #[serde(rename = "UTSMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uts_mode: Option<String>,

/// Ulimits is a set of ulimits that will be set within the container.
    #[serde(rename = "Ulimits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ulimits: Option<Vec<models::InspectUlimit>>,

/// UsernsMode represents the configuration of the container's user namespace. When running rootless, a user namespace is created outside of libpod to allow some privileged operations. This will not be reflected here. Populated as follows: \"\" (empty string) - No user namespace will be created private - The container will be run in a user namespace container:<id> - Using another container's user namespace ns:<path> - A path to a user namespace has been specified TODO Rootless has an additional 'keep-id' option, presently not reflected here.
    #[serde(rename = "UsernsMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub userns_mode: Option<String>,

/// VolumeDriver is presently unused and is retained for Docker compatibility.
    #[serde(rename = "VolumeDriver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_driver: Option<String>,

/// VolumesFrom is a list of containers which this container uses volumes from. This is not handled directly within libpod and is stored in an annotation. It is formatted as an array of container names and IDs.
    #[serde(rename = "VolumesFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

}


impl InspectContainerHostConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectContainerHostConfig {
        InspectContainerHostConfig {
            annotations: None,
            auto_remove: None,
            binds: None,
            blkio_device_read_bps: None,
            blkio_device_read_i_ops: None,
            blkio_device_write_bps: None,
            blkio_device_write_i_ops: None,
            blkio_weight: None,
            blkio_weight_device: None,
            cap_add: None,
            cap_drop: None,
            cgroup: None,
            cgroup_conf: None,
            cgroup_manager: None,
            cgroup_mode: None,
            cgroup_parent: None,
            cgroups: None,
            console_size: None,
            container_id_file: None,
            cpu_count: None,
            cpu_percent: None,
            cpu_period: None,
            cpu_quota: None,
            cpu_realtime_period: None,
            cpu_realtime_runtime: None,
            cpu_shares: None,
            cpuset_cpus: None,
            cpuset_mems: None,
            devices: None,
            disk_quota: None,
            dns: None,
            dns_options: None,
            dns_search: None,
            extra_hosts: None,
            group_add: None,
            id_mappings: None,
            io_maximum_bandwidth: None,
            io_maximum_i_ops: None,
            init: None,
            intel_rdt_clos_id: None,
            ipc_mode: None,
            isolation: None,
            kernel_memory: None,
            links: None,
            log_config: None,
            memory: None,
            memory_reservation: None,
            memory_swap: None,
            memory_swappiness: None,
            nano_cpus: None,
            network_mode: None,
            oom_kill_disable: None,
            oom_score_adj: None,
            pid_mode: None,
            pids_limit: None,
            port_bindings: None,
            privileged: None,
            publish_all_ports: None,
            readonly_rootfs: None,
            restart_policy: None,
            runtime: None,
            security_opt: None,
            shm_size: None,
            tmpfs: None,
            uts_mode: None,
            ulimits: None,
            userns_mode: None,
            volume_driver: None,
            volumes_from: None,
        }
    }
}

/// Converts the InspectContainerHostConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectContainerHostConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Annotations in query parameter serialization


            self.auto_remove.as_ref().map(|auto_remove| {
                [
                    "AutoRemove".to_string(),
                    auto_remove.to_string(),
                ].join(",")
            }),


            self.binds.as_ref().map(|binds| {
                [
                    "Binds".to_string(),
                    binds.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping BlkioDeviceReadBps in query parameter serialization

            // Skipping BlkioDeviceReadIOps in query parameter serialization

            // Skipping BlkioDeviceWriteBps in query parameter serialization

            // Skipping BlkioDeviceWriteIOps in query parameter serialization


            self.blkio_weight.as_ref().map(|blkio_weight| {
                [
                    "BlkioWeight".to_string(),
                    blkio_weight.to_string(),
                ].join(",")
            }),

            // Skipping BlkioWeightDevice in query parameter serialization


            self.cap_add.as_ref().map(|cap_add| {
                [
                    "CapAdd".to_string(),
                    cap_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cap_drop.as_ref().map(|cap_drop| {
                [
                    "CapDrop".to_string(),
                    cap_drop.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cgroup.as_ref().map(|cgroup| {
                [
                    "Cgroup".to_string(),
                    cgroup.to_string(),
                ].join(",")
            }),

            // Skipping CgroupConf in query parameter serialization


            self.cgroup_manager.as_ref().map(|cgroup_manager| {
                [
                    "CgroupManager".to_string(),
                    cgroup_manager.to_string(),
                ].join(",")
            }),


            self.cgroup_mode.as_ref().map(|cgroup_mode| {
                [
                    "CgroupMode".to_string(),
                    cgroup_mode.to_string(),
                ].join(",")
            }),


            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "CgroupParent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.cgroups.as_ref().map(|cgroups| {
                [
                    "Cgroups".to_string(),
                    cgroups.to_string(),
                ].join(",")
            }),


            self.console_size.as_ref().map(|console_size| {
                [
                    "ConsoleSize".to_string(),
                    console_size.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.container_id_file.as_ref().map(|container_id_file| {
                [
                    "ContainerIDFile".to_string(),
                    container_id_file.to_string(),
                ].join(",")
            }),


            self.cpu_count.as_ref().map(|cpu_count| {
                [
                    "CpuCount".to_string(),
                    cpu_count.to_string(),
                ].join(",")
            }),


            self.cpu_percent.as_ref().map(|cpu_percent| {
                [
                    "CpuPercent".to_string(),
                    cpu_percent.to_string(),
                ].join(",")
            }),


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "CpuPeriod".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "CpuQuota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_period.as_ref().map(|cpu_realtime_period| {
                [
                    "CpuRealtimePeriod".to_string(),
                    cpu_realtime_period.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_runtime.as_ref().map(|cpu_realtime_runtime| {
                [
                    "CpuRealtimeRuntime".to_string(),
                    cpu_realtime_runtime.to_string(),
                ].join(",")
            }),


            self.cpu_shares.as_ref().map(|cpu_shares| {
                [
                    "CpuShares".to_string(),
                    cpu_shares.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "CpusetCpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.cpuset_mems.as_ref().map(|cpuset_mems| {
                [
                    "CpusetMems".to_string(),
                    cpuset_mems.to_string(),
                ].join(",")
            }),

            // Skipping Devices in query parameter serialization


            self.disk_quota.as_ref().map(|disk_quota| {
                [
                    "DiskQuota".to_string(),
                    disk_quota.to_string(),
                ].join(",")
            }),


            self.dns.as_ref().map(|dns| {
                [
                    "Dns".to_string(),
                    dns.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_options.as_ref().map(|dns_options| {
                [
                    "DnsOptions".to_string(),
                    dns_options.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "DnsSearch".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.extra_hosts.as_ref().map(|extra_hosts| {
                [
                    "ExtraHosts".to_string(),
                    extra_hosts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.group_add.as_ref().map(|group_add| {
                [
                    "GroupAdd".to_string(),
                    group_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping IDMappings in query parameter serialization


            self.io_maximum_bandwidth.as_ref().map(|io_maximum_bandwidth| {
                [
                    "IOMaximumBandwidth".to_string(),
                    io_maximum_bandwidth.to_string(),
                ].join(",")
            }),


            self.io_maximum_i_ops.as_ref().map(|io_maximum_i_ops| {
                [
                    "IOMaximumIOps".to_string(),
                    io_maximum_i_ops.to_string(),
                ].join(",")
            }),


            self.init.as_ref().map(|init| {
                [
                    "Init".to_string(),
                    init.to_string(),
                ].join(",")
            }),


            self.intel_rdt_clos_id.as_ref().map(|intel_rdt_clos_id| {
                [
                    "IntelRdtClosID".to_string(),
                    intel_rdt_clos_id.to_string(),
                ].join(",")
            }),


            self.ipc_mode.as_ref().map(|ipc_mode| {
                [
                    "IpcMode".to_string(),
                    ipc_mode.to_string(),
                ].join(",")
            }),


            self.isolation.as_ref().map(|isolation| {
                [
                    "Isolation".to_string(),
                    isolation.to_string(),
                ].join(",")
            }),


            self.kernel_memory.as_ref().map(|kernel_memory| {
                [
                    "KernelMemory".to_string(),
                    kernel_memory.to_string(),
                ].join(",")
            }),


            self.links.as_ref().map(|links| {
                [
                    "Links".to_string(),
                    links.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping LogConfig in query parameter serialization


            self.memory.as_ref().map(|memory| {
                [
                    "Memory".to_string(),
                    memory.to_string(),
                ].join(",")
            }),


            self.memory_reservation.as_ref().map(|memory_reservation| {
                [
                    "MemoryReservation".to_string(),
                    memory_reservation.to_string(),
                ].join(",")
            }),


            self.memory_swap.as_ref().map(|memory_swap| {
                [
                    "MemorySwap".to_string(),
                    memory_swap.to_string(),
                ].join(",")
            }),


            self.memory_swappiness.as_ref().map(|memory_swappiness| {
                [
                    "MemorySwappiness".to_string(),
                    memory_swappiness.to_string(),
                ].join(",")
            }),


            self.nano_cpus.as_ref().map(|nano_cpus| {
                [
                    "NanoCpus".to_string(),
                    nano_cpus.to_string(),
                ].join(",")
            }),


            self.network_mode.as_ref().map(|network_mode| {
                [
                    "NetworkMode".to_string(),
                    network_mode.to_string(),
                ].join(",")
            }),


            self.oom_kill_disable.as_ref().map(|oom_kill_disable| {
                [
                    "OomKillDisable".to_string(),
                    oom_kill_disable.to_string(),
                ].join(",")
            }),


            self.oom_score_adj.as_ref().map(|oom_score_adj| {
                [
                    "OomScoreAdj".to_string(),
                    oom_score_adj.to_string(),
                ].join(",")
            }),


            self.pid_mode.as_ref().map(|pid_mode| {
                [
                    "PidMode".to_string(),
                    pid_mode.to_string(),
                ].join(",")
            }),


            self.pids_limit.as_ref().map(|pids_limit| {
                [
                    "PidsLimit".to_string(),
                    pids_limit.to_string(),
                ].join(",")
            }),

            // Skipping PortBindings in query parameter serialization
            // Skipping PortBindings in query parameter serialization


            self.privileged.as_ref().map(|privileged| {
                [
                    "Privileged".to_string(),
                    privileged.to_string(),
                ].join(",")
            }),


            self.publish_all_ports.as_ref().map(|publish_all_ports| {
                [
                    "PublishAllPorts".to_string(),
                    publish_all_ports.to_string(),
                ].join(",")
            }),


            self.readonly_rootfs.as_ref().map(|readonly_rootfs| {
                [
                    "ReadonlyRootfs".to_string(),
                    readonly_rootfs.to_string(),
                ].join(",")
            }),

            // Skipping RestartPolicy in query parameter serialization


            self.runtime.as_ref().map(|runtime| {
                [
                    "Runtime".to_string(),
                    runtime.to_string(),
                ].join(",")
            }),


            self.security_opt.as_ref().map(|security_opt| {
                [
                    "SecurityOpt".to_string(),
                    security_opt.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.shm_size.as_ref().map(|shm_size| {
                [
                    "ShmSize".to_string(),
                    shm_size.to_string(),
                ].join(",")
            }),

            // Skipping Tmpfs in query parameter serialization


            self.uts_mode.as_ref().map(|uts_mode| {
                [
                    "UTSMode".to_string(),
                    uts_mode.to_string(),
                ].join(",")
            }),

            // Skipping Ulimits in query parameter serialization


            self.userns_mode.as_ref().map(|userns_mode| {
                [
                    "UsernsMode".to_string(),
                    userns_mode.to_string(),
                ].join(",")
            }),


            self.volume_driver.as_ref().map(|volume_driver| {
                [
                    "VolumeDriver".to_string(),
                    volume_driver.to_string(),
                ].join(",")
            }),


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "VolumesFrom".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectContainerHostConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectContainerHostConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub auto_remove: Vec<bool>,
            pub binds: Vec<Vec<String>>,
            pub blkio_device_read_bps: Vec<Vec<models::InspectBlkioThrottleDevice>>,
            pub blkio_device_read_i_ops: Vec<Vec<models::InspectBlkioThrottleDevice>>,
            pub blkio_device_write_bps: Vec<Vec<models::InspectBlkioThrottleDevice>>,
            pub blkio_device_write_i_ops: Vec<Vec<models::InspectBlkioThrottleDevice>>,
            pub blkio_weight: Vec<i32>,
            pub blkio_weight_device: Vec<Vec<models::InspectBlkioWeightDevice>>,
            pub cap_add: Vec<Vec<String>>,
            pub cap_drop: Vec<Vec<String>>,
            pub cgroup: Vec<String>,
            pub cgroup_conf: Vec<std::collections::HashMap<String, String>>,
            pub cgroup_manager: Vec<String>,
            pub cgroup_mode: Vec<String>,
            pub cgroup_parent: Vec<String>,
            pub cgroups: Vec<String>,
            pub console_size: Vec<Vec<i32>>,
            pub container_id_file: Vec<String>,
            pub cpu_count: Vec<i32>,
            pub cpu_percent: Vec<i32>,
            pub cpu_period: Vec<i32>,
            pub cpu_quota: Vec<i64>,
            pub cpu_realtime_period: Vec<i32>,
            pub cpu_realtime_runtime: Vec<i64>,
            pub cpu_shares: Vec<i32>,
            pub cpuset_cpus: Vec<String>,
            pub cpuset_mems: Vec<String>,
            pub devices: Vec<Vec<models::InspectDevice>>,
            pub disk_quota: Vec<i32>,
            pub dns: Vec<Vec<String>>,
            pub dns_options: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub extra_hosts: Vec<Vec<String>>,
            pub group_add: Vec<Vec<String>>,
            pub id_mappings: Vec<models::InspectIdMappings>,
            pub io_maximum_bandwidth: Vec<i32>,
            pub io_maximum_i_ops: Vec<i32>,
            pub init: Vec<bool>,
            pub intel_rdt_clos_id: Vec<String>,
            pub ipc_mode: Vec<String>,
            pub isolation: Vec<String>,
            pub kernel_memory: Vec<i64>,
            pub links: Vec<Vec<String>>,
            pub log_config: Vec<models::InspectLogConfig>,
            pub memory: Vec<i64>,
            pub memory_reservation: Vec<i64>,
            pub memory_swap: Vec<i64>,
            pub memory_swappiness: Vec<i64>,
            pub nano_cpus: Vec<i64>,
            pub network_mode: Vec<String>,
            pub oom_kill_disable: Vec<bool>,
            pub oom_score_adj: Vec<i64>,
            pub pid_mode: Vec<String>,
            pub pids_limit: Vec<i64>,
            pub port_bindings: Vec<std::collections::HashMap<String, Vec<models::InspectHostPort>>>,
            pub privileged: Vec<bool>,
            pub publish_all_ports: Vec<bool>,
            pub readonly_rootfs: Vec<bool>,
            pub restart_policy: Vec<models::InspectRestartPolicy>,
            pub runtime: Vec<String>,
            pub security_opt: Vec<Vec<String>>,
            pub shm_size: Vec<i64>,
            pub tmpfs: Vec<std::collections::HashMap<String, String>>,
            pub uts_mode: Vec<String>,
            pub ulimits: Vec<Vec<models::InspectUlimit>>,
            pub userns_mode: Vec<String>,
            pub volume_driver: Vec<String>,
            pub volumes_from: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectContainerHostConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "AutoRemove" => intermediate_rep.auto_remove.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Binds" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "BlkioDeviceReadBps" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "BlkioDeviceReadIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "BlkioDeviceWriteBps" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "BlkioDeviceWriteIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "BlkioWeight" => intermediate_rep.blkio_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "BlkioWeightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "CapAdd" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "CapDrop" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Cgroup" => intermediate_rep.cgroup.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "CgroupConf" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "CgroupManager" => intermediate_rep.cgroup_manager.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CgroupMode" => intermediate_rep.cgroup_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CgroupParent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Cgroups" => intermediate_rep.cgroups.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ConsoleSize" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ContainerIDFile" => intermediate_rep.container_id_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuCount" => intermediate_rep.cpu_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPercent" => intermediate_rep.cpu_percent.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPeriod" => intermediate_rep.cpu_period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuQuota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimePeriod" => intermediate_rep.cpu_realtime_period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimeRuntime" => intermediate_rep.cpu_realtime_runtime.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuShares" => intermediate_rep.cpu_shares.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetCpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetMems" => intermediate_rep.cpuset_mems.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "DiskQuota" => intermediate_rep.disk_quota.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Dns" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "DnsOptions" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "DnsSearch" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "ExtraHosts" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    "GroupAdd" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "IDMappings" => intermediate_rep.id_mappings.push(<models::InspectIdMappings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumBandwidth" => intermediate_rep.io_maximum_bandwidth.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumIOps" => intermediate_rep.io_maximum_i_ops.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Init" => intermediate_rep.init.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IntelRdtClosID" => intermediate_rep.intel_rdt_clos_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IpcMode" => intermediate_rep.ipc_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Isolation" => intermediate_rep.isolation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemory" => intermediate_rep.kernel_memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Links" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "LogConfig" => intermediate_rep.log_config.push(<models::InspectLogConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Memory" => intermediate_rep.memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemoryReservation" => intermediate_rep.memory_reservation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwap" => intermediate_rep.memory_swap.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwappiness" => intermediate_rep.memory_swappiness.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NanoCpus" => intermediate_rep.nano_cpus.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetworkMode" => intermediate_rep.network_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomKillDisable" => intermediate_rep.oom_kill_disable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomScoreAdj" => intermediate_rep.oom_score_adj.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidMode" => intermediate_rep.pid_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidsLimit" => intermediate_rep.pids_limit.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "PortBindings" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Privileged" => intermediate_rep.privileged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PublishAllPorts" => intermediate_rep.publish_all_ports.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ReadonlyRootfs" => intermediate_rep.readonly_rootfs.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestartPolicy" => intermediate_rep.restart_policy.push(<models::InspectRestartPolicy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Runtime" => intermediate_rep.runtime.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "SecurityOpt" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ShmSize" => intermediate_rep.shm_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Tmpfs" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "UTSMode" => intermediate_rep.uts_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ulimits" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "UsernsMode" => intermediate_rep.userns_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VolumeDriver" => intermediate_rep.volume_driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "VolumesFrom" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectContainerHostConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectContainerHostConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectContainerHostConfig {
            annotations: intermediate_rep.annotations.into_iter().next(),
            auto_remove: intermediate_rep.auto_remove.into_iter().next(),
            binds: intermediate_rep.binds.into_iter().next(),
            blkio_device_read_bps: intermediate_rep.blkio_device_read_bps.into_iter().next(),
            blkio_device_read_i_ops: intermediate_rep.blkio_device_read_i_ops.into_iter().next(),
            blkio_device_write_bps: intermediate_rep.blkio_device_write_bps.into_iter().next(),
            blkio_device_write_i_ops: intermediate_rep.blkio_device_write_i_ops.into_iter().next(),
            blkio_weight: intermediate_rep.blkio_weight.into_iter().next(),
            blkio_weight_device: intermediate_rep.blkio_weight_device.into_iter().next(),
            cap_add: intermediate_rep.cap_add.into_iter().next(),
            cap_drop: intermediate_rep.cap_drop.into_iter().next(),
            cgroup: intermediate_rep.cgroup.into_iter().next(),
            cgroup_conf: intermediate_rep.cgroup_conf.into_iter().next(),
            cgroup_manager: intermediate_rep.cgroup_manager.into_iter().next(),
            cgroup_mode: intermediate_rep.cgroup_mode.into_iter().next(),
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cgroups: intermediate_rep.cgroups.into_iter().next(),
            console_size: intermediate_rep.console_size.into_iter().next(),
            container_id_file: intermediate_rep.container_id_file.into_iter().next(),
            cpu_count: intermediate_rep.cpu_count.into_iter().next(),
            cpu_percent: intermediate_rep.cpu_percent.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            cpu_realtime_period: intermediate_rep.cpu_realtime_period.into_iter().next(),
            cpu_realtime_runtime: intermediate_rep.cpu_realtime_runtime.into_iter().next(),
            cpu_shares: intermediate_rep.cpu_shares.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            cpuset_mems: intermediate_rep.cpuset_mems.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            disk_quota: intermediate_rep.disk_quota.into_iter().next(),
            dns: intermediate_rep.dns.into_iter().next(),
            dns_options: intermediate_rep.dns_options.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            extra_hosts: intermediate_rep.extra_hosts.into_iter().next(),
            group_add: intermediate_rep.group_add.into_iter().next(),
            id_mappings: intermediate_rep.id_mappings.into_iter().next(),
            io_maximum_bandwidth: intermediate_rep.io_maximum_bandwidth.into_iter().next(),
            io_maximum_i_ops: intermediate_rep.io_maximum_i_ops.into_iter().next(),
            init: intermediate_rep.init.into_iter().next(),
            intel_rdt_clos_id: intermediate_rep.intel_rdt_clos_id.into_iter().next(),
            ipc_mode: intermediate_rep.ipc_mode.into_iter().next(),
            isolation: intermediate_rep.isolation.into_iter().next(),
            kernel_memory: intermediate_rep.kernel_memory.into_iter().next(),
            links: intermediate_rep.links.into_iter().next(),
            log_config: intermediate_rep.log_config.into_iter().next(),
            memory: intermediate_rep.memory.into_iter().next(),
            memory_reservation: intermediate_rep.memory_reservation.into_iter().next(),
            memory_swap: intermediate_rep.memory_swap.into_iter().next(),
            memory_swappiness: intermediate_rep.memory_swappiness.into_iter().next(),
            nano_cpus: intermediate_rep.nano_cpus.into_iter().next(),
            network_mode: intermediate_rep.network_mode.into_iter().next(),
            oom_kill_disable: intermediate_rep.oom_kill_disable.into_iter().next(),
            oom_score_adj: intermediate_rep.oom_score_adj.into_iter().next(),
            pid_mode: intermediate_rep.pid_mode.into_iter().next(),
            pids_limit: intermediate_rep.pids_limit.into_iter().next(),
            port_bindings: intermediate_rep.port_bindings.into_iter().next(),
            privileged: intermediate_rep.privileged.into_iter().next(),
            publish_all_ports: intermediate_rep.publish_all_ports.into_iter().next(),
            readonly_rootfs: intermediate_rep.readonly_rootfs.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            runtime: intermediate_rep.runtime.into_iter().next(),
            security_opt: intermediate_rep.security_opt.into_iter().next(),
            shm_size: intermediate_rep.shm_size.into_iter().next(),
            tmpfs: intermediate_rep.tmpfs.into_iter().next(),
            uts_mode: intermediate_rep.uts_mode.into_iter().next(),
            ulimits: intermediate_rep.ulimits.into_iter().next(),
            userns_mode: intermediate_rep.userns_mode.into_iter().next(),
            volume_driver: intermediate_rep.volume_driver.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectContainerHostConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectContainerHostConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectContainerHostConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectContainerHostConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectContainerHostConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectContainerHostConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectContainerHostConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectContainerState provides a detailed record of a container's current state. It is returned as part of InspectContainerData. As with InspectContainerData, many portions of this struct are matched to Docker, but here we see more fields that are unused (nonsensical in the context of Libpod).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectContainerState {
    #[serde(rename = "CgroupPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_path: Option<String>,

    #[serde(rename = "CheckpointLog")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub checkpoint_log: Option<String>,

    #[serde(rename = "CheckpointPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub checkpoint_path: Option<String>,

    #[serde(rename = "Checkpointed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub checkpointed: Option<bool>,

    #[serde(rename = "CheckpointedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub checkpointed_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "ConmonPid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conmon_pid: Option<i64>,

    #[serde(rename = "Dead")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dead: Option<bool>,

    #[serde(rename = "Error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,

    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i32>,

    #[serde(rename = "FinishedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub finished_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Health")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub health: Option<models::HealthCheckResults>,

    #[serde(rename = "OOMKilled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_killed: Option<bool>,

    #[serde(rename = "OciVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oci_version: Option<String>,

    #[serde(rename = "Paused")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub paused: Option<bool>,

    #[serde(rename = "Pid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid: Option<i64>,

    #[serde(rename = "Restarting")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restarting: Option<bool>,

    #[serde(rename = "RestoreLog")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restore_log: Option<String>,

    #[serde(rename = "Restored")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restored: Option<bool>,

    #[serde(rename = "RestoredAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restored_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Running")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub running: Option<bool>,

    #[serde(rename = "StartedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "StoppedByUser")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stopped_by_user: Option<bool>,

}


impl InspectContainerState {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectContainerState {
        InspectContainerState {
            cgroup_path: None,
            checkpoint_log: None,
            checkpoint_path: None,
            checkpointed: None,
            checkpointed_at: None,
            conmon_pid: None,
            dead: None,
            error: None,
            exit_code: None,
            finished_at: None,
            health: None,
            oom_killed: None,
            oci_version: None,
            paused: None,
            pid: None,
            restarting: None,
            restore_log: None,
            restored: None,
            restored_at: None,
            running: None,
            started_at: None,
            status: None,
            stopped_by_user: None,
        }
    }
}

/// Converts the InspectContainerState value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectContainerState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup_path.as_ref().map(|cgroup_path| {
                [
                    "CgroupPath".to_string(),
                    cgroup_path.to_string(),
                ].join(",")
            }),


            self.checkpoint_log.as_ref().map(|checkpoint_log| {
                [
                    "CheckpointLog".to_string(),
                    checkpoint_log.to_string(),
                ].join(",")
            }),


            self.checkpoint_path.as_ref().map(|checkpoint_path| {
                [
                    "CheckpointPath".to_string(),
                    checkpoint_path.to_string(),
                ].join(",")
            }),


            self.checkpointed.as_ref().map(|checkpointed| {
                [
                    "Checkpointed".to_string(),
                    checkpointed.to_string(),
                ].join(",")
            }),

            // Skipping CheckpointedAt in query parameter serialization


            self.conmon_pid.as_ref().map(|conmon_pid| {
                [
                    "ConmonPid".to_string(),
                    conmon_pid.to_string(),
                ].join(",")
            }),


            self.dead.as_ref().map(|dead| {
                [
                    "Dead".to_string(),
                    dead.to_string(),
                ].join(",")
            }),


            self.error.as_ref().map(|error| {
                [
                    "Error".to_string(),
                    error.to_string(),
                ].join(",")
            }),


            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),

            // Skipping FinishedAt in query parameter serialization

            // Skipping Health in query parameter serialization


            self.oom_killed.as_ref().map(|oom_killed| {
                [
                    "OOMKilled".to_string(),
                    oom_killed.to_string(),
                ].join(",")
            }),


            self.oci_version.as_ref().map(|oci_version| {
                [
                    "OciVersion".to_string(),
                    oci_version.to_string(),
                ].join(",")
            }),


            self.paused.as_ref().map(|paused| {
                [
                    "Paused".to_string(),
                    paused.to_string(),
                ].join(",")
            }),


            self.pid.as_ref().map(|pid| {
                [
                    "Pid".to_string(),
                    pid.to_string(),
                ].join(",")
            }),


            self.restarting.as_ref().map(|restarting| {
                [
                    "Restarting".to_string(),
                    restarting.to_string(),
                ].join(",")
            }),


            self.restore_log.as_ref().map(|restore_log| {
                [
                    "RestoreLog".to_string(),
                    restore_log.to_string(),
                ].join(",")
            }),


            self.restored.as_ref().map(|restored| {
                [
                    "Restored".to_string(),
                    restored.to_string(),
                ].join(",")
            }),

            // Skipping RestoredAt in query parameter serialization


            self.running.as_ref().map(|running| {
                [
                    "Running".to_string(),
                    running.to_string(),
                ].join(",")
            }),

            // Skipping StartedAt in query parameter serialization


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.stopped_by_user.as_ref().map(|stopped_by_user| {
                [
                    "StoppedByUser".to_string(),
                    stopped_by_user.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectContainerState value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectContainerState {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup_path: Vec<String>,
            pub checkpoint_log: Vec<String>,
            pub checkpoint_path: Vec<String>,
            pub checkpointed: Vec<bool>,
            pub checkpointed_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub conmon_pid: Vec<i64>,
            pub dead: Vec<bool>,
            pub error: Vec<String>,
            pub exit_code: Vec<i32>,
            pub finished_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub health: Vec<models::HealthCheckResults>,
            pub oom_killed: Vec<bool>,
            pub oci_version: Vec<String>,
            pub paused: Vec<bool>,
            pub pid: Vec<i64>,
            pub restarting: Vec<bool>,
            pub restore_log: Vec<String>,
            pub restored: Vec<bool>,
            pub restored_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub running: Vec<bool>,
            pub started_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<String>,
            pub stopped_by_user: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectContainerState".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CgroupPath" => intermediate_rep.cgroup_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CheckpointLog" => intermediate_rep.checkpoint_log.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CheckpointPath" => intermediate_rep.checkpoint_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Checkpointed" => intermediate_rep.checkpointed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CheckpointedAt" => intermediate_rep.checkpointed_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ConmonPid" => intermediate_rep.conmon_pid.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Dead" => intermediate_rep.dead.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Error" => intermediate_rep.error.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "FinishedAt" => intermediate_rep.finished_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Health" => intermediate_rep.health.push(<models::HealthCheckResults as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OOMKilled" => intermediate_rep.oom_killed.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OciVersion" => intermediate_rep.oci_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Paused" => intermediate_rep.paused.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Pid" => intermediate_rep.pid.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Restarting" => intermediate_rep.restarting.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestoreLog" => intermediate_rep.restore_log.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Restored" => intermediate_rep.restored.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestoredAt" => intermediate_rep.restored_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Running" => intermediate_rep.running.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartedAt" => intermediate_rep.started_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StoppedByUser" => intermediate_rep.stopped_by_user.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectContainerState".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectContainerState {
            cgroup_path: intermediate_rep.cgroup_path.into_iter().next(),
            checkpoint_log: intermediate_rep.checkpoint_log.into_iter().next(),
            checkpoint_path: intermediate_rep.checkpoint_path.into_iter().next(),
            checkpointed: intermediate_rep.checkpointed.into_iter().next(),
            checkpointed_at: intermediate_rep.checkpointed_at.into_iter().next(),
            conmon_pid: intermediate_rep.conmon_pid.into_iter().next(),
            dead: intermediate_rep.dead.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            finished_at: intermediate_rep.finished_at.into_iter().next(),
            health: intermediate_rep.health.into_iter().next(),
            oom_killed: intermediate_rep.oom_killed.into_iter().next(),
            oci_version: intermediate_rep.oci_version.into_iter().next(),
            paused: intermediate_rep.paused.into_iter().next(),
            pid: intermediate_rep.pid.into_iter().next(),
            restarting: intermediate_rep.restarting.into_iter().next(),
            restore_log: intermediate_rep.restore_log.into_iter().next(),
            restored: intermediate_rep.restored.into_iter().next(),
            restored_at: intermediate_rep.restored_at.into_iter().next(),
            running: intermediate_rep.running.into_iter().next(),
            started_at: intermediate_rep.started_at.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            stopped_by_user: intermediate_rep.stopped_by_user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectContainerState> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectContainerState>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectContainerState>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectContainerState - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectContainerState> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectContainerState as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectContainerState - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectDevice {
/// CgroupPermissions is the permissions of the mounted device. Presently not populated. TODO.
    #[serde(rename = "CgroupPermissions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_permissions: Option<String>,

/// PathInContainer is the path of the device within the container.
    #[serde(rename = "PathInContainer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path_in_container: Option<String>,

/// PathOnHost is the path of the device on the host.
    #[serde(rename = "PathOnHost")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path_on_host: Option<String>,

}


impl InspectDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectDevice {
        InspectDevice {
            cgroup_permissions: None,
            path_in_container: None,
            path_on_host: None,
        }
    }
}

/// Converts the InspectDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup_permissions.as_ref().map(|cgroup_permissions| {
                [
                    "CgroupPermissions".to_string(),
                    cgroup_permissions.to_string(),
                ].join(",")
            }),


            self.path_in_container.as_ref().map(|path_in_container| {
                [
                    "PathInContainer".to_string(),
                    path_in_container.to_string(),
                ].join(",")
            }),


            self.path_on_host.as_ref().map(|path_on_host| {
                [
                    "PathOnHost".to_string(),
                    path_on_host.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup_permissions: Vec<String>,
            pub path_in_container: Vec<String>,
            pub path_on_host: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CgroupPermissions" => intermediate_rep.cgroup_permissions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PathInContainer" => intermediate_rep.path_in_container.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PathOnHost" => intermediate_rep.path_on_host.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectDevice {
            cgroup_permissions: intermediate_rep.cgroup_permissions.into_iter().next(),
            path_in_container: intermediate_rep.path_in_container.into_iter().next(),
            path_on_host: intermediate_rep.path_on_host.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectExecProcess contains information about the process in a given exec session.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectExecProcess {
/// Arguments are the arguments to the entrypoint command of the exec session.
    #[serde(rename = "arguments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arguments: Option<Vec<String>>,

/// Entrypoint is the entrypoint for the exec session (the command that will be executed in the container).
    #[serde(rename = "entrypoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrypoint: Option<String>,

/// Privileged is whether the exec session will be started with elevated privileges.
    #[serde(rename = "privileged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privileged: Option<bool>,

/// Tty is whether the exec session created a terminal.
    #[serde(rename = "tty")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tty: Option<bool>,

/// User is the user the exec session was started as.
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}


impl InspectExecProcess {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectExecProcess {
        InspectExecProcess {
            arguments: None,
            entrypoint: None,
            privileged: None,
            tty: None,
            user: None,
        }
    }
}

/// Converts the InspectExecProcess value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectExecProcess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.arguments.as_ref().map(|arguments| {
                [
                    "arguments".to_string(),
                    arguments.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.entrypoint.as_ref().map(|entrypoint| {
                [
                    "entrypoint".to_string(),
                    entrypoint.to_string(),
                ].join(",")
            }),


            self.privileged.as_ref().map(|privileged| {
                [
                    "privileged".to_string(),
                    privileged.to_string(),
                ].join(",")
            }),


            self.tty.as_ref().map(|tty| {
                [
                    "tty".to_string(),
                    tty.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectExecProcess value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectExecProcess {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub arguments: Vec<Vec<String>>,
            pub entrypoint: Vec<String>,
            pub privileged: Vec<bool>,
            pub tty: Vec<bool>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectExecProcess".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "arguments" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectExecProcess".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "entrypoint" => intermediate_rep.entrypoint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "privileged" => intermediate_rep.privileged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tty" => intermediate_rep.tty.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectExecProcess".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectExecProcess {
            arguments: intermediate_rep.arguments.into_iter().next(),
            entrypoint: intermediate_rep.entrypoint.into_iter().next(),
            privileged: intermediate_rep.privileged.into_iter().next(),
            tty: intermediate_rep.tty.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectExecProcess> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectExecProcess>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectExecProcess>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectExecProcess - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectExecProcess> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectExecProcess as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectExecProcess - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectExecSession {
/// CanRemove is legacy and used purely for compatibility reasons. Will always be set to true, unless the exec session is running.
    #[serde(rename = "CanRemove")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_remove: Option<bool>,

/// ContainerID is the ID of the container this exec session is attached to.
    #[serde(rename = "ContainerID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_id: Option<String>,

/// DetachKeys are the detach keys used by the exec session. If set to \"\" the default keys are being used. Will show \"<none>\" if no detach keys are set.
    #[serde(rename = "DetachKeys")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detach_keys: Option<String>,

/// ExitCode is the exit code of the exec session. Will be set to 0 if the exec session has not yet exited.
    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i64>,

/// ID is the ID of the exec session.
    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// OpenStderr is whether the container's STDERR stream will be attached. Always set to true if the exec session created a TTY.
    #[serde(rename = "OpenStderr")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_stderr: Option<bool>,

/// OpenStdin is whether the container's STDIN stream will be attached to.
    #[serde(rename = "OpenStdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_stdin: Option<bool>,

/// OpenStdout is whether the container's STDOUT stream will be attached. Always set to true if the exec session created a TTY.
    #[serde(rename = "OpenStdout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_stdout: Option<bool>,

/// Pid is the PID of the exec session's process. Will be set to 0 if the exec session is not running.
    #[serde(rename = "Pid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid: Option<i64>,

    #[serde(rename = "ProcessConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub process_config: Option<models::InspectExecProcess>,

/// Running is whether the exec session is running.
    #[serde(rename = "Running")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub running: Option<bool>,

}


impl InspectExecSession {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectExecSession {
        InspectExecSession {
            can_remove: None,
            container_id: None,
            detach_keys: None,
            exit_code: None,
            id: None,
            open_stderr: None,
            open_stdin: None,
            open_stdout: None,
            pid: None,
            process_config: None,
            running: None,
        }
    }
}

/// Converts the InspectExecSession value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectExecSession {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.can_remove.as_ref().map(|can_remove| {
                [
                    "CanRemove".to_string(),
                    can_remove.to_string(),
                ].join(",")
            }),


            self.container_id.as_ref().map(|container_id| {
                [
                    "ContainerID".to_string(),
                    container_id.to_string(),
                ].join(",")
            }),


            self.detach_keys.as_ref().map(|detach_keys| {
                [
                    "DetachKeys".to_string(),
                    detach_keys.to_string(),
                ].join(",")
            }),


            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.open_stderr.as_ref().map(|open_stderr| {
                [
                    "OpenStderr".to_string(),
                    open_stderr.to_string(),
                ].join(",")
            }),


            self.open_stdin.as_ref().map(|open_stdin| {
                [
                    "OpenStdin".to_string(),
                    open_stdin.to_string(),
                ].join(",")
            }),


            self.open_stdout.as_ref().map(|open_stdout| {
                [
                    "OpenStdout".to_string(),
                    open_stdout.to_string(),
                ].join(",")
            }),


            self.pid.as_ref().map(|pid| {
                [
                    "Pid".to_string(),
                    pid.to_string(),
                ].join(",")
            }),

            // Skipping ProcessConfig in query parameter serialization


            self.running.as_ref().map(|running| {
                [
                    "Running".to_string(),
                    running.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectExecSession value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectExecSession {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub can_remove: Vec<bool>,
            pub container_id: Vec<String>,
            pub detach_keys: Vec<String>,
            pub exit_code: Vec<i64>,
            pub id: Vec<String>,
            pub open_stderr: Vec<bool>,
            pub open_stdin: Vec<bool>,
            pub open_stdout: Vec<bool>,
            pub pid: Vec<i64>,
            pub process_config: Vec<models::InspectExecProcess>,
            pub running: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectExecSession".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CanRemove" => intermediate_rep.can_remove.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ContainerID" => intermediate_rep.container_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DetachKeys" => intermediate_rep.detach_keys.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OpenStderr" => intermediate_rep.open_stderr.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OpenStdin" => intermediate_rep.open_stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OpenStdout" => intermediate_rep.open_stdout.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Pid" => intermediate_rep.pid.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ProcessConfig" => intermediate_rep.process_config.push(<models::InspectExecProcess as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Running" => intermediate_rep.running.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectExecSession".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectExecSession {
            can_remove: intermediate_rep.can_remove.into_iter().next(),
            container_id: intermediate_rep.container_id.into_iter().next(),
            detach_keys: intermediate_rep.detach_keys.into_iter().next(),
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            open_stderr: intermediate_rep.open_stderr.into_iter().next(),
            open_stdin: intermediate_rep.open_stdin.into_iter().next(),
            open_stdout: intermediate_rep.open_stdout.into_iter().next(),
            pid: intermediate_rep.pid.into_iter().next(),
            process_config: intermediate_rep.process_config.into_iter().next(),
            running: intermediate_rep.running.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectExecSession> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectExecSession>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectExecSession>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectExecSession - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectExecSession> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectExecSession as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectExecSession - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectHostPort provides information on a port on the host that a container's port is bound to.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectHostPort {
/// IP on the host we are bound to. \"\" if not specified (binding to all IPs).
    #[serde(rename = "HostIp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_ip: Option<String>,

/// Port on the host we are bound to. No special formatting - just an integer stuffed into a string.
    #[serde(rename = "HostPort")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_port: Option<String>,

}


impl InspectHostPort {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectHostPort {
        InspectHostPort {
            host_ip: None,
            host_port: None,
        }
    }
}

/// Converts the InspectHostPort value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectHostPort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.host_ip.as_ref().map(|host_ip| {
                [
                    "HostIp".to_string(),
                    host_ip.to_string(),
                ].join(",")
            }),


            self.host_port.as_ref().map(|host_port| {
                [
                    "HostPort".to_string(),
                    host_port.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectHostPort value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectHostPort {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub host_ip: Vec<String>,
            pub host_port: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectHostPort".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "HostIp" => intermediate_rep.host_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostPort" => intermediate_rep.host_port.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectHostPort".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectHostPort {
            host_ip: intermediate_rep.host_ip.into_iter().next(),
            host_port: intermediate_rep.host_port.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectHostPort> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectHostPort>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectHostPort>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectHostPort - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectHostPort> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectHostPort as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectHostPort - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectIdMappings {
    #[serde(rename = "GidMap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gid_map: Option<Vec<String>>,

    #[serde(rename = "UidMap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid_map: Option<Vec<String>>,

}


impl InspectIdMappings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectIdMappings {
        InspectIdMappings {
            gid_map: None,
            uid_map: None,
        }
    }
}

/// Converts the InspectIdMappings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectIdMappings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.gid_map.as_ref().map(|gid_map| {
                [
                    "GidMap".to_string(),
                    gid_map.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.uid_map.as_ref().map(|uid_map| {
                [
                    "UidMap".to_string(),
                    uid_map.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectIdMappings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectIdMappings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gid_map: Vec<Vec<String>>,
            pub uid_map: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectIdMappings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "GidMap" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectIdMappings".to_string()),
                    "UidMap" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectIdMappings".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectIdMappings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectIdMappings {
            gid_map: intermediate_rep.gid_map.into_iter().next(),
            uid_map: intermediate_rep.uid_map.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectIdMappings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectIdMappings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectIdMappings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectIdMappings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectIdMappings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectIdMappings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectIdMappings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectLogConfig holds information about a container's configured log driver



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectLogConfig {
    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<std::collections::HashMap<String, String>>,

/// Path specifies a path to the log file
    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// Size specifies a maximum size of the container log
    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<String>,

/// Tag specifies a custom log tag for the container
    #[serde(rename = "Tag")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag: Option<String>,

    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl InspectLogConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectLogConfig {
        InspectLogConfig {
            config: None,
            path: None,
            size: None,
            tag: None,
            r#type: None,
        }
    }
}

/// Converts the InspectLogConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectLogConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Config in query parameter serialization


            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.tag.as_ref().map(|tag| {
                [
                    "Tag".to_string(),
                    tag.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectLogConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectLogConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config: Vec<std::collections::HashMap<String, String>>,
            pub path: Vec<String>,
            pub size: Vec<String>,
            pub tag: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectLogConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Config" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectLogConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tag" => intermediate_rep.tag.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectLogConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectLogConfig {
            config: intermediate_rep.config.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            tag: intermediate_rep.tag.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectLogConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectLogConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectLogConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectLogConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectLogConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectLogConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectLogConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectMount provides a record of a single mount in a container. It contains fields for both named and normal volumes. Only user-specified volumes will be included, and tmpfs volumes are not included even if the user specified them.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectMount {
/// The destination directory for the volume. Specified as a path within the container, as it would be passed into the OCI runtime.
    #[serde(rename = "Destination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination: Option<String>,

/// The driver used for the named volume. Empty for bind mounts.
    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// Contains SELinux :z/:Z mount options. Unclear what, if anything, else goes in here.
    #[serde(rename = "Mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

/// The name of the volume. Empty for bind mounts.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// All remaining mount options. Additional data, not present in the original output.
    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<Vec<String>>,

/// Mount propagation for the mount. Can be empty if not specified, but is always printed - no omitempty.
    #[serde(rename = "Propagation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub propagation: Option<String>,

/// Whether the volume is read-write
    #[serde(rename = "RW")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rw: Option<bool>,

/// The source directory for the volume.
    #[serde(rename = "Source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,

/// Whether the mount is a volume or bind mount. Allowed values are \"volume\" and \"bind\".
    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl InspectMount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectMount {
        InspectMount {
            destination: None,
            driver: None,
            mode: None,
            name: None,
            options: None,
            propagation: None,
            rw: None,
            source: None,
            r#type: None,
        }
    }
}

/// Converts the InspectMount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectMount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.destination.as_ref().map(|destination| {
                [
                    "Destination".to_string(),
                    destination.to_string(),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "Mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.options.as_ref().map(|options| {
                [
                    "Options".to_string(),
                    options.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.propagation.as_ref().map(|propagation| {
                [
                    "Propagation".to_string(),
                    propagation.to_string(),
                ].join(",")
            }),


            self.rw.as_ref().map(|rw| {
                [
                    "RW".to_string(),
                    rw.to_string(),
                ].join(",")
            }),


            self.source.as_ref().map(|source| {
                [
                    "Source".to_string(),
                    source.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectMount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectMount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub destination: Vec<String>,
            pub driver: Vec<String>,
            pub mode: Vec<String>,
            pub name: Vec<String>,
            pub options: Vec<Vec<String>>,
            pub propagation: Vec<String>,
            pub rw: Vec<bool>,
            pub source: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectMount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Destination" => intermediate_rep.destination.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectMount".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Propagation" => intermediate_rep.propagation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RW" => intermediate_rep.rw.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Source" => intermediate_rep.source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectMount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectMount {
            destination: intermediate_rep.destination.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            propagation: intermediate_rep.propagation.into_iter().next(),
            rw: intermediate_rep.rw.into_iter().next(),
            source: intermediate_rep.source.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectMount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectMount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectMount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectMount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectMount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectMount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectMount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectNetworkSettings holds information about the network settings of the container. Many fields are maintained only for compatibility with `docker inspect` and are unused within Libpod.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectNetworkSettings {
/// AdditionalMacAddresses is a set of additional MAC Addresses beyond the first. CNI may configure more than one interface for a single network, which can cause this.
    #[serde(rename = "AdditionalMACAddresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_mac_addresses: Option<Vec<String>>,

    #[serde(rename = "Bridge")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bridge: Option<String>,

/// EndpointID is unused, maintained exclusively for compatibility.
    #[serde(rename = "EndpointID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_id: Option<String>,

/// Gateway is the IP address of the gateway this network will use.
    #[serde(rename = "Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

/// GlobalIPv6Address is the global-scope IPv6 Address for this network.
    #[serde(rename = "GlobalIPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_address: Option<String>,

/// GlobalIPv6PrefixLen is the length of the subnet mask of this network.
    #[serde(rename = "GlobalIPv6PrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_prefix_len: Option<i64>,

    #[serde(rename = "HairpinMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hairpin_mode: Option<bool>,

/// IPAddress is the IP address for this network.
    #[serde(rename = "IPAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_address: Option<String>,

/// IPPrefixLen is the length of the subnet mask of this network.
    #[serde(rename = "IPPrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_prefix_len: Option<i64>,

/// IPv6Gateway is the IPv6 gateway this network will use.
    #[serde(rename = "IPv6Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_gateway: Option<String>,

    #[serde(rename = "LinkLocalIPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_local_ipv6_address: Option<String>,

    #[serde(rename = "LinkLocalIPv6PrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_local_ipv6_prefix_len: Option<i64>,

/// MacAddress is the MAC address for the interface in this network.
    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

/// Networks contains information on non-default networks this container has joined. It is a map of network name to network information.
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<std::collections::HashMap<String, models::InspectAdditionalNetwork>>,

    #[serde(rename = "Ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ports: Option<std::collections::HashMap<String, Vec<models::InspectHostPort>>>,

    #[serde(rename = "SandboxID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sandbox_id: Option<String>,

    #[serde(rename = "SandboxKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sandbox_key: Option<String>,

/// SecondaryIPAddresses is a list of extra IP Addresses that the container has been assigned in this network.
    #[serde(rename = "SecondaryIPAddresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secondary_ip_addresses: Option<Vec<models::Address>>,

/// SecondaryIPv6Addresses is a list of extra IPv6 Addresses that the container has been assigned in this network.
    #[serde(rename = "SecondaryIPv6Addresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secondary_ipv6_addresses: Option<Vec<models::Address>>,

}


impl InspectNetworkSettings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectNetworkSettings {
        InspectNetworkSettings {
            additional_mac_addresses: None,
            bridge: None,
            endpoint_id: None,
            gateway: None,
            global_ipv6_address: None,
            global_ipv6_prefix_len: None,
            hairpin_mode: None,
            ip_address: None,
            ip_prefix_len: None,
            ipv6_gateway: None,
            link_local_ipv6_address: None,
            link_local_ipv6_prefix_len: None,
            mac_address: None,
            networks: None,
            ports: None,
            sandbox_id: None,
            sandbox_key: None,
            secondary_ip_addresses: None,
            secondary_ipv6_addresses: None,
        }
    }
}

/// Converts the InspectNetworkSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectNetworkSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.additional_mac_addresses.as_ref().map(|additional_mac_addresses| {
                [
                    "AdditionalMACAddresses".to_string(),
                    additional_mac_addresses.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.bridge.as_ref().map(|bridge| {
                [
                    "Bridge".to_string(),
                    bridge.to_string(),
                ].join(",")
            }),


            self.endpoint_id.as_ref().map(|endpoint_id| {
                [
                    "EndpointID".to_string(),
                    endpoint_id.to_string(),
                ].join(",")
            }),


            self.gateway.as_ref().map(|gateway| {
                [
                    "Gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),


            self.global_ipv6_address.as_ref().map(|global_ipv6_address| {
                [
                    "GlobalIPv6Address".to_string(),
                    global_ipv6_address.to_string(),
                ].join(",")
            }),


            self.global_ipv6_prefix_len.as_ref().map(|global_ipv6_prefix_len| {
                [
                    "GlobalIPv6PrefixLen".to_string(),
                    global_ipv6_prefix_len.to_string(),
                ].join(",")
            }),


            self.hairpin_mode.as_ref().map(|hairpin_mode| {
                [
                    "HairpinMode".to_string(),
                    hairpin_mode.to_string(),
                ].join(",")
            }),


            self.ip_address.as_ref().map(|ip_address| {
                [
                    "IPAddress".to_string(),
                    ip_address.to_string(),
                ].join(",")
            }),


            self.ip_prefix_len.as_ref().map(|ip_prefix_len| {
                [
                    "IPPrefixLen".to_string(),
                    ip_prefix_len.to_string(),
                ].join(",")
            }),


            self.ipv6_gateway.as_ref().map(|ipv6_gateway| {
                [
                    "IPv6Gateway".to_string(),
                    ipv6_gateway.to_string(),
                ].join(",")
            }),


            self.link_local_ipv6_address.as_ref().map(|link_local_ipv6_address| {
                [
                    "LinkLocalIPv6Address".to_string(),
                    link_local_ipv6_address.to_string(),
                ].join(",")
            }),


            self.link_local_ipv6_prefix_len.as_ref().map(|link_local_ipv6_prefix_len| {
                [
                    "LinkLocalIPv6PrefixLen".to_string(),
                    link_local_ipv6_prefix_len.to_string(),
                ].join(",")
            }),


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),

            // Skipping Networks in query parameter serialization
            // Skipping Networks in query parameter serialization

            // Skipping Ports in query parameter serialization
            // Skipping Ports in query parameter serialization


            self.sandbox_id.as_ref().map(|sandbox_id| {
                [
                    "SandboxID".to_string(),
                    sandbox_id.to_string(),
                ].join(",")
            }),


            self.sandbox_key.as_ref().map(|sandbox_key| {
                [
                    "SandboxKey".to_string(),
                    sandbox_key.to_string(),
                ].join(",")
            }),

            // Skipping SecondaryIPAddresses in query parameter serialization

            // Skipping SecondaryIPv6Addresses in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectNetworkSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectNetworkSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub additional_mac_addresses: Vec<Vec<String>>,
            pub bridge: Vec<String>,
            pub endpoint_id: Vec<String>,
            pub gateway: Vec<String>,
            pub global_ipv6_address: Vec<String>,
            pub global_ipv6_prefix_len: Vec<i64>,
            pub hairpin_mode: Vec<bool>,
            pub ip_address: Vec<String>,
            pub ip_prefix_len: Vec<i64>,
            pub ipv6_gateway: Vec<String>,
            pub link_local_ipv6_address: Vec<String>,
            pub link_local_ipv6_prefix_len: Vec<i64>,
            pub mac_address: Vec<String>,
            pub networks: Vec<std::collections::HashMap<String, models::InspectAdditionalNetwork>>,
            pub ports: Vec<std::collections::HashMap<String, Vec<models::InspectHostPort>>>,
            pub sandbox_id: Vec<String>,
            pub sandbox_key: Vec<String>,
            pub secondary_ip_addresses: Vec<Vec<models::Address>>,
            pub secondary_ipv6_addresses: Vec<Vec<models::Address>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectNetworkSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "AdditionalMACAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectNetworkSettings".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Bridge" => intermediate_rep.bridge.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "EndpointID" => intermediate_rep.endpoint_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6Address" => intermediate_rep.global_ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6PrefixLen" => intermediate_rep.global_ipv6_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HairpinMode" => intermediate_rep.hairpin_mode.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPAddress" => intermediate_rep.ip_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPPrefixLen" => intermediate_rep.ip_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv6Gateway" => intermediate_rep.ipv6_gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LinkLocalIPv6Address" => intermediate_rep.link_local_ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LinkLocalIPv6PrefixLen" => intermediate_rep.link_local_ipv6_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectNetworkSettings".to_string()),
                    "Ports" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectNetworkSettings".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SandboxID" => intermediate_rep.sandbox_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SandboxKey" => intermediate_rep.sandbox_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "SecondaryIPAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectNetworkSettings".to_string()),
                    "SecondaryIPv6Addresses" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectNetworkSettings".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectNetworkSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectNetworkSettings {
            additional_mac_addresses: intermediate_rep.additional_mac_addresses.into_iter().next(),
            bridge: intermediate_rep.bridge.into_iter().next(),
            endpoint_id: intermediate_rep.endpoint_id.into_iter().next(),
            gateway: intermediate_rep.gateway.into_iter().next(),
            global_ipv6_address: intermediate_rep.global_ipv6_address.into_iter().next(),
            global_ipv6_prefix_len: intermediate_rep.global_ipv6_prefix_len.into_iter().next(),
            hairpin_mode: intermediate_rep.hairpin_mode.into_iter().next(),
            ip_address: intermediate_rep.ip_address.into_iter().next(),
            ip_prefix_len: intermediate_rep.ip_prefix_len.into_iter().next(),
            ipv6_gateway: intermediate_rep.ipv6_gateway.into_iter().next(),
            link_local_ipv6_address: intermediate_rep.link_local_ipv6_address.into_iter().next(),
            link_local_ipv6_prefix_len: intermediate_rep.link_local_ipv6_prefix_len.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            networks: intermediate_rep.networks.into_iter().next(),
            ports: intermediate_rep.ports.into_iter().next(),
            sandbox_id: intermediate_rep.sandbox_id.into_iter().next(),
            sandbox_key: intermediate_rep.sandbox_key.into_iter().next(),
            secondary_ip_addresses: intermediate_rep.secondary_ip_addresses.into_iter().next(),
            secondary_ipv6_addresses: intermediate_rep.secondary_ipv6_addresses.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectNetworkSettings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectNetworkSettings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectNetworkSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectNetworkSettings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectNetworkSettings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectNetworkSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectNetworkSettings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectPodContainerInfo {
/// ID is the ID of the container.
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Name is the name of the container.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// State is the current status of the container.
    #[serde(rename = "State")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,

}


impl InspectPodContainerInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectPodContainerInfo {
        InspectPodContainerInfo {
            id: None,
            name: None,
            state: None,
        }
    }
}

/// Converts the InspectPodContainerInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectPodContainerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.state.as_ref().map(|state| {
                [
                    "State".to_string(),
                    state.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectPodContainerInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectPodContainerInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub state: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectPodContainerInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "State" => intermediate_rep.state.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectPodContainerInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectPodContainerInfo {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectPodContainerInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectPodContainerInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectPodContainerInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectPodContainerInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectPodContainerInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectPodContainerInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectPodContainerInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectPodData contains detailed information on a pod's configuration and state. It is used as the output of Inspect on pods.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectPodData {
/// CgroupParent is the parent of the pod's Cgroup.
    #[serde(rename = "CgroupParent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

/// CgroupPath is the path to the pod's Cgroup.
    #[serde(rename = "CgroupPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_path: Option<String>,

/// Containers gives a brief summary of all containers in the pod and their current status.
    #[serde(rename = "Containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<Vec<models::InspectPodContainerInfo>>,

/// CreateCgroup is whether this pod will create its own Cgroup to group containers under.
    #[serde(rename = "CreateCgroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_cgroup: Option<bool>,

/// CreateCommand is the full command plus arguments of the process the container has been created with.
    #[serde(rename = "CreateCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_command: Option<Vec<String>>,

/// CreateInfra is whether this pod will create an infra container to share namespaces.
    #[serde(rename = "CreateInfra")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_infra: Option<bool>,

/// Created is the time when the pod was created.
    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

/// ExitPolicy of the pod.
    #[serde(rename = "ExitPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_policy: Option<String>,

/// Hostname is the hostname that the pod will set.
    #[serde(rename = "Hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

/// ID is the ID of the pod.
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "InfraConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_config: Option<models::InspectPodInfraConfig>,

/// InfraContainerID is the ID of the pod's infra container, if one is present.
    #[serde(rename = "InfraContainerID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_container_id: Option<String>,

/// Labels is a set of key-value labels that have been applied to the pod.
    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// Number of the pod's Libpod lock.
    #[serde(rename = "LockNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_number: Option<i32>,

/// Name is the name of the pod.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Namespace is the Libpod namespace the pod is placed in.
    #[serde(rename = "Namespace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,

/// NumContainers is the number of containers in the pod, including the infra container.
    #[serde(rename = "NumContainers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub num_containers: Option<i32>,

/// RestartPolicy of the pod.
    #[serde(rename = "RestartPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<String>,

/// SharedNamespaces contains a list of namespaces that will be shared by containers within the pod. Can only be set if CreateInfra is true.
    #[serde(rename = "SharedNamespaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shared_namespaces: Option<Vec<String>>,

/// State represents the current state of the pod.
    #[serde(rename = "State")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,

/// BlkioWeight contains the blkio weight limit for the pod
    #[serde(rename = "blkio_weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight: Option<i32>,

/// BlkioWeightDevice contains the blkio weight device limits for the pod
    #[serde(rename = "blkio_weight_device")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight_device: Option<Vec<models::InspectBlkioWeightDevice>>,

/// CPUPeriod contains the CPU period of the pod
    #[serde(rename = "cpu_period")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i32>,

/// CPUQuota contains the CPU quota of the pod
    #[serde(rename = "cpu_quota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

/// CPUShares contains the cpu shares for the pod
    #[serde(rename = "cpu_shares")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_shares: Option<i32>,

/// CPUSetCPUs contains linux specific CPU data for the pod
    #[serde(rename = "cpuset_cpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

/// CPUSetMems contains linux specific CPU data for the pod
    #[serde(rename = "cpuset_mems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_mems: Option<String>,

/// BlkioDeviceReadBps contains the Read/Access limit for the pod's devices
    #[serde(rename = "device_read_bps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_read_bps: Option<Vec<models::InspectBlkioThrottleDevice>>,

/// BlkioDeviceReadBps contains the Read/Access limit for the pod's devices
    #[serde(rename = "device_write_bps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_write_bps: Option<Vec<models::InspectBlkioThrottleDevice>>,

/// Devices contains the specified host devices
    #[serde(rename = "devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::InspectDevice>>,

/// MemoryLimit contains the specified cgroup memory limit for the pod
    #[serde(rename = "memory_limit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_limit: Option<i32>,

/// MemorySwap contains the specified memory swap limit for the pod
    #[serde(rename = "memory_swap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swap: Option<i32>,

/// Mounts contains volume related information for the pod
    #[serde(rename = "mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::InspectMount>>,

/// SecurityOpt contains the specified security labels and related SELinux information
    #[serde(rename = "security_opt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_opt: Option<Vec<String>>,

/// VolumesFrom contains the containers that the pod inherits mounts from
    #[serde(rename = "volumes_from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

}


impl InspectPodData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectPodData {
        InspectPodData {
            cgroup_parent: None,
            cgroup_path: None,
            containers: None,
            create_cgroup: None,
            create_command: None,
            create_infra: None,
            created: None,
            exit_policy: None,
            hostname: None,
            id: None,
            infra_config: None,
            infra_container_id: None,
            labels: None,
            lock_number: None,
            name: None,
            namespace: None,
            num_containers: None,
            restart_policy: None,
            shared_namespaces: None,
            state: None,
            blkio_weight: None,
            blkio_weight_device: None,
            cpu_period: None,
            cpu_quota: None,
            cpu_shares: None,
            cpuset_cpus: None,
            cpuset_mems: None,
            device_read_bps: None,
            device_write_bps: None,
            devices: None,
            memory_limit: None,
            memory_swap: None,
            mounts: None,
            security_opt: None,
            volumes_from: None,
        }
    }
}

/// Converts the InspectPodData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectPodData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "CgroupParent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.cgroup_path.as_ref().map(|cgroup_path| {
                [
                    "CgroupPath".to_string(),
                    cgroup_path.to_string(),
                ].join(",")
            }),

            // Skipping Containers in query parameter serialization


            self.create_cgroup.as_ref().map(|create_cgroup| {
                [
                    "CreateCgroup".to_string(),
                    create_cgroup.to_string(),
                ].join(",")
            }),


            self.create_command.as_ref().map(|create_command| {
                [
                    "CreateCommand".to_string(),
                    create_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.create_infra.as_ref().map(|create_infra| {
                [
                    "CreateInfra".to_string(),
                    create_infra.to_string(),
                ].join(",")
            }),

            // Skipping Created in query parameter serialization


            self.exit_policy.as_ref().map(|exit_policy| {
                [
                    "ExitPolicy".to_string(),
                    exit_policy.to_string(),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "Hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping InfraConfig in query parameter serialization


            self.infra_container_id.as_ref().map(|infra_container_id| {
                [
                    "InfraContainerID".to_string(),
                    infra_container_id.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.lock_number.as_ref().map(|lock_number| {
                [
                    "LockNumber".to_string(),
                    lock_number.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.namespace.as_ref().map(|namespace| {
                [
                    "Namespace".to_string(),
                    namespace.to_string(),
                ].join(",")
            }),


            self.num_containers.as_ref().map(|num_containers| {
                [
                    "NumContainers".to_string(),
                    num_containers.to_string(),
                ].join(",")
            }),


            self.restart_policy.as_ref().map(|restart_policy| {
                [
                    "RestartPolicy".to_string(),
                    restart_policy.to_string(),
                ].join(",")
            }),


            self.shared_namespaces.as_ref().map(|shared_namespaces| {
                [
                    "SharedNamespaces".to_string(),
                    shared_namespaces.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.state.as_ref().map(|state| {
                [
                    "State".to_string(),
                    state.to_string(),
                ].join(",")
            }),


            self.blkio_weight.as_ref().map(|blkio_weight| {
                [
                    "blkio_weight".to_string(),
                    blkio_weight.to_string(),
                ].join(",")
            }),

            // Skipping blkio_weight_device in query parameter serialization


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "cpu_period".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "cpu_quota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.cpu_shares.as_ref().map(|cpu_shares| {
                [
                    "cpu_shares".to_string(),
                    cpu_shares.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "cpuset_cpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.cpuset_mems.as_ref().map(|cpuset_mems| {
                [
                    "cpuset_mems".to_string(),
                    cpuset_mems.to_string(),
                ].join(",")
            }),

            // Skipping device_read_bps in query parameter serialization

            // Skipping device_write_bps in query parameter serialization

            // Skipping devices in query parameter serialization


            self.memory_limit.as_ref().map(|memory_limit| {
                [
                    "memory_limit".to_string(),
                    memory_limit.to_string(),
                ].join(",")
            }),


            self.memory_swap.as_ref().map(|memory_swap| {
                [
                    "memory_swap".to_string(),
                    memory_swap.to_string(),
                ].join(",")
            }),

            // Skipping mounts in query parameter serialization


            self.security_opt.as_ref().map(|security_opt| {
                [
                    "security_opt".to_string(),
                    security_opt.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "volumes_from".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectPodData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectPodData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup_parent: Vec<String>,
            pub cgroup_path: Vec<String>,
            pub containers: Vec<Vec<models::InspectPodContainerInfo>>,
            pub create_cgroup: Vec<bool>,
            pub create_command: Vec<Vec<String>>,
            pub create_infra: Vec<bool>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub exit_policy: Vec<String>,
            pub hostname: Vec<String>,
            pub id: Vec<String>,
            pub infra_config: Vec<models::InspectPodInfraConfig>,
            pub infra_container_id: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub lock_number: Vec<i32>,
            pub name: Vec<String>,
            pub namespace: Vec<String>,
            pub num_containers: Vec<i32>,
            pub restart_policy: Vec<String>,
            pub shared_namespaces: Vec<Vec<String>>,
            pub state: Vec<String>,
            pub blkio_weight: Vec<i32>,
            pub blkio_weight_device: Vec<Vec<models::InspectBlkioWeightDevice>>,
            pub cpu_period: Vec<i32>,
            pub cpu_quota: Vec<i64>,
            pub cpu_shares: Vec<i32>,
            pub cpuset_cpus: Vec<String>,
            pub cpuset_mems: Vec<String>,
            pub device_read_bps: Vec<Vec<models::InspectBlkioThrottleDevice>>,
            pub device_write_bps: Vec<Vec<models::InspectBlkioThrottleDevice>>,
            pub devices: Vec<Vec<models::InspectDevice>>,
            pub memory_limit: Vec<i32>,
            pub memory_swap: Vec<i32>,
            pub mounts: Vec<Vec<models::InspectMount>>,
            pub security_opt: Vec<Vec<String>>,
            pub volumes_from: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectPodData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CgroupParent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CgroupPath" => intermediate_rep.cgroup_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Containers" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "CreateCgroup" => intermediate_rep.create_cgroup.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "CreateCommand" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "CreateInfra" => intermediate_rep.create_infra.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExitPolicy" => intermediate_rep.exit_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "InfraConfig" => intermediate_rep.infra_config.push(<models::InspectPodInfraConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "InfraContainerID" => intermediate_rep.infra_container_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "LockNumber" => intermediate_rep.lock_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Namespace" => intermediate_rep.namespace.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NumContainers" => intermediate_rep.num_containers.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestartPolicy" => intermediate_rep.restart_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "SharedNamespaces" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "State" => intermediate_rep.state.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "blkio_weight" => intermediate_rep.blkio_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "blkio_weight_device" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cpu_period" => intermediate_rep.cpu_period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpu_quota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpu_shares" => intermediate_rep.cpu_shares.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpuset_cpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpuset_mems" => intermediate_rep.cpuset_mems.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "device_read_bps" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    "device_write_bps" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    "devices" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "memory_limit" => intermediate_rep.memory_limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "memory_swap" => intermediate_rep.memory_swap.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    "security_opt" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    "volumes_from" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectPodData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectPodData {
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cgroup_path: intermediate_rep.cgroup_path.into_iter().next(),
            containers: intermediate_rep.containers.into_iter().next(),
            create_cgroup: intermediate_rep.create_cgroup.into_iter().next(),
            create_command: intermediate_rep.create_command.into_iter().next(),
            create_infra: intermediate_rep.create_infra.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            exit_policy: intermediate_rep.exit_policy.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            infra_config: intermediate_rep.infra_config.into_iter().next(),
            infra_container_id: intermediate_rep.infra_container_id.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            lock_number: intermediate_rep.lock_number.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            namespace: intermediate_rep.namespace.into_iter().next(),
            num_containers: intermediate_rep.num_containers.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            shared_namespaces: intermediate_rep.shared_namespaces.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
            blkio_weight: intermediate_rep.blkio_weight.into_iter().next(),
            blkio_weight_device: intermediate_rep.blkio_weight_device.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            cpu_shares: intermediate_rep.cpu_shares.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            cpuset_mems: intermediate_rep.cpuset_mems.into_iter().next(),
            device_read_bps: intermediate_rep.device_read_bps.into_iter().next(),
            device_write_bps: intermediate_rep.device_write_bps.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            memory_limit: intermediate_rep.memory_limit.into_iter().next(),
            memory_swap: intermediate_rep.memory_swap.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            security_opt: intermediate_rep.security_opt.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectPodData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectPodData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectPodData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectPodData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectPodData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectPodData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectPodData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectPodInfraConfig contains the configuration of the pod's infra container.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectPodInfraConfig {
/// DNSOption is a set of DNS options that will be used by the infra container's resolv.conf and shared with the remainder of the pod.
    #[serde(rename = "DNSOption")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_option: Option<Vec<String>>,

/// DNSSearch is a set of DNS search domains that will be used by the infra container's resolv.conf and shared with the remainder of the pod.
    #[serde(rename = "DNSSearch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

/// DNSServer is a set of DNS Servers that will be used by the infra container's resolv.conf and shared with the remainder of the pod.
    #[serde(rename = "DNSServer")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_server: Option<Vec<String>>,

/// HostAdd adds a number of hosts to the infra container's resolv.conf which will be shared with the rest of the pod.
    #[serde(rename = "HostAdd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_add: Option<Vec<String>>,

/// HostNetwork is whether the infra container (and thus the whole pod) will use the host's network and not create a network namespace.
    #[serde(rename = "HostNetwork")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_network: Option<bool>,

/// NetworkOptions are additional options for each network
    #[serde(rename = "NetworkOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_options: Option<std::collections::HashMap<String, Vec<String>>>,

/// Networks is a list of networks the pod will join.
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<Vec<String>>,

/// NoManageHosts indicates that the pod will not manage /etc/hosts and instead each container will handle their own.
    #[serde(rename = "NoManageHosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_manage_hosts: Option<bool>,

/// NoManageResolvConf indicates that the pod will not manage resolv.conf and instead each container will handle their own.
    #[serde(rename = "NoManageResolvConf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_manage_resolv_conf: Option<bool>,

/// PortBindings are ports that will be forwarded to the infra container and then shared with the pod.
    #[serde(rename = "PortBindings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub port_bindings: Option<std::collections::HashMap<String, Vec<models::InspectHostPort>>>,

/// StaticIP is a static IPv4 that will be assigned to the infra container and then used by the pod.
    #[serde(rename = "StaticIP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub static_ip: Option<String>,

/// StaticMAC is a static MAC address that will be assigned to the infra container and then used by the pod.
    #[serde(rename = "StaticMAC")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub static_mac: Option<String>,

/// CPUPeriod contains the CPU period of the pod
    #[serde(rename = "cpu_period")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i32>,

/// CPUQuota contains the CPU quota of the pod
    #[serde(rename = "cpu_quota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

/// CPUSetCPUs contains linux specific CPU data for the container
    #[serde(rename = "cpuset_cpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

/// Pid is the PID namespace mode of the pod's infra container
    #[serde(rename = "pid_ns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid_ns: Option<String>,

/// UserNS is the usernamespace that all the containers in the pod will join.
    #[serde(rename = "userns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub userns: Option<String>,

/// UtsNS is the uts namespace that all containers in the pod will join
    #[serde(rename = "uts_ns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uts_ns: Option<String>,

}


impl InspectPodInfraConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectPodInfraConfig {
        InspectPodInfraConfig {
            dns_option: None,
            dns_search: None,
            dns_server: None,
            host_add: None,
            host_network: None,
            network_options: None,
            networks: None,
            no_manage_hosts: None,
            no_manage_resolv_conf: None,
            port_bindings: None,
            static_ip: None,
            static_mac: None,
            cpu_period: None,
            cpu_quota: None,
            cpuset_cpus: None,
            pid_ns: None,
            userns: None,
            uts_ns: None,
        }
    }
}

/// Converts the InspectPodInfraConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectPodInfraConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.dns_option.as_ref().map(|dns_option| {
                [
                    "DNSOption".to_string(),
                    dns_option.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "DNSSearch".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_server.as_ref().map(|dns_server| {
                [
                    "DNSServer".to_string(),
                    dns_server.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.host_add.as_ref().map(|host_add| {
                [
                    "HostAdd".to_string(),
                    host_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.host_network.as_ref().map(|host_network| {
                [
                    "HostNetwork".to_string(),
                    host_network.to_string(),
                ].join(",")
            }),

            // Skipping NetworkOptions in query parameter serialization
            // Skipping NetworkOptions in query parameter serialization


            self.networks.as_ref().map(|networks| {
                [
                    "Networks".to_string(),
                    networks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.no_manage_hosts.as_ref().map(|no_manage_hosts| {
                [
                    "NoManageHosts".to_string(),
                    no_manage_hosts.to_string(),
                ].join(",")
            }),


            self.no_manage_resolv_conf.as_ref().map(|no_manage_resolv_conf| {
                [
                    "NoManageResolvConf".to_string(),
                    no_manage_resolv_conf.to_string(),
                ].join(",")
            }),

            // Skipping PortBindings in query parameter serialization
            // Skipping PortBindings in query parameter serialization


            self.static_ip.as_ref().map(|static_ip| {
                [
                    "StaticIP".to_string(),
                    static_ip.to_string(),
                ].join(",")
            }),


            self.static_mac.as_ref().map(|static_mac| {
                [
                    "StaticMAC".to_string(),
                    static_mac.to_string(),
                ].join(",")
            }),


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "cpu_period".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "cpu_quota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "cpuset_cpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.pid_ns.as_ref().map(|pid_ns| {
                [
                    "pid_ns".to_string(),
                    pid_ns.to_string(),
                ].join(",")
            }),


            self.userns.as_ref().map(|userns| {
                [
                    "userns".to_string(),
                    userns.to_string(),
                ].join(",")
            }),


            self.uts_ns.as_ref().map(|uts_ns| {
                [
                    "uts_ns".to_string(),
                    uts_ns.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectPodInfraConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectPodInfraConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dns_option: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub dns_server: Vec<Vec<String>>,
            pub host_add: Vec<Vec<String>>,
            pub host_network: Vec<bool>,
            pub network_options: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub networks: Vec<Vec<String>>,
            pub no_manage_hosts: Vec<bool>,
            pub no_manage_resolv_conf: Vec<bool>,
            pub port_bindings: Vec<std::collections::HashMap<String, Vec<models::InspectHostPort>>>,
            pub static_ip: Vec<String>,
            pub static_mac: Vec<String>,
            pub cpu_period: Vec<i32>,
            pub cpu_quota: Vec<i64>,
            pub cpuset_cpus: Vec<String>,
            pub pid_ns: Vec<String>,
            pub userns: Vec<String>,
            pub uts_ns: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectPodInfraConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "DNSOption" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodInfraConfig".to_string()),
                    "DNSSearch" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodInfraConfig".to_string()),
                    "DNSServer" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodInfraConfig".to_string()),
                    "HostAdd" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodInfraConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "HostNetwork" => intermediate_rep.host_network.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "NetworkOptions" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodInfraConfig".to_string()),
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodInfraConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "NoManageHosts" => intermediate_rep.no_manage_hosts.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NoManageResolvConf" => intermediate_rep.no_manage_resolv_conf.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "PortBindings" => return std::result::Result::Err("Parsing a container in this style is not supported in InspectPodInfraConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "StaticIP" => intermediate_rep.static_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StaticMAC" => intermediate_rep.static_mac.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpu_period" => intermediate_rep.cpu_period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpu_quota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpuset_cpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pid_ns" => intermediate_rep.pid_ns.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userns" => intermediate_rep.userns.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uts_ns" => intermediate_rep.uts_ns.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectPodInfraConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectPodInfraConfig {
            dns_option: intermediate_rep.dns_option.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            dns_server: intermediate_rep.dns_server.into_iter().next(),
            host_add: intermediate_rep.host_add.into_iter().next(),
            host_network: intermediate_rep.host_network.into_iter().next(),
            network_options: intermediate_rep.network_options.into_iter().next(),
            networks: intermediate_rep.networks.into_iter().next(),
            no_manage_hosts: intermediate_rep.no_manage_hosts.into_iter().next(),
            no_manage_resolv_conf: intermediate_rep.no_manage_resolv_conf.into_iter().next(),
            port_bindings: intermediate_rep.port_bindings.into_iter().next(),
            static_ip: intermediate_rep.static_ip.into_iter().next(),
            static_mac: intermediate_rep.static_mac.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            pid_ns: intermediate_rep.pid_ns.into_iter().next(),
            userns: intermediate_rep.userns.into_iter().next(),
            uts_ns: intermediate_rep.uts_ns.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectPodInfraConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectPodInfraConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectPodInfraConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectPodInfraConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectPodInfraConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectPodInfraConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectPodInfraConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectRestartPolicy {
/// MaximumRetryCount is the maximum number of retries allowed if the \"on-failure\" restart policy is in use. Not used if \"on-failure\" is not set.
    #[serde(rename = "MaximumRetryCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub maximum_retry_count: Option<i32>,

/// Name contains the container's restart policy. Allowable values are \"no\" or \"\" (take no action), \"on-failure\" (restart on non-zero exit code, with an optional max retry count), and \"always\" (always restart on container stop, unless explicitly requested by API). Note that this is NOT actually a name of any sort - the poor naming is for Docker compatibility.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl InspectRestartPolicy {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectRestartPolicy {
        InspectRestartPolicy {
            maximum_retry_count: None,
            name: None,
        }
    }
}

/// Converts the InspectRestartPolicy value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectRestartPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.maximum_retry_count.as_ref().map(|maximum_retry_count| {
                [
                    "MaximumRetryCount".to_string(),
                    maximum_retry_count.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectRestartPolicy value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectRestartPolicy {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub maximum_retry_count: Vec<i32>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectRestartPolicy".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "MaximumRetryCount" => intermediate_rep.maximum_retry_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectRestartPolicy".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectRestartPolicy {
            maximum_retry_count: intermediate_rep.maximum_retry_count.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectRestartPolicy> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectRestartPolicy>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectRestartPolicy>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectRestartPolicy - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectRestartPolicy> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectRestartPolicy as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectRestartPolicy - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// InspectSecret contains information on secrets mounted inside the container



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectSecret {
/// ID is the GID of the mounted secret file
    #[serde(rename = "GID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gid: Option<i32>,

/// ID is the ID of the secret
    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// ID is the ID of the mode of the mounted secret file
    #[serde(rename = "Mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<i32>,

/// Name is the name of the secret
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// ID is the UID of the mounted secret file
    #[serde(rename = "UID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid: Option<i32>,

}


impl InspectSecret {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectSecret {
        InspectSecret {
            gid: None,
            id: None,
            mode: None,
            name: None,
            uid: None,
        }
    }
}

/// Converts the InspectSecret value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.gid.as_ref().map(|gid| {
                [
                    "GID".to_string(),
                    gid.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "Mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.uid.as_ref().map(|uid| {
                [
                    "UID".to_string(),
                    uid.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectSecret value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectSecret {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gid: Vec<i32>,
            pub id: Vec<String>,
            pub mode: Vec<i32>,
            pub name: Vec<String>,
            pub uid: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectSecret".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GID" => intermediate_rep.gid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Mode" => intermediate_rep.mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UID" => intermediate_rep.uid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectSecret".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectSecret {
            gid: intermediate_rep.gid.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            uid: intermediate_rep.uid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectSecret> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectSecret>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectSecret>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectSecret - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectSecret> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectSecret as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectSecret - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InspectUlimit {
/// Hard is the hard limit that will be applied.
    #[serde(rename = "Hard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hard: Option<i64>,

/// Name is the name (type) of the ulimit.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Soft is the soft limit that will be applied.
    #[serde(rename = "Soft")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub soft: Option<i64>,

}


impl InspectUlimit {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InspectUlimit {
        InspectUlimit {
            hard: None,
            name: None,
            soft: None,
        }
    }
}

/// Converts the InspectUlimit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InspectUlimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.hard.as_ref().map(|hard| {
                [
                    "Hard".to_string(),
                    hard.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.soft.as_ref().map(|soft| {
                [
                    "Soft".to_string(),
                    soft.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InspectUlimit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InspectUlimit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hard: Vec<i64>,
            pub name: Vec<String>,
            pub soft: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InspectUlimit".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Hard" => intermediate_rep.hard.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Soft" => intermediate_rep.soft.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InspectUlimit".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InspectUlimit {
            hard: intermediate_rep.hard.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            soft: intermediate_rep.soft.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InspectUlimit> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InspectUlimit>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InspectUlimit>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for InspectUlimit - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InspectUlimit> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InspectUlimit as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into InspectUlimit - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpNet {
    #[serde(rename = "IP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip: Option<String>,

/// See type [IPNet] and func [ParseCIDR] for details.
    #[serde(rename = "Mask")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mask: Option<Vec<i32>>,

}


impl IpNet {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IpNet {
        IpNet {
            ip: None,
            mask: None,
        }
    }
}

/// Converts the IpNet value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IpNet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ip.as_ref().map(|ip| {
                [
                    "IP".to_string(),
                    ip.to_string(),
                ].join(",")
            }),


            self.mask.as_ref().map(|mask| {
                [
                    "Mask".to_string(),
                    mask.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpNet value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpNet {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ip: Vec<String>,
            pub mask: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IpNet".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IP" => intermediate_rep.ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Mask" => return std::result::Result::Err("Parsing a container in this style is not supported in IpNet".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing IpNet".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpNet {
            ip: intermediate_rep.ip.into_iter().next(),
            mask: intermediate_rep.mask.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IpNet> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IpNet>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IpNet>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IpNet - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IpNet> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IpNet as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IpNet - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// IPAM represents IP Address Management



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ipam {
    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<Vec<models::IpamConfig>>,

    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

}


impl Ipam {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Ipam {
        Ipam {
            config: None,
            driver: None,
            options: None,
        }
    }
}

/// Converts the Ipam value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Ipam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Config in query parameter serialization


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ipam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ipam {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config: Vec<Vec<models::IpamConfig>>,
            pub driver: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Ipam".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Config" => return std::result::Result::Err("Parsing a container in this style is not supported in Ipam".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in Ipam".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Ipam".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ipam {
            config: intermediate_rep.config.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ipam> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Ipam>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Ipam>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Ipam - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Ipam> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Ipam as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Ipam - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// IPAMConfig represents IPAM configurations



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpamConfig {
    #[serde(rename = "AuxiliaryAddresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auxiliary_addresses: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

    #[serde(rename = "IPRange")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_range: Option<String>,

    #[serde(rename = "Subnet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subnet: Option<String>,

}


impl IpamConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> IpamConfig {
        IpamConfig {
            auxiliary_addresses: None,
            gateway: None,
            ip_range: None,
            subnet: None,
        }
    }
}

/// Converts the IpamConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for IpamConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping AuxiliaryAddresses in query parameter serialization


            self.gateway.as_ref().map(|gateway| {
                [
                    "Gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),


            self.ip_range.as_ref().map(|ip_range| {
                [
                    "IPRange".to_string(),
                    ip_range.to_string(),
                ].join(",")
            }),


            self.subnet.as_ref().map(|subnet| {
                [
                    "Subnet".to_string(),
                    subnet.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a IpamConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for IpamConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auxiliary_addresses: Vec<std::collections::HashMap<String, String>>,
            pub gateway: Vec<String>,
            pub ip_range: Vec<String>,
            pub subnet: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing IpamConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "AuxiliaryAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in IpamConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPRange" => intermediate_rep.ip_range.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Subnet" => intermediate_rep.subnet.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing IpamConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(IpamConfig {
            auxiliary_addresses: intermediate_rep.auxiliary_addresses.into_iter().next(),
            gateway: intermediate_rep.gateway.into_iter().next(),
            ip_range: intermediate_rep.ip_range.into_iter().next(),
            subnet: intermediate_rep.subnet.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<IpamConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<IpamConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<IpamConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for IpamConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<IpamConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <IpamConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into IpamConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct IpcMode(String);

impl validator::Validate for IpcMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for IpcMode {
    fn from(x: String) -> Self {
        IpcMode(x)
    }
}

impl std::fmt::Display for IpcMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for IpcMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(IpcMode(x.to_string()))
    }
}

impl std::convert::From<IpcMode> for String {
    fn from(x: IpcMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for IpcMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for IpcMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// Isolation represents the isolation technology of a container. The supported values are platform specific
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Isolation(String);

impl validator::Validate for Isolation {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Isolation {
    fn from(x: String) -> Self {
        Isolation(x)
    }
}

impl std::fmt::Display for Isolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for Isolation {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Isolation(x.to_string()))
    }
}

impl std::convert::From<Isolation> for String {
    fn from(x: Isolation) -> Self {
        x.0
    }
}

impl std::ops::Deref for Isolation {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Isolation {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LeaseRange {
/// EndIP last IP in the subnet which should be used to assign ips.
    #[serde(rename = "end_ip")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_ip: Option<String>,

/// StartIP first IP in the subnet which should be used to assign ips.
    #[serde(rename = "start_ip")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_ip: Option<String>,

}


impl LeaseRange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LeaseRange {
        LeaseRange {
            end_ip: None,
            start_ip: None,
        }
    }
}

/// Converts the LeaseRange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LeaseRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.end_ip.as_ref().map(|end_ip| {
                [
                    "end_ip".to_string(),
                    end_ip.to_string(),
                ].join(",")
            }),


            self.start_ip.as_ref().map(|start_ip| {
                [
                    "start_ip".to_string(),
                    start_ip.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LeaseRange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LeaseRange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub end_ip: Vec<String>,
            pub start_ip: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LeaseRange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "end_ip" => intermediate_rep.end_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_ip" => intermediate_rep.start_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LeaseRange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LeaseRange {
            end_ip: intermediate_rep.end_ip.into_iter().next(),
            start_ip: intermediate_rep.start_ip.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LeaseRange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LeaseRange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LeaseRange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LeaseRange - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LeaseRange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LeaseRange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LeaseRange - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LibpodContainersRmReport {
/// Error which occurred during Rm operation (if any). This field is optional and may be omitted if no error occurred.
    #[serde(rename = "Err")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub err: Option<Nullable<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl LibpodContainersRmReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LibpodContainersRmReport {
        LibpodContainersRmReport {
            err: None,
            id: None,
        }
    }
}

/// Converts the LibpodContainersRmReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LibpodContainersRmReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.err.as_ref().map(|err| {
                [
                    "Err".to_string(),
                    err.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LibpodContainersRmReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LibpodContainersRmReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub err: Vec<String>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LibpodContainersRmReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Err" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in LibpodContainersRmReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LibpodContainersRmReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LibpodContainersRmReport {
            err: std::result::Result::Err("Nullable types not supported in LibpodContainersRmReport".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LibpodContainersRmReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LibpodContainersRmReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LibpodContainersRmReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LibpodContainersRmReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LibpodContainersRmReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LibpodContainersRmReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LibpodContainersRmReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate, Default)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LibpodImageSummary {
/// Podman extensions
    #[serde(rename = "Arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arch: Option<String>,

    #[serde(rename = "Containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<i64>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<i64>,

    #[serde(rename = "Dangling")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dangling: Option<bool>,

    #[serde(rename = "Digest")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub digest: Option<String>,

    #[serde(rename = "History")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub history: Option<Vec<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// IsManifestList is a ptr so we can distinguish between a true json empty response and false.  the docker compat side needs to return empty; where as the libpod side needs a value of true or false
    #[serde(rename = "IsManifestList")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_manifest_list: Option<bool>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Names")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub names: Option<Vec<String>>,

    #[serde(rename = "Os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

    #[serde(rename = "ParentId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_id: Option<String>,

    #[serde(rename = "ReadOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

    #[serde(rename = "RepoDigests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo_digests: Option<Vec<String>>,

    #[serde(rename = "RepoTags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo_tags: Option<Vec<String>>,

    #[serde(rename = "SharedSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shared_size: Option<i64>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

    #[serde(rename = "VirtualSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub virtual_size: Option<i64>,

}


impl LibpodImageSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LibpodImageSummary {
        LibpodImageSummary {
            arch: None,
            containers: None,
            created: None,
            dangling: None,
            digest: None,
            history: None,
            id: None,
            is_manifest_list: None,
            labels: None,
            names: None,
            os: None,
            parent_id: None,
            read_only: None,
            repo_digests: None,
            repo_tags: None,
            shared_size: None,
            size: None,
            virtual_size: None,
        }
    }
}

/// Converts the LibpodImageSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LibpodImageSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.arch.as_ref().map(|arch| {
                [
                    "Arch".to_string(),
                    arch.to_string(),
                ].join(",")
            }),


            self.containers.as_ref().map(|containers| {
                [
                    "Containers".to_string(),
                    containers.to_string(),
                ].join(",")
            }),


            self.created.as_ref().map(|created| {
                [
                    "Created".to_string(),
                    created.to_string(),
                ].join(",")
            }),


            self.dangling.as_ref().map(|dangling| {
                [
                    "Dangling".to_string(),
                    dangling.to_string(),
                ].join(",")
            }),


            self.digest.as_ref().map(|digest| {
                [
                    "Digest".to_string(),
                    digest.to_string(),
                ].join(",")
            }),


            self.history.as_ref().map(|history| {
                [
                    "History".to_string(),
                    history.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.is_manifest_list.as_ref().map(|is_manifest_list| {
                [
                    "IsManifestList".to_string(),
                    is_manifest_list.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.names.as_ref().map(|names| {
                [
                    "Names".to_string(),
                    names.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os.as_ref().map(|os| {
                [
                    "Os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.parent_id.as_ref().map(|parent_id| {
                [
                    "ParentId".to_string(),
                    parent_id.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "ReadOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.repo_digests.as_ref().map(|repo_digests| {
                [
                    "RepoDigests".to_string(),
                    repo_digests.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.repo_tags.as_ref().map(|repo_tags| {
                [
                    "RepoTags".to_string(),
                    repo_tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.shared_size.as_ref().map(|shared_size| {
                [
                    "SharedSize".to_string(),
                    shared_size.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.virtual_size.as_ref().map(|virtual_size| {
                [
                    "VirtualSize".to_string(),
                    virtual_size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LibpodImageSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LibpodImageSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub arch: Vec<String>,
            pub containers: Vec<i64>,
            pub created: Vec<i64>,
            pub dangling: Vec<bool>,
            pub digest: Vec<String>,
            pub history: Vec<Vec<String>>,
            pub id: Vec<String>,
            pub is_manifest_list: Vec<bool>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub names: Vec<Vec<String>>,
            pub os: Vec<String>,
            pub parent_id: Vec<String>,
            pub read_only: Vec<bool>,
            pub repo_digests: Vec<Vec<String>>,
            pub repo_tags: Vec<Vec<String>>,
            pub shared_size: Vec<i64>,
            pub size: Vec<i64>,
            pub virtual_size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LibpodImageSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Arch" => intermediate_rep.arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Containers" => intermediate_rep.containers.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Dangling" => intermediate_rep.dangling.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Digest" => intermediate_rep.digest.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "History" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImageSummary".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IsManifestList" => intermediate_rep.is_manifest_list.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImageSummary".to_string()),
                    "Names" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImageSummary".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ParentId" => intermediate_rep.parent_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ReadOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "RepoDigests" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImageSummary".to_string()),
                    "RepoTags" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImageSummary".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SharedSize" => intermediate_rep.shared_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VirtualSize" => intermediate_rep.virtual_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LibpodImageSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LibpodImageSummary {
            arch: intermediate_rep.arch.into_iter().next(),
            containers: intermediate_rep.containers.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            dangling: intermediate_rep.dangling.into_iter().next(),
            digest: intermediate_rep.digest.into_iter().next(),
            history: intermediate_rep.history.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            is_manifest_list: intermediate_rep.is_manifest_list.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            names: intermediate_rep.names.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            parent_id: intermediate_rep.parent_id.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            repo_digests: intermediate_rep.repo_digests.into_iter().next(),
            repo_tags: intermediate_rep.repo_tags.into_iter().next(),
            shared_size: intermediate_rep.shared_size.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            virtual_size: intermediate_rep.virtual_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LibpodImageSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LibpodImageSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LibpodImageSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LibpodImageSummary - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LibpodImageSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LibpodImageSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LibpodImageSummary - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LibpodImagesPullReport {
/// Error contains text of errors from c/image
    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,

/// ID contains image id (retained for backwards compatibility)
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Images contains the ID's of the images pulled
    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<Vec<String>>,

/// Stream used to provide output from c/image
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<String>,

}


impl LibpodImagesPullReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LibpodImagesPullReport {
        LibpodImagesPullReport {
            error: None,
            id: None,
            images: None,
            stream: None,
        }
    }
}

/// Converts the LibpodImagesPullReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LibpodImagesPullReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.error.as_ref().map(|error| {
                [
                    "error".to_string(),
                    error.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.images.as_ref().map(|images| {
                [
                    "images".to_string(),
                    images.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LibpodImagesPullReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LibpodImagesPullReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<String>,
            pub id: Vec<String>,
            pub images: Vec<Vec<String>>,
            pub stream: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LibpodImagesPullReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "images" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImagesPullReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "stream" => intermediate_rep.stream.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LibpodImagesPullReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LibpodImagesPullReport {
            error: intermediate_rep.error.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            images: intermediate_rep.images.into_iter().next(),
            stream: intermediate_rep.stream.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LibpodImagesPullReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LibpodImagesPullReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LibpodImagesPullReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LibpodImagesPullReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LibpodImagesPullReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LibpodImagesPullReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LibpodImagesPullReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LibpodImagesRemoveReport is the return type for image removal via the rest api.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LibpodImagesRemoveReport {
/// Deleted images.
    #[serde(rename = "Deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<Vec<String>>,

/// Image removal requires is to return data and an error.
    #[serde(rename = "Errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<String>>,

/// ExitCode describes the exit codes as described in the `podman rmi` man page.
    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i64>,

/// Untagged images. Can be longer than Deleted.
    #[serde(rename = "Untagged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub untagged: Option<Vec<String>>,

}


impl LibpodImagesRemoveReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LibpodImagesRemoveReport {
        LibpodImagesRemoveReport {
            deleted: None,
            errors: None,
            exit_code: None,
            untagged: None,
        }
    }
}

/// Converts the LibpodImagesRemoveReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LibpodImagesRemoveReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.deleted.as_ref().map(|deleted| {
                [
                    "Deleted".to_string(),
                    deleted.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.errors.as_ref().map(|errors| {
                [
                    "Errors".to_string(),
                    errors.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),


            self.untagged.as_ref().map(|untagged| {
                [
                    "Untagged".to_string(),
                    untagged.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LibpodImagesRemoveReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LibpodImagesRemoveReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub deleted: Vec<Vec<String>>,
            pub errors: Vec<Vec<String>>,
            pub exit_code: Vec<i64>,
            pub untagged: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LibpodImagesRemoveReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Deleted" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImagesRemoveReport".to_string()),
                    "Errors" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImagesRemoveReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Untagged" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodImagesRemoveReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LibpodImagesRemoveReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LibpodImagesRemoveReport {
            deleted: intermediate_rep.deleted.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            untagged: intermediate_rep.untagged.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LibpodImagesRemoveReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LibpodImagesRemoveReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LibpodImagesRemoveReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LibpodImagesRemoveReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LibpodImagesRemoveReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LibpodImagesRemoveReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LibpodImagesRemoveReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Info is the overall struct that describes the host system running libpod/podman



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LibpodInfo {
    #[serde(rename = "host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host: Option<models::HostInfo>,

    #[serde(rename = "plugins")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plugins: Option<models::Plugins>,

    #[serde(rename = "registries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub registries: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "store")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub store: Option<models::StoreInfo>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<models::Version>,

}


impl LibpodInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LibpodInfo {
        LibpodInfo {
            host: None,
            plugins: None,
            registries: None,
            store: None,
            version: None,
        }
    }
}

/// Converts the LibpodInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LibpodInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping host in query parameter serialization

            // Skipping plugins in query parameter serialization

            // Skipping registries in query parameter serialization
            // Skipping registries in query parameter serialization

            // Skipping store in query parameter serialization

            // Skipping version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LibpodInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LibpodInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub host: Vec<models::HostInfo>,
            pub plugins: Vec<models::Plugins>,
            pub registries: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub store: Vec<models::StoreInfo>,
            pub version: Vec<models::Version>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LibpodInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "host" => intermediate_rep.host.push(<models::HostInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "plugins" => intermediate_rep.plugins.push(<models::Plugins as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "registries" => return std::result::Result::Err("Parsing a container in this style is not supported in LibpodInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "store" => intermediate_rep.store.push(<models::StoreInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<models::Version as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LibpodInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LibpodInfo {
            host: intermediate_rep.host.into_iter().next(),
            plugins: intermediate_rep.plugins.into_iter().next(),
            registries: intermediate_rep.registries.into_iter().next(),
            store: intermediate_rep.store.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LibpodInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LibpodInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LibpodInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LibpodInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LibpodInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LibpodInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LibpodInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxBlockIO for Linux cgroup 'blkio' resource management



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxBlockIo {
/// Specifies tasks' weight in the given cgroup while competing with the cgroup's child cgroups, CFQ scheduler only
    #[serde(rename = "leafWeight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub leaf_weight: Option<i32>,

/// IO read rate limit per cgroup per device, bytes per second
    #[serde(rename = "throttleReadBpsDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_read_bps_device: Option<Vec<models::LinuxThrottleDevice>>,

/// IO read rate limit per cgroup per device, IO per second
    #[serde(rename = "throttleReadIOPSDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_read_iops_device: Option<Vec<models::LinuxThrottleDevice>>,

/// IO write rate limit per cgroup per device, bytes per second
    #[serde(rename = "throttleWriteBpsDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_write_bps_device: Option<Vec<models::LinuxThrottleDevice>>,

/// IO write rate limit per cgroup per device, IO per second
    #[serde(rename = "throttleWriteIOPSDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_write_iops_device: Option<Vec<models::LinuxThrottleDevice>>,

/// Specifies per cgroup weight
    #[serde(rename = "weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<i32>,

/// Weight per cgroup per device, can override BlkioWeight
    #[serde(rename = "weightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_device: Option<Vec<models::LinuxWeightDevice>>,

}


impl LinuxBlockIo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxBlockIo {
        LinuxBlockIo {
            leaf_weight: None,
            throttle_read_bps_device: None,
            throttle_read_iops_device: None,
            throttle_write_bps_device: None,
            throttle_write_iops_device: None,
            weight: None,
            weight_device: None,
        }
    }
}

/// Converts the LinuxBlockIo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxBlockIo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.leaf_weight.as_ref().map(|leaf_weight| {
                [
                    "leafWeight".to_string(),
                    leaf_weight.to_string(),
                ].join(",")
            }),

            // Skipping throttleReadBpsDevice in query parameter serialization

            // Skipping throttleReadIOPSDevice in query parameter serialization

            // Skipping throttleWriteBpsDevice in query parameter serialization

            // Skipping throttleWriteIOPSDevice in query parameter serialization


            self.weight.as_ref().map(|weight| {
                [
                    "weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

            // Skipping weightDevice in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxBlockIo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxBlockIo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub leaf_weight: Vec<i32>,
            pub throttle_read_bps_device: Vec<Vec<models::LinuxThrottleDevice>>,
            pub throttle_read_iops_device: Vec<Vec<models::LinuxThrottleDevice>>,
            pub throttle_write_bps_device: Vec<Vec<models::LinuxThrottleDevice>>,
            pub throttle_write_iops_device: Vec<Vec<models::LinuxThrottleDevice>>,
            pub weight: Vec<i32>,
            pub weight_device: Vec<Vec<models::LinuxWeightDevice>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxBlockIo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "leafWeight" => intermediate_rep.leaf_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "throttleReadBpsDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxBlockIo".to_string()),
                    "throttleReadIOPSDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxBlockIo".to_string()),
                    "throttleWriteBpsDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxBlockIo".to_string()),
                    "throttleWriteIOPSDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxBlockIo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "weightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxBlockIo".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxBlockIo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxBlockIo {
            leaf_weight: intermediate_rep.leaf_weight.into_iter().next(),
            throttle_read_bps_device: intermediate_rep.throttle_read_bps_device.into_iter().next(),
            throttle_read_iops_device: intermediate_rep.throttle_read_iops_device.into_iter().next(),
            throttle_write_bps_device: intermediate_rep.throttle_write_bps_device.into_iter().next(),
            throttle_write_iops_device: intermediate_rep.throttle_write_iops_device.into_iter().next(),
            weight: intermediate_rep.weight.into_iter().next(),
            weight_device: intermediate_rep.weight_device.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxBlockIo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxBlockIo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxBlockIo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxBlockIo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxBlockIo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxBlockIo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxBlockIo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxBlockIODevice holds major:minor format supported in blkio cgroup



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxBlockIoDevice {
/// Major is the device's major number.
    #[serde(rename = "major")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<i64>,

/// Minor is the device's minor number.
    #[serde(rename = "minor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub minor: Option<i64>,

}


impl LinuxBlockIoDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxBlockIoDevice {
        LinuxBlockIoDevice {
            major: None,
            minor: None,
        }
    }
}

/// Converts the LinuxBlockIoDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxBlockIoDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.major.as_ref().map(|major| {
                [
                    "major".to_string(),
                    major.to_string(),
                ].join(",")
            }),


            self.minor.as_ref().map(|minor| {
                [
                    "minor".to_string(),
                    minor.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxBlockIoDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxBlockIoDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub major: Vec<i64>,
            pub minor: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxBlockIoDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "major" => intermediate_rep.major.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "minor" => intermediate_rep.minor.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxBlockIoDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxBlockIoDevice {
            major: intermediate_rep.major.into_iter().next(),
            minor: intermediate_rep.minor.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxBlockIoDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxBlockIoDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxBlockIoDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxBlockIoDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxBlockIoDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxBlockIoDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxBlockIoDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxCPU for Linux cgroup 'cpu' resource management



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxCpu {
/// CPU hardcap burst limit (in usecs). Allowed accumulated cpu time additionally for burst in a given period.
    #[serde(rename = "burst")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub burst: Option<i32>,

/// CPUs to use within the cpuset. Default is to use any CPU available.
    #[serde(rename = "cpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpus: Option<String>,

/// cgroups are configured with minimum weight, 0: default behavior, 1: SCHED_IDLE.
    #[serde(rename = "idle")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle: Option<i64>,

/// List of memory nodes in the cpuset. Default is to use any available memory node.
    #[serde(rename = "mems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mems: Option<String>,

/// CPU period to be used for hardcapping (in usecs).
    #[serde(rename = "period")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub period: Option<i32>,

/// CPU hardcap limit (in usecs). Allowed cpu time in a given period.
    #[serde(rename = "quota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quota: Option<i64>,

/// CPU period to be used for realtime scheduling (in usecs).
    #[serde(rename = "realtimePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub realtime_period: Option<i32>,

/// How much time realtime scheduling may use (in usecs).
    #[serde(rename = "realtimeRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub realtime_runtime: Option<i64>,

/// CPU shares (relative weight (ratio) vs. other cgroups with cpu shares).
    #[serde(rename = "shares")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shares: Option<i32>,

}


impl LinuxCpu {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxCpu {
        LinuxCpu {
            burst: None,
            cpus: None,
            idle: None,
            mems: None,
            period: None,
            quota: None,
            realtime_period: None,
            realtime_runtime: None,
            shares: None,
        }
    }
}

/// Converts the LinuxCpu value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxCpu {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.burst.as_ref().map(|burst| {
                [
                    "burst".to_string(),
                    burst.to_string(),
                ].join(",")
            }),


            self.cpus.as_ref().map(|cpus| {
                [
                    "cpus".to_string(),
                    cpus.to_string(),
                ].join(",")
            }),


            self.idle.as_ref().map(|idle| {
                [
                    "idle".to_string(),
                    idle.to_string(),
                ].join(",")
            }),


            self.mems.as_ref().map(|mems| {
                [
                    "mems".to_string(),
                    mems.to_string(),
                ].join(",")
            }),


            self.period.as_ref().map(|period| {
                [
                    "period".to_string(),
                    period.to_string(),
                ].join(",")
            }),


            self.quota.as_ref().map(|quota| {
                [
                    "quota".to_string(),
                    quota.to_string(),
                ].join(",")
            }),


            self.realtime_period.as_ref().map(|realtime_period| {
                [
                    "realtimePeriod".to_string(),
                    realtime_period.to_string(),
                ].join(",")
            }),


            self.realtime_runtime.as_ref().map(|realtime_runtime| {
                [
                    "realtimeRuntime".to_string(),
                    realtime_runtime.to_string(),
                ].join(",")
            }),


            self.shares.as_ref().map(|shares| {
                [
                    "shares".to_string(),
                    shares.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxCpu value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxCpu {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub burst: Vec<i32>,
            pub cpus: Vec<String>,
            pub idle: Vec<i64>,
            pub mems: Vec<String>,
            pub period: Vec<i32>,
            pub quota: Vec<i64>,
            pub realtime_period: Vec<i32>,
            pub realtime_runtime: Vec<i64>,
            pub shares: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxCpu".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "burst" => intermediate_rep.burst.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpus" => intermediate_rep.cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "idle" => intermediate_rep.idle.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mems" => intermediate_rep.mems.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "period" => intermediate_rep.period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quota" => intermediate_rep.quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "realtimePeriod" => intermediate_rep.realtime_period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "realtimeRuntime" => intermediate_rep.realtime_runtime.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shares" => intermediate_rep.shares.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxCpu".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxCpu {
            burst: intermediate_rep.burst.into_iter().next(),
            cpus: intermediate_rep.cpus.into_iter().next(),
            idle: intermediate_rep.idle.into_iter().next(),
            mems: intermediate_rep.mems.into_iter().next(),
            period: intermediate_rep.period.into_iter().next(),
            quota: intermediate_rep.quota.into_iter().next(),
            realtime_period: intermediate_rep.realtime_period.into_iter().next(),
            realtime_runtime: intermediate_rep.realtime_runtime.into_iter().next(),
            shares: intermediate_rep.shares.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxCpu> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxCpu>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxCpu>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxCpu - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxCpu> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxCpu as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxCpu - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxDevice represents the mknod information for a Linux special device file



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxDevice {
/// The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is [ModeDir] for directories.
    #[serde(rename = "fileMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_mode: Option<i32>,

/// Gid of the device.
    #[serde(rename = "gid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gid: Option<i32>,

/// Major is the device's major number.
    #[serde(rename = "major")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<i64>,

/// Minor is the device's minor number.
    #[serde(rename = "minor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub minor: Option<i64>,

/// Path to the device.
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// Device type, block, char, etc.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// UID of the device.
    #[serde(rename = "uid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid: Option<i32>,

}


impl LinuxDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxDevice {
        LinuxDevice {
            file_mode: None,
            gid: None,
            major: None,
            minor: None,
            path: None,
            r#type: None,
            uid: None,
        }
    }
}

/// Converts the LinuxDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_mode.as_ref().map(|file_mode| {
                [
                    "fileMode".to_string(),
                    file_mode.to_string(),
                ].join(",")
            }),


            self.gid.as_ref().map(|gid| {
                [
                    "gid".to_string(),
                    gid.to_string(),
                ].join(",")
            }),


            self.major.as_ref().map(|major| {
                [
                    "major".to_string(),
                    major.to_string(),
                ].join(",")
            }),


            self.minor.as_ref().map(|minor| {
                [
                    "minor".to_string(),
                    minor.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.uid.as_ref().map(|uid| {
                [
                    "uid".to_string(),
                    uid.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_mode: Vec<i32>,
            pub gid: Vec<i32>,
            pub major: Vec<i64>,
            pub minor: Vec<i64>,
            pub path: Vec<String>,
            pub r#type: Vec<String>,
            pub uid: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "fileMode" => intermediate_rep.file_mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gid" => intermediate_rep.gid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "major" => intermediate_rep.major.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "minor" => intermediate_rep.minor.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "uid" => intermediate_rep.uid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxDevice {
            file_mode: intermediate_rep.file_mode.into_iter().next(),
            gid: intermediate_rep.gid.into_iter().next(),
            major: intermediate_rep.major.into_iter().next(),
            minor: intermediate_rep.minor.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            uid: intermediate_rep.uid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxDeviceCgroup represents a device rule for the devices specified to the device controller



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxDeviceCgroup {
/// Cgroup access permissions format, rwm.
    #[serde(rename = "access")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub access: Option<String>,

/// Allow or deny
    #[serde(rename = "allow")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow: Option<bool>,

/// Major is the device's major number.
    #[serde(rename = "major")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<i64>,

/// Minor is the device's minor number.
    #[serde(rename = "minor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub minor: Option<i64>,

/// Device type, block, char, etc.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl LinuxDeviceCgroup {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxDeviceCgroup {
        LinuxDeviceCgroup {
            access: None,
            allow: None,
            major: None,
            minor: None,
            r#type: None,
        }
    }
}

/// Converts the LinuxDeviceCgroup value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxDeviceCgroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.access.as_ref().map(|access| {
                [
                    "access".to_string(),
                    access.to_string(),
                ].join(",")
            }),


            self.allow.as_ref().map(|allow| {
                [
                    "allow".to_string(),
                    allow.to_string(),
                ].join(",")
            }),


            self.major.as_ref().map(|major| {
                [
                    "major".to_string(),
                    major.to_string(),
                ].join(",")
            }),


            self.minor.as_ref().map(|minor| {
                [
                    "minor".to_string(),
                    minor.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxDeviceCgroup value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxDeviceCgroup {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub access: Vec<String>,
            pub allow: Vec<bool>,
            pub major: Vec<i64>,
            pub minor: Vec<i64>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxDeviceCgroup".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "access" => intermediate_rep.access.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "allow" => intermediate_rep.allow.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "major" => intermediate_rep.major.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "minor" => intermediate_rep.minor.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxDeviceCgroup".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxDeviceCgroup {
            access: intermediate_rep.access.into_iter().next(),
            allow: intermediate_rep.allow.into_iter().next(),
            major: intermediate_rep.major.into_iter().next(),
            minor: intermediate_rep.minor.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxDeviceCgroup> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxDeviceCgroup>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxDeviceCgroup>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxDeviceCgroup - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxDeviceCgroup> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxDeviceCgroup as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxDeviceCgroup - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Default to reservation limits if supported. Otherwise fallback to page fault limits.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxHugepageLimit {
/// Limit is the limit of \"hugepagesize\" hugetlb reservations (if supported) or usage.
    #[serde(rename = "limit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<i32>,

/// Pagesize is the hugepage size. Format: \"<size><unit-prefix>B' (e.g. 64KB, 2MB, 1GB, etc.).
    #[serde(rename = "pageSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub page_size: Option<String>,

}


impl LinuxHugepageLimit {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxHugepageLimit {
        LinuxHugepageLimit {
            limit: None,
            page_size: None,
        }
    }
}

/// Converts the LinuxHugepageLimit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxHugepageLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.limit.as_ref().map(|limit| {
                [
                    "limit".to_string(),
                    limit.to_string(),
                ].join(",")
            }),


            self.page_size.as_ref().map(|page_size| {
                [
                    "pageSize".to_string(),
                    page_size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxHugepageLimit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxHugepageLimit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub limit: Vec<i32>,
            pub page_size: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxHugepageLimit".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "limit" => intermediate_rep.limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pageSize" => intermediate_rep.page_size.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxHugepageLimit".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxHugepageLimit {
            limit: intermediate_rep.limit.into_iter().next(),
            page_size: intermediate_rep.page_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxHugepageLimit> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxHugepageLimit>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxHugepageLimit>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxHugepageLimit - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxHugepageLimit> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxHugepageLimit as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxHugepageLimit - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxIDMapping specifies UID/GID mappings



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxIdMapping {
/// ContainerID is the starting UID/GID in the container
    #[serde(rename = "containerID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_id: Option<i32>,

/// HostID is the starting UID/GID on the host to be mapped to 'ContainerID'
    #[serde(rename = "hostID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_id: Option<i32>,

/// Size is the number of IDs to be mapped
    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i32>,

}


impl LinuxIdMapping {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxIdMapping {
        LinuxIdMapping {
            container_id: None,
            host_id: None,
            size: None,
        }
    }
}

/// Converts the LinuxIdMapping value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxIdMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.container_id.as_ref().map(|container_id| {
                [
                    "containerID".to_string(),
                    container_id.to_string(),
                ].join(",")
            }),


            self.host_id.as_ref().map(|host_id| {
                [
                    "hostID".to_string(),
                    host_id.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxIdMapping value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxIdMapping {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container_id: Vec<i32>,
            pub host_id: Vec<i32>,
            pub size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxIdMapping".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "containerID" => intermediate_rep.container_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostID" => intermediate_rep.host_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxIdMapping".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxIdMapping {
            container_id: intermediate_rep.container_id.into_iter().next(),
            host_id: intermediate_rep.host_id.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxIdMapping> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxIdMapping>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxIdMapping>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxIdMapping - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxIdMapping> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxIdMapping as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxIdMapping - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxIntelRdt has container runtime resource constraints for Intel RDT CAT and MBA features and flags enabling Intel RDT CMT and MBM features. Intel RDT features are available in Linux 4.14 and newer kernel versions.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxIntelRdt {
/// The identity for RDT Class of Service
    #[serde(rename = "closID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub clos_id: Option<String>,

/// EnableCMT is the flag to indicate if the Intel RDT CMT is enabled. CMT (Cache Monitoring Technology) supports monitoring of the last-level cache (LLC) occupancy for the container.
    #[serde(rename = "enableCMT")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_cmt: Option<bool>,

/// EnableMBM is the flag to indicate if the Intel RDT MBM is enabled. MBM (Memory Bandwidth Monitoring) supports monitoring of total and local memory bandwidth for the container.
    #[serde(rename = "enableMBM")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_mbm: Option<bool>,

/// The schema for L3 cache id and capacity bitmask (CBM) Format: \"L3:<cache_id0>=<cbm0>;<cache_id1>=<cbm1>;...\"
    #[serde(rename = "l3CacheSchema")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub l3_cache_schema: Option<String>,

/// The schema of memory bandwidth per L3 cache id Format: \"MB:<cache_id0>=bandwidth0;<cache_id1>=bandwidth1;...\" The unit of memory bandwidth is specified in \"percentages\" by default, and in \"MBps\" if MBA Software Controller is enabled.
    #[serde(rename = "memBwSchema")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem_bw_schema: Option<String>,

}


impl LinuxIntelRdt {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxIntelRdt {
        LinuxIntelRdt {
            clos_id: None,
            enable_cmt: None,
            enable_mbm: None,
            l3_cache_schema: None,
            mem_bw_schema: None,
        }
    }
}

/// Converts the LinuxIntelRdt value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxIntelRdt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.clos_id.as_ref().map(|clos_id| {
                [
                    "closID".to_string(),
                    clos_id.to_string(),
                ].join(",")
            }),


            self.enable_cmt.as_ref().map(|enable_cmt| {
                [
                    "enableCMT".to_string(),
                    enable_cmt.to_string(),
                ].join(",")
            }),


            self.enable_mbm.as_ref().map(|enable_mbm| {
                [
                    "enableMBM".to_string(),
                    enable_mbm.to_string(),
                ].join(",")
            }),


            self.l3_cache_schema.as_ref().map(|l3_cache_schema| {
                [
                    "l3CacheSchema".to_string(),
                    l3_cache_schema.to_string(),
                ].join(",")
            }),


            self.mem_bw_schema.as_ref().map(|mem_bw_schema| {
                [
                    "memBwSchema".to_string(),
                    mem_bw_schema.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxIntelRdt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxIntelRdt {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub clos_id: Vec<String>,
            pub enable_cmt: Vec<bool>,
            pub enable_mbm: Vec<bool>,
            pub l3_cache_schema: Vec<String>,
            pub mem_bw_schema: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxIntelRdt".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "closID" => intermediate_rep.clos_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enableCMT" => intermediate_rep.enable_cmt.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "enableMBM" => intermediate_rep.enable_mbm.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "l3CacheSchema" => intermediate_rep.l3_cache_schema.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "memBwSchema" => intermediate_rep.mem_bw_schema.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxIntelRdt".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxIntelRdt {
            clos_id: intermediate_rep.clos_id.into_iter().next(),
            enable_cmt: intermediate_rep.enable_cmt.into_iter().next(),
            enable_mbm: intermediate_rep.enable_mbm.into_iter().next(),
            l3_cache_schema: intermediate_rep.l3_cache_schema.into_iter().next(),
            mem_bw_schema: intermediate_rep.mem_bw_schema.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxIntelRdt> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxIntelRdt>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxIntelRdt>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxIntelRdt - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxIntelRdt> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxIntelRdt as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxIntelRdt - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxInterfacePriority for network interfaces



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxInterfacePriority {
/// Name is the name of the network interface
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Priority for the interface
    #[serde(rename = "priority")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<i32>,

}


impl LinuxInterfacePriority {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxInterfacePriority {
        LinuxInterfacePriority {
            name: None,
            priority: None,
        }
    }
}

/// Converts the LinuxInterfacePriority value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxInterfacePriority {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.priority.as_ref().map(|priority| {
                [
                    "priority".to_string(),
                    priority.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxInterfacePriority value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxInterfacePriority {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub priority: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxInterfacePriority".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "priority" => intermediate_rep.priority.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxInterfacePriority".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxInterfacePriority {
            name: intermediate_rep.name.into_iter().next(),
            priority: intermediate_rep.priority.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxInterfacePriority> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxInterfacePriority>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxInterfacePriority>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxInterfacePriority - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxInterfacePriority> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxInterfacePriority as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxInterfacePriority - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxMemory for Linux cgroup 'memory' resource management



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxMemory {
/// CheckBeforeUpdate enables checking if a new memory limit is lower than the current usage during update, and if so, rejecting the new limit.
    #[serde(rename = "checkBeforeUpdate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_before_update: Option<bool>,

/// DisableOOMKiller disables the OOM killer for out of memory conditions
    #[serde(rename = "disableOOMKiller")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub disable_oom_killer: Option<bool>,

/// Kernel memory limit (in bytes).  Deprecated: kernel-memory limits are not supported in cgroups v2, and were obsoleted in [kernel v5.4]. This field should no longer be used, as it may be ignored by runtimes.  [kernel v5.4]: https://github.com/torvalds/linux/commit/0158115f702b0ba208ab0
    #[serde(rename = "kernel")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel: Option<i64>,

/// Kernel memory limit for tcp (in bytes)
    #[serde(rename = "kernelTCP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_tcp: Option<i64>,

/// Memory limit (in bytes).
    #[serde(rename = "limit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<i64>,

/// Memory reservation or soft_limit (in bytes).
    #[serde(rename = "reservation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reservation: Option<i64>,

/// Total memory limit (memory + swap).
    #[serde(rename = "swap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub swap: Option<i64>,

/// How aggressive the kernel will swap memory pages.
    #[serde(rename = "swappiness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub swappiness: Option<i32>,

/// Enables hierarchical memory accounting
    #[serde(rename = "useHierarchy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_hierarchy: Option<bool>,

}


impl LinuxMemory {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxMemory {
        LinuxMemory {
            check_before_update: None,
            disable_oom_killer: None,
            kernel: None,
            kernel_tcp: None,
            limit: None,
            reservation: None,
            swap: None,
            swappiness: None,
            use_hierarchy: None,
        }
    }
}

/// Converts the LinuxMemory value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxMemory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.check_before_update.as_ref().map(|check_before_update| {
                [
                    "checkBeforeUpdate".to_string(),
                    check_before_update.to_string(),
                ].join(",")
            }),


            self.disable_oom_killer.as_ref().map(|disable_oom_killer| {
                [
                    "disableOOMKiller".to_string(),
                    disable_oom_killer.to_string(),
                ].join(",")
            }),


            self.kernel.as_ref().map(|kernel| {
                [
                    "kernel".to_string(),
                    kernel.to_string(),
                ].join(",")
            }),


            self.kernel_tcp.as_ref().map(|kernel_tcp| {
                [
                    "kernelTCP".to_string(),
                    kernel_tcp.to_string(),
                ].join(",")
            }),


            self.limit.as_ref().map(|limit| {
                [
                    "limit".to_string(),
                    limit.to_string(),
                ].join(",")
            }),


            self.reservation.as_ref().map(|reservation| {
                [
                    "reservation".to_string(),
                    reservation.to_string(),
                ].join(",")
            }),


            self.swap.as_ref().map(|swap| {
                [
                    "swap".to_string(),
                    swap.to_string(),
                ].join(",")
            }),


            self.swappiness.as_ref().map(|swappiness| {
                [
                    "swappiness".to_string(),
                    swappiness.to_string(),
                ].join(",")
            }),


            self.use_hierarchy.as_ref().map(|use_hierarchy| {
                [
                    "useHierarchy".to_string(),
                    use_hierarchy.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxMemory value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxMemory {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub check_before_update: Vec<bool>,
            pub disable_oom_killer: Vec<bool>,
            pub kernel: Vec<i64>,
            pub kernel_tcp: Vec<i64>,
            pub limit: Vec<i64>,
            pub reservation: Vec<i64>,
            pub swap: Vec<i64>,
            pub swappiness: Vec<i32>,
            pub use_hierarchy: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxMemory".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "checkBeforeUpdate" => intermediate_rep.check_before_update.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "disableOOMKiller" => intermediate_rep.disable_oom_killer.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kernel" => intermediate_rep.kernel.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "kernelTCP" => intermediate_rep.kernel_tcp.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "limit" => intermediate_rep.limit.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reservation" => intermediate_rep.reservation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "swap" => intermediate_rep.swap.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "swappiness" => intermediate_rep.swappiness.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "useHierarchy" => intermediate_rep.use_hierarchy.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxMemory".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxMemory {
            check_before_update: intermediate_rep.check_before_update.into_iter().next(),
            disable_oom_killer: intermediate_rep.disable_oom_killer.into_iter().next(),
            kernel: intermediate_rep.kernel.into_iter().next(),
            kernel_tcp: intermediate_rep.kernel_tcp.into_iter().next(),
            limit: intermediate_rep.limit.into_iter().next(),
            reservation: intermediate_rep.reservation.into_iter().next(),
            swap: intermediate_rep.swap.into_iter().next(),
            swappiness: intermediate_rep.swappiness.into_iter().next(),
            use_hierarchy: intermediate_rep.use_hierarchy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxMemory> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxMemory>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxMemory>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxMemory - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxMemory> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxMemory as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxMemory - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxNetwork identification and priority configuration



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxNetwork {
/// Set class identifier for container's network packets
    #[serde(rename = "classID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub class_id: Option<i32>,

/// Set priority of network traffic for container
    #[serde(rename = "priorities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub priorities: Option<Vec<models::LinuxInterfacePriority>>,

}


impl LinuxNetwork {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxNetwork {
        LinuxNetwork {
            class_id: None,
            priorities: None,
        }
    }
}

/// Converts the LinuxNetwork value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxNetwork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.class_id.as_ref().map(|class_id| {
                [
                    "classID".to_string(),
                    class_id.to_string(),
                ].join(",")
            }),

            // Skipping priorities in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxNetwork value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxNetwork {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub class_id: Vec<i32>,
            pub priorities: Vec<Vec<models::LinuxInterfacePriority>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxNetwork".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "classID" => intermediate_rep.class_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "priorities" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxNetwork".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxNetwork".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxNetwork {
            class_id: intermediate_rep.class_id.into_iter().next(),
            priorities: intermediate_rep.priorities.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxNetwork> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxNetwork>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxNetwork>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxNetwork - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxNetwork> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxNetwork as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxNetwork - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxPersonality represents the Linux personality syscall input



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxPersonality {
    #[serde(rename = "domain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub domain: Option<String>,

/// Additional flags
    #[serde(rename = "flags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub flags: Option<Vec<models::LinuxPersonalityFlag>>,

}


impl LinuxPersonality {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxPersonality {
        LinuxPersonality {
            domain: None,
            flags: None,
        }
    }
}

/// Converts the LinuxPersonality value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxPersonality {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.domain.as_ref().map(|domain| {
                [
                    "domain".to_string(),
                    domain.to_string(),
                ].join(",")
            }),


            self.flags.as_ref().map(|flags| {
                [
                    "flags".to_string(),
                    flags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxPersonality value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxPersonality {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub domain: Vec<String>,
            pub flags: Vec<Vec<models::LinuxPersonalityFlag>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxPersonality".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "domain" => intermediate_rep.domain.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "flags" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxPersonality".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxPersonality".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxPersonality {
            domain: intermediate_rep.domain.into_iter().next(),
            flags: intermediate_rep.flags.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxPersonality> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxPersonality>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxPersonality>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxPersonality - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxPersonality> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxPersonality as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxPersonality - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxPersonalityDomain(String);

impl validator::Validate for LinuxPersonalityDomain {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for LinuxPersonalityDomain {
    fn from(x: String) -> Self {
        LinuxPersonalityDomain(x)
    }
}

impl std::fmt::Display for LinuxPersonalityDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for LinuxPersonalityDomain {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(LinuxPersonalityDomain(x.to_string()))
    }
}

impl std::convert::From<LinuxPersonalityDomain> for String {
    fn from(x: LinuxPersonalityDomain) -> Self {
        x.0
    }
}

impl std::ops::Deref for LinuxPersonalityDomain {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for LinuxPersonalityDomain {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxPersonalityFlag(String);

impl validator::Validate for LinuxPersonalityFlag {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for LinuxPersonalityFlag {
    fn from(x: String) -> Self {
        LinuxPersonalityFlag(x)
    }
}

impl std::fmt::Display for LinuxPersonalityFlag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for LinuxPersonalityFlag {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(LinuxPersonalityFlag(x.to_string()))
    }
}

impl std::convert::From<LinuxPersonalityFlag> for String {
    fn from(x: LinuxPersonalityFlag) -> Self {
        x.0
    }
}

impl std::ops::Deref for LinuxPersonalityFlag {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for LinuxPersonalityFlag {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// LinuxPids for Linux cgroup 'pids' resource management (Linux 4.3)



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxPids {
/// Maximum number of PIDs. Default is \"no limit\".
    #[serde(rename = "limit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<i64>,

}


impl LinuxPids {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxPids {
        LinuxPids {
            limit: None,
        }
    }
}

/// Converts the LinuxPids value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxPids {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.limit.as_ref().map(|limit| {
                [
                    "limit".to_string(),
                    limit.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxPids value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxPids {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub limit: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxPids".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "limit" => intermediate_rep.limit.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxPids".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxPids {
            limit: intermediate_rep.limit.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxPids> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxPids>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxPids>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxPids - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxPids> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxPids as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxPids - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxRdma for Linux cgroup 'rdma' resource management (Linux 4.11)



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxRdma {
/// Maximum number of HCA handles that can be opened. Default is \"no limit\".
    #[serde(rename = "hcaHandles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hca_handles: Option<i32>,

/// Maximum number of HCA objects that can be created. Default is \"no limit\".
    #[serde(rename = "hcaObjects")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hca_objects: Option<i32>,

}


impl LinuxRdma {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxRdma {
        LinuxRdma {
            hca_handles: None,
            hca_objects: None,
        }
    }
}

/// Converts the LinuxRdma value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxRdma {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.hca_handles.as_ref().map(|hca_handles| {
                [
                    "hcaHandles".to_string(),
                    hca_handles.to_string(),
                ].join(",")
            }),


            self.hca_objects.as_ref().map(|hca_objects| {
                [
                    "hcaObjects".to_string(),
                    hca_objects.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxRdma value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxRdma {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hca_handles: Vec<i32>,
            pub hca_objects: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxRdma".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hcaHandles" => intermediate_rep.hca_handles.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hcaObjects" => intermediate_rep.hca_objects.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxRdma".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxRdma {
            hca_handles: intermediate_rep.hca_handles.into_iter().next(),
            hca_objects: intermediate_rep.hca_objects.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxRdma> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxRdma>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxRdma>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxRdma - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxRdma> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxRdma as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxRdma - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxResources has container runtime resource constraints



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxResources {
    #[serde(rename = "blockIO")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_io: Option<models::LinuxBlockIo>,

    #[serde(rename = "cpu")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu: Option<models::LinuxCpu>,

/// Devices configures the device allowlist.
    #[serde(rename = "devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::LinuxDeviceCgroup>>,

/// Hugetlb limits (in bytes). Default to reservation limits if supported.
    #[serde(rename = "hugepageLimits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hugepage_limits: Option<Vec<models::LinuxHugepageLimit>>,

    #[serde(rename = "memory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory: Option<models::LinuxMemory>,

    #[serde(rename = "network")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network: Option<models::LinuxNetwork>,

    #[serde(rename = "pids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids: Option<models::LinuxPids>,

/// Rdma resource restriction configuration. Limits are a set of key value pairs that define RDMA resource limits, where the key is device name and value is resource limits.
    #[serde(rename = "rdma")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rdma: Option<std::collections::HashMap<String, models::LinuxRdma>>,

/// Unified resources.
    #[serde(rename = "unified")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unified: Option<std::collections::HashMap<String, String>>,

}


impl LinuxResources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxResources {
        LinuxResources {
            block_io: None,
            cpu: None,
            devices: None,
            hugepage_limits: None,
            memory: None,
            network: None,
            pids: None,
            rdma: None,
            unified: None,
        }
    }
}

/// Converts the LinuxResources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping blockIO in query parameter serialization

            // Skipping cpu in query parameter serialization

            // Skipping devices in query parameter serialization

            // Skipping hugepageLimits in query parameter serialization

            // Skipping memory in query parameter serialization

            // Skipping network in query parameter serialization

            // Skipping pids in query parameter serialization

            // Skipping rdma in query parameter serialization
            // Skipping rdma in query parameter serialization

            // Skipping unified in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxResources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxResources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub block_io: Vec<models::LinuxBlockIo>,
            pub cpu: Vec<models::LinuxCpu>,
            pub devices: Vec<Vec<models::LinuxDeviceCgroup>>,
            pub hugepage_limits: Vec<Vec<models::LinuxHugepageLimit>>,
            pub memory: Vec<models::LinuxMemory>,
            pub network: Vec<models::LinuxNetwork>,
            pub pids: Vec<models::LinuxPids>,
            pub rdma: Vec<std::collections::HashMap<String, models::LinuxRdma>>,
            pub unified: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxResources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "blockIO" => intermediate_rep.block_io.push(<models::LinuxBlockIo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpu" => intermediate_rep.cpu.push(<models::LinuxCpu as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "devices" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxResources".to_string()),
                    "hugepageLimits" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxResources".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "memory" => intermediate_rep.memory.push(<models::LinuxMemory as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "network" => intermediate_rep.network.push(<models::LinuxNetwork as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pids" => intermediate_rep.pids.push(<models::LinuxPids as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "rdma" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxResources".to_string()),
                    "unified" => return std::result::Result::Err("Parsing a container in this style is not supported in LinuxResources".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxResources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxResources {
            block_io: intermediate_rep.block_io.into_iter().next(),
            cpu: intermediate_rep.cpu.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            hugepage_limits: intermediate_rep.hugepage_limits.into_iter().next(),
            memory: intermediate_rep.memory.into_iter().next(),
            network: intermediate_rep.network.into_iter().next(),
            pids: intermediate_rep.pids.into_iter().next(),
            rdma: intermediate_rep.rdma.into_iter().next(),
            unified: intermediate_rep.unified.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxResources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxResources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxResources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxResources - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxResources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxResources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxResources - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxThrottleDevice struct holds a `major:minor rate_per_second` pair



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxThrottleDevice {
/// Major is the device's major number.
    #[serde(rename = "major")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<i64>,

/// Minor is the device's minor number.
    #[serde(rename = "minor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub minor: Option<i64>,

/// Rate is the IO rate limit per cgroup per device
    #[serde(rename = "rate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate: Option<i32>,

}


impl LinuxThrottleDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxThrottleDevice {
        LinuxThrottleDevice {
            major: None,
            minor: None,
            rate: None,
        }
    }
}

/// Converts the LinuxThrottleDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxThrottleDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.major.as_ref().map(|major| {
                [
                    "major".to_string(),
                    major.to_string(),
                ].join(",")
            }),


            self.minor.as_ref().map(|minor| {
                [
                    "minor".to_string(),
                    minor.to_string(),
                ].join(",")
            }),


            self.rate.as_ref().map(|rate| {
                [
                    "rate".to_string(),
                    rate.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxThrottleDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxThrottleDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub major: Vec<i64>,
            pub minor: Vec<i64>,
            pub rate: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxThrottleDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "major" => intermediate_rep.major.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "minor" => intermediate_rep.minor.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rate" => intermediate_rep.rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxThrottleDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxThrottleDevice {
            major: intermediate_rep.major.into_iter().next(),
            minor: intermediate_rep.minor.into_iter().next(),
            rate: intermediate_rep.rate.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxThrottleDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxThrottleDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxThrottleDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxThrottleDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxThrottleDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxThrottleDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxThrottleDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LinuxWeightDevice struct holds a `major:minor weight` pair for weightDevice



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LinuxWeightDevice {
/// LeafWeight is the bandwidth rate for the device while competing with the cgroup's child cgroups, CFQ scheduler only
    #[serde(rename = "leafWeight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub leaf_weight: Option<i32>,

/// Major is the device's major number.
    #[serde(rename = "major")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub major: Option<i64>,

/// Minor is the device's minor number.
    #[serde(rename = "minor")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub minor: Option<i64>,

/// Weight is the bandwidth rate for the device.
    #[serde(rename = "weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<i32>,

}


impl LinuxWeightDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LinuxWeightDevice {
        LinuxWeightDevice {
            leaf_weight: None,
            major: None,
            minor: None,
            weight: None,
        }
    }
}

/// Converts the LinuxWeightDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LinuxWeightDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.leaf_weight.as_ref().map(|leaf_weight| {
                [
                    "leafWeight".to_string(),
                    leaf_weight.to_string(),
                ].join(",")
            }),


            self.major.as_ref().map(|major| {
                [
                    "major".to_string(),
                    major.to_string(),
                ].join(",")
            }),


            self.minor.as_ref().map(|minor| {
                [
                    "minor".to_string(),
                    minor.to_string(),
                ].join(",")
            }),


            self.weight.as_ref().map(|weight| {
                [
                    "weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LinuxWeightDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LinuxWeightDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub leaf_weight: Vec<i32>,
            pub major: Vec<i64>,
            pub minor: Vec<i64>,
            pub weight: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LinuxWeightDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "leafWeight" => intermediate_rep.leaf_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "major" => intermediate_rep.major.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "minor" => intermediate_rep.minor.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LinuxWeightDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LinuxWeightDevice {
            leaf_weight: intermediate_rep.leaf_weight.into_iter().next(),
            major: intermediate_rep.major.into_iter().next(),
            minor: intermediate_rep.minor.into_iter().next(),
            weight: intermediate_rep.weight.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LinuxWeightDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LinuxWeightDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LinuxWeightDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LinuxWeightDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LinuxWeightDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LinuxWeightDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LinuxWeightDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ListContainer describes a container suitable for listing



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate, Default)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListContainer {
/// AutoRemove
    #[serde(rename = "AutoRemove")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_remove: Option<bool>,

/// CIDFile specified at creation time.
    #[serde(rename = "CIDFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cid_file: Option<String>,

/// Container command
    #[serde(rename = "Command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<Vec<String>>,

/// Container creation time
    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

/// Human-readable container creation time.
    #[serde(rename = "CreatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,

/// If container has exited, the return code from the command
    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i32>,

/// If container has exited/stopped
    #[serde(rename = "Exited")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exited: Option<bool>,

/// Time container exited
    #[serde(rename = "ExitedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exited_at: Option<i64>,

/// ExposedPorts contains the ports that are exposed but not forwarded, see Ports for forwarded ports. The key is the port number and the string slice contains the protocols, i.e. \"tcp\", \"udp\" and \"sctp\".
    #[serde(rename = "ExposedPorts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exposed_ports: Option<crate::types::Object>,

/// The unique identifier for the container
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Container image
    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

/// Container image ID
    #[serde(rename = "ImageID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_id: Option<String>,

/// If this container is a Pod infra container
    #[serde(rename = "IsInfra")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_infra: Option<bool>,

/// Labels for container
    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// User volume mounts
    #[serde(rename = "Mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<String>>,

/// The names assigned to the container
    #[serde(rename = "Names")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub names: Option<Vec<String>>,

    #[serde(rename = "Namespaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespaces: Option<models::ListContainerNamespaces>,

/// The network names assigned to the container
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<Vec<String>>,

/// The process id of the container
    #[serde(rename = "Pid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid: Option<i64>,

/// If the container is part of Pod, the Pod ID. Requires the pod boolean to be set
    #[serde(rename = "Pod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod: Option<String>,

/// If the container is part of Pod, the Pod name. Requires the pod boolean to be set
    #[serde(rename = "PodName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_name: Option<String>,

/// Port mappings
    #[serde(rename = "Ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ports: Option<Vec<models::PortMapping>>,

/// Restarts is how many times the container was restarted by its restart policy. This is NOT incremented by normal container restarts (only by restart policy).
    #[serde(rename = "Restarts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restarts: Option<i32>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<models::ContainerSize>,

/// Time when container started
    #[serde(rename = "StartedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<i64>,

/// State of container
    #[serde(rename = "State")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,

/// Status is a human-readable approximation of a duration for json output
    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl ListContainer {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ListContainer {
        ListContainer {
            auto_remove: None,
            cid_file: None,
            command: None,
            created: None,
            created_at: None,
            exit_code: None,
            exited: None,
            exited_at: None,
            exposed_ports: None,
            id: None,
            image: None,
            image_id: None,
            is_infra: None,
            labels: None,
            mounts: None,
            names: None,
            namespaces: None,
            networks: None,
            pid: None,
            pod: None,
            pod_name: None,
            ports: None,
            restarts: None,
            size: None,
            started_at: None,
            state: None,
            status: None,
        }
    }
}

/// Converts the ListContainer value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListContainer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.auto_remove.as_ref().map(|auto_remove| {
                [
                    "AutoRemove".to_string(),
                    auto_remove.to_string(),
                ].join(",")
            }),


            self.cid_file.as_ref().map(|cid_file| {
                [
                    "CIDFile".to_string(),
                    cid_file.to_string(),
                ].join(",")
            }),


            self.command.as_ref().map(|command| {
                [
                    "Command".to_string(),
                    command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping Created in query parameter serialization


            self.created_at.as_ref().map(|created_at| {
                [
                    "CreatedAt".to_string(),
                    created_at.to_string(),
                ].join(",")
            }),


            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),


            self.exited.as_ref().map(|exited| {
                [
                    "Exited".to_string(),
                    exited.to_string(),
                ].join(",")
            }),


            self.exited_at.as_ref().map(|exited_at| {
                [
                    "ExitedAt".to_string(),
                    exited_at.to_string(),
                ].join(",")
            }),

            // Skipping ExposedPorts in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.image_id.as_ref().map(|image_id| {
                [
                    "ImageID".to_string(),
                    image_id.to_string(),
                ].join(",")
            }),


            self.is_infra.as_ref().map(|is_infra| {
                [
                    "IsInfra".to_string(),
                    is_infra.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.mounts.as_ref().map(|mounts| {
                [
                    "Mounts".to_string(),
                    mounts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.names.as_ref().map(|names| {
                [
                    "Names".to_string(),
                    names.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping Namespaces in query parameter serialization


            self.networks.as_ref().map(|networks| {
                [
                    "Networks".to_string(),
                    networks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.pid.as_ref().map(|pid| {
                [
                    "Pid".to_string(),
                    pid.to_string(),
                ].join(",")
            }),


            self.pod.as_ref().map(|pod| {
                [
                    "Pod".to_string(),
                    pod.to_string(),
                ].join(",")
            }),


            self.pod_name.as_ref().map(|pod_name| {
                [
                    "PodName".to_string(),
                    pod_name.to_string(),
                ].join(",")
            }),

            // Skipping Ports in query parameter serialization


            self.restarts.as_ref().map(|restarts| {
                [
                    "Restarts".to_string(),
                    restarts.to_string(),
                ].join(",")
            }),

            // Skipping Size in query parameter serialization


            self.started_at.as_ref().map(|started_at| {
                [
                    "StartedAt".to_string(),
                    started_at.to_string(),
                ].join(",")
            }),


            self.state.as_ref().map(|state| {
                [
                    "State".to_string(),
                    state.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListContainer value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListContainer {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub auto_remove: Vec<bool>,
            pub cid_file: Vec<String>,
            pub command: Vec<Vec<String>>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub created_at: Vec<String>,
            pub exit_code: Vec<i32>,
            pub exited: Vec<bool>,
            pub exited_at: Vec<i64>,
            pub exposed_ports: Vec<crate::types::Object>,
            pub id: Vec<String>,
            pub image: Vec<String>,
            pub image_id: Vec<String>,
            pub is_infra: Vec<bool>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub mounts: Vec<Vec<String>>,
            pub names: Vec<Vec<String>>,
            pub namespaces: Vec<models::ListContainerNamespaces>,
            pub networks: Vec<Vec<String>>,
            pub pid: Vec<i64>,
            pub pod: Vec<String>,
            pub pod_name: Vec<String>,
            pub ports: Vec<Vec<models::PortMapping>>,
            pub restarts: Vec<i32>,
            pub size: Vec<models::ContainerSize>,
            pub started_at: Vec<i64>,
            pub state: Vec<String>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListContainer".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AutoRemove" => intermediate_rep.auto_remove.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CIDFile" => intermediate_rep.cid_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Command" => return std::result::Result::Err("Parsing a container in this style is not supported in ListContainer".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CreatedAt" => intermediate_rep.created_at.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Exited" => intermediate_rep.exited.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExitedAt" => intermediate_rep.exited_at.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ExposedPorts" => intermediate_rep.exposed_ports.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ImageID" => intermediate_rep.image_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IsInfra" => intermediate_rep.is_infra.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in ListContainer".to_string()),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in ListContainer".to_string()),
                    "Names" => return std::result::Result::Err("Parsing a container in this style is not supported in ListContainer".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Namespaces" => intermediate_rep.namespaces.push(<models::ListContainerNamespaces as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in ListContainer".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Pid" => intermediate_rep.pid.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Pod" => intermediate_rep.pod.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PodName" => intermediate_rep.pod_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ports" => return std::result::Result::Err("Parsing a container in this style is not supported in ListContainer".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Restarts" => intermediate_rep.restarts.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<models::ContainerSize as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartedAt" => intermediate_rep.started_at.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "State" => intermediate_rep.state.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListContainer".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListContainer {
            auto_remove: intermediate_rep.auto_remove.into_iter().next(),
            cid_file: intermediate_rep.cid_file.into_iter().next(),
            command: intermediate_rep.command.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            exited: intermediate_rep.exited.into_iter().next(),
            exited_at: intermediate_rep.exited_at.into_iter().next(),
            exposed_ports: intermediate_rep.exposed_ports.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            image_id: intermediate_rep.image_id.into_iter().next(),
            is_infra: intermediate_rep.is_infra.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            names: intermediate_rep.names.into_iter().next(),
            namespaces: intermediate_rep.namespaces.into_iter().next(),
            networks: intermediate_rep.networks.into_iter().next(),
            pid: intermediate_rep.pid.into_iter().next(),
            pod: intermediate_rep.pod.into_iter().next(),
            pod_name: intermediate_rep.pod_name.into_iter().next(),
            ports: intermediate_rep.ports.into_iter().next(),
            restarts: intermediate_rep.restarts.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            started_at: intermediate_rep.started_at.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListContainer> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListContainer>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListContainer>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListContainer - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListContainer> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListContainer as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListContainer - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ListContainerNamespaces contains the identifiers of the container's Linux namespaces



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListContainerNamespaces {
/// Cgroup namespace
    #[serde(rename = "Cgroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup: Option<String>,

/// IPC namespace
    #[serde(rename = "Ipc")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipc: Option<String>,

/// Mount namespace
    #[serde(rename = "Mnt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mnt: Option<String>,

/// Network namespace
    #[serde(rename = "Net")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub net: Option<String>,

/// PID namespace
    #[serde(rename = "Pidns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pidns: Option<String>,

/// User namespace
    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

/// UTS namespace
    #[serde(rename = "Uts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uts: Option<String>,

}


impl ListContainerNamespaces {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ListContainerNamespaces {
        ListContainerNamespaces {
            cgroup: None,
            ipc: None,
            mnt: None,
            net: None,
            pidns: None,
            user: None,
            uts: None,
        }
    }
}

/// Converts the ListContainerNamespaces value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListContainerNamespaces {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup.as_ref().map(|cgroup| {
                [
                    "Cgroup".to_string(),
                    cgroup.to_string(),
                ].join(",")
            }),


            self.ipc.as_ref().map(|ipc| {
                [
                    "Ipc".to_string(),
                    ipc.to_string(),
                ].join(",")
            }),


            self.mnt.as_ref().map(|mnt| {
                [
                    "Mnt".to_string(),
                    mnt.to_string(),
                ].join(",")
            }),


            self.net.as_ref().map(|net| {
                [
                    "Net".to_string(),
                    net.to_string(),
                ].join(",")
            }),


            self.pidns.as_ref().map(|pidns| {
                [
                    "Pidns".to_string(),
                    pidns.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "User".to_string(),
                    user.to_string(),
                ].join(",")
            }),


            self.uts.as_ref().map(|uts| {
                [
                    "Uts".to_string(),
                    uts.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListContainerNamespaces value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListContainerNamespaces {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup: Vec<String>,
            pub ipc: Vec<String>,
            pub mnt: Vec<String>,
            pub net: Vec<String>,
            pub pidns: Vec<String>,
            pub user: Vec<String>,
            pub uts: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListContainerNamespaces".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Cgroup" => intermediate_rep.cgroup.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Ipc" => intermediate_rep.ipc.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Mnt" => intermediate_rep.mnt.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Net" => intermediate_rep.net.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Pidns" => intermediate_rep.pidns.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Uts" => intermediate_rep.uts.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListContainerNamespaces".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListContainerNamespaces {
            cgroup: intermediate_rep.cgroup.into_iter().next(),
            ipc: intermediate_rep.ipc.into_iter().next(),
            mnt: intermediate_rep.mnt.into_iter().next(),
            net: intermediate_rep.net.into_iter().next(),
            pidns: intermediate_rep.pidns.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            uts: intermediate_rep.uts.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListContainerNamespaces> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListContainerNamespaces>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListContainerNamespaces>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListContainerNamespaces - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListContainerNamespaces> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListContainerNamespaces as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListContainerNamespaces - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListPodContainer {
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Names")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub names: Option<String>,

    #[serde(rename = "RestartCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_count: Option<i32>,

    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl ListPodContainer {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ListPodContainer {
        ListPodContainer {
            id: None,
            names: None,
            restart_count: None,
            status: None,
        }
    }
}

/// Converts the ListPodContainer value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListPodContainer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.names.as_ref().map(|names| {
                [
                    "Names".to_string(),
                    names.to_string(),
                ].join(",")
            }),


            self.restart_count.as_ref().map(|restart_count| {
                [
                    "RestartCount".to_string(),
                    restart_count.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListPodContainer value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListPodContainer {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub names: Vec<String>,
            pub restart_count: Vec<i32>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListPodContainer".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Names" => intermediate_rep.names.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestartCount" => intermediate_rep.restart_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListPodContainer".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListPodContainer {
            id: intermediate_rep.id.into_iter().next(),
            names: intermediate_rep.names.into_iter().next(),
            restart_count: intermediate_rep.restart_count.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListPodContainer> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListPodContainer>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListPodContainer>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListPodContainer - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListPodContainer> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListPodContainer as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListPodContainer - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListPodsReport {
    #[serde(rename = "Cgroup")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup: Option<String>,

    #[serde(rename = "Containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<Vec<models::ListPodContainer>>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "InfraId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_id: Option<String>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Namespace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,

/// Network names connected to infra container
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<Vec<String>>,

    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl ListPodsReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ListPodsReport {
        ListPodsReport {
            cgroup: None,
            containers: None,
            created: None,
            id: None,
            infra_id: None,
            labels: None,
            name: None,
            namespace: None,
            networks: None,
            status: None,
        }
    }
}

/// Converts the ListPodsReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListPodsReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup.as_ref().map(|cgroup| {
                [
                    "Cgroup".to_string(),
                    cgroup.to_string(),
                ].join(",")
            }),

            // Skipping Containers in query parameter serialization

            // Skipping Created in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.infra_id.as_ref().map(|infra_id| {
                [
                    "InfraId".to_string(),
                    infra_id.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.namespace.as_ref().map(|namespace| {
                [
                    "Namespace".to_string(),
                    namespace.to_string(),
                ].join(",")
            }),


            self.networks.as_ref().map(|networks| {
                [
                    "Networks".to_string(),
                    networks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListPodsReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListPodsReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup: Vec<String>,
            pub containers: Vec<Vec<models::ListPodContainer>>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub infra_id: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub namespace: Vec<String>,
            pub networks: Vec<Vec<String>>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListPodsReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Cgroup" => intermediate_rep.cgroup.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Containers" => return std::result::Result::Err("Parsing a container in this style is not supported in ListPodsReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "InfraId" => intermediate_rep.infra_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in ListPodsReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Namespace" => intermediate_rep.namespace.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in ListPodsReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListPodsReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListPodsReport {
            cgroup: intermediate_rep.cgroup.into_iter().next(),
            containers: intermediate_rep.containers.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            infra_id: intermediate_rep.infra_id.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            namespace: intermediate_rep.namespace.into_iter().next(),
            networks: intermediate_rep.networks.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListPodsReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListPodsReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListPodsReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListPodsReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListPodsReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListPodsReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListPodsReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Volume list response



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListResponse {
/// List of volumes
    #[serde(rename = "Volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<Vec<models::Volume>>,

/// Warnings that occurred when fetching the list of volumes.
    #[serde(rename = "Warnings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<Vec<String>>,

}


impl ListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ListResponse {
        ListResponse {
            volumes: None,
            warnings: None,
        }
    }
}

/// Converts the ListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Volumes in query parameter serialization


            self.warnings.as_ref().map(|warnings| {
                [
                    "Warnings".to_string(),
                    warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub volumes: Vec<Vec<models::Volume>>,
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in ListResponse".to_string()),
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ListResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListResponse {
            volumes: intermediate_rep.volumes.into_iter().next(),
            warnings: intermediate_rep.warnings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LogConfig {
    #[serde(rename = "Config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl LogConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LogConfig {
        LogConfig {
            config: None,
            r#type: None,
        }
    }
}

/// Converts the LogConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LogConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Config in query parameter serialization


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LogConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LogConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config: Vec<std::collections::HashMap<String, String>>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LogConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Config" => return std::result::Result::Err("Parsing a container in this style is not supported in LogConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LogConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LogConfig {
            config: intermediate_rep.config.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LogConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LogConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LogConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LogConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LogConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LogConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LogConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// LogConfig describes the logging characteristics for a container



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LogConfigLibpod {
/// LogDriver is the container's log driver. Optional.
    #[serde(rename = "driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// A set of options to accompany the log driver. Optional.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

/// LogPath is the path the container's logs will be stored at. Only available if LogDriver is set to \"json-file\" or \"k8s-file\". Optional.
    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

/// Size is the maximum size of the log file Optional.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

}


impl LogConfigLibpod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> LogConfigLibpod {
        LogConfigLibpod {
            driver: None,
            options: None,
            path: None,
            size: None,
        }
    }
}

/// Converts the LogConfigLibpod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LogConfigLibpod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.driver.as_ref().map(|driver| {
                [
                    "driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),

            // Skipping options in query parameter serialization


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LogConfigLibpod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LogConfigLibpod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub path: Vec<String>,
            pub size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LogConfigLibpod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "options" => return std::result::Result::Err("Parsing a container in this style is not supported in LogConfigLibpod".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LogConfigLibpod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LogConfigLibpod {
            driver: intermediate_rep.driver.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LogConfigLibpod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LogConfigLibpod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LogConfigLibpod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for LogConfigLibpod - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LogConfigLibpod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LogConfigLibpod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into LogConfigLibpod - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MacAddress(Vec<integer>);

impl validator::Validate for MacAddress {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<Vec<integer>> for MacAddress {
    fn from(x: Vec<integer>) -> Self {
        MacAddress(x)
    }
}

impl std::convert::From<MacAddress> for Vec<integer> {
    fn from(x: MacAddress) -> Self {
        x.0
    }
}

impl std::iter::FromIterator<integer> for MacAddress {
    fn from_iter<U: IntoIterator<Item=integer>>(u: U) -> Self {
        MacAddress(Vec::<integer>::from_iter(u))
    }
}

impl std::iter::IntoIterator for MacAddress {
    type Item = integer;
    type IntoIter = std::vec::IntoIter<integer>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl<'a> std::iter::IntoIterator for &'a MacAddress {
    type Item = &'a integer;
    type IntoIter = std::slice::Iter<'a, integer>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.iter()
    }
}

impl<'a> std::iter::IntoIterator for &'a mut MacAddress {
    type Item = &'a mut integer;
    type IntoIter = std::slice::IterMut<'a, integer>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.iter_mut()
    }
}

impl std::ops::Deref for MacAddress {
    type Target = Vec<integer>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::ops::DerefMut for MacAddress {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

/// Converts the MacAddress value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MacAddress {
   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{}", self.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MacAddress value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MacAddress {
    type Err = <integer as std::str::FromStr>::Err;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        let mut items = vec![];
        for item in s.split(',')
        {
            items.push(item.parse()?);
        }
        std::result::Result::Ok(MacAddress(items))
    }
}


// Methods for converting between header::IntoHeaderValue<MacAddress> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MacAddress>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MacAddress>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MacAddress - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MacAddress> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MacAddress as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MacAddress - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ManifestAddArtifactOptions provides the model for creating artifact manifests for files and adding those manifests to a manifest list



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManifestAddArtifactOptions {
/// Annotation to add to the item in the manifest list
    #[serde(rename = "annotation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotation: Option<Vec<String>>,

/// Annotations to add to the item in the manifest list by a map which is preferred over Annotation
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// Arch overrides the architecture for the item in the manifest list
    #[serde(rename = "arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arch: Option<String>,

    #[serde(rename = "artifact_annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_annotations: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "artifact_config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_config: Option<String>,

    #[serde(rename = "artifact_config_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_config_type: Option<String>,

    #[serde(rename = "artifact_exclude_titles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_exclude_titles: Option<bool>,

    #[serde(rename = "artifact_files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_files: Option<Vec<String>>,

    #[serde(rename = "artifact_layer_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_layer_type: Option<String>,

    #[serde(rename = "artifact_subject")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_subject: Option<String>,

/// Note to future maintainers: keep these fields synchronized with ManifestModifyOptions!
    #[serde(rename = "artifact_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_type: Option<String>,

/// Feature list for the item in the manifest list
    #[serde(rename = "features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub features: Option<Vec<String>>,

/// IndexAnnotation is a slice of key=value annotations to add to the manifest list itself
    #[serde(rename = "index_annotation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_annotation: Option<Vec<String>>,

/// IndexAnnotations is a map of key:value annotations to add to the manifest list itself, by a map which is preferred over IndexAnnotation
    #[serde(rename = "index_annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_annotations: Option<std::collections::HashMap<String, String>>,

/// OS overrides the operating system for the item in the manifest list
    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

/// OS features for the item in the manifest list
    #[serde(rename = "os_features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_features: Option<Vec<String>>,

/// OSVersion overrides the operating system for the item in the manifest list
    #[serde(rename = "os_version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_version: Option<String>,

/// IndexSubject is a subject value to set in the manifest list itself
    #[serde(rename = "subject")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject: Option<String>,

/// Variant for the item in the manifest list
    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

}


impl ManifestAddArtifactOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ManifestAddArtifactOptions {
        ManifestAddArtifactOptions {
            annotation: None,
            annotations: None,
            arch: None,
            artifact_annotations: None,
            artifact_config: None,
            artifact_config_type: None,
            artifact_exclude_titles: None,
            artifact_files: None,
            artifact_layer_type: None,
            artifact_subject: None,
            artifact_type: None,
            features: None,
            index_annotation: None,
            index_annotations: None,
            os: None,
            os_features: None,
            os_version: None,
            subject: None,
            variant: None,
        }
    }
}

/// Converts the ManifestAddArtifactOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ManifestAddArtifactOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.annotation.as_ref().map(|annotation| {
                [
                    "annotation".to_string(),
                    annotation.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping annotations in query parameter serialization


            self.arch.as_ref().map(|arch| {
                [
                    "arch".to_string(),
                    arch.to_string(),
                ].join(",")
            }),

            // Skipping artifact_annotations in query parameter serialization


            self.artifact_config.as_ref().map(|artifact_config| {
                [
                    "artifact_config".to_string(),
                    artifact_config.to_string(),
                ].join(",")
            }),


            self.artifact_config_type.as_ref().map(|artifact_config_type| {
                [
                    "artifact_config_type".to_string(),
                    artifact_config_type.to_string(),
                ].join(",")
            }),


            self.artifact_exclude_titles.as_ref().map(|artifact_exclude_titles| {
                [
                    "artifact_exclude_titles".to_string(),
                    artifact_exclude_titles.to_string(),
                ].join(",")
            }),


            self.artifact_files.as_ref().map(|artifact_files| {
                [
                    "artifact_files".to_string(),
                    artifact_files.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.artifact_layer_type.as_ref().map(|artifact_layer_type| {
                [
                    "artifact_layer_type".to_string(),
                    artifact_layer_type.to_string(),
                ].join(",")
            }),


            self.artifact_subject.as_ref().map(|artifact_subject| {
                [
                    "artifact_subject".to_string(),
                    artifact_subject.to_string(),
                ].join(",")
            }),


            self.artifact_type.as_ref().map(|artifact_type| {
                [
                    "artifact_type".to_string(),
                    artifact_type.to_string(),
                ].join(",")
            }),


            self.features.as_ref().map(|features| {
                [
                    "features".to_string(),
                    features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.index_annotation.as_ref().map(|index_annotation| {
                [
                    "index_annotation".to_string(),
                    index_annotation.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping index_annotations in query parameter serialization


            self.os.as_ref().map(|os| {
                [
                    "os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.os_features.as_ref().map(|os_features| {
                [
                    "os_features".to_string(),
                    os_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os_version.as_ref().map(|os_version| {
                [
                    "os_version".to_string(),
                    os_version.to_string(),
                ].join(",")
            }),


            self.subject.as_ref().map(|subject| {
                [
                    "subject".to_string(),
                    subject.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ManifestAddArtifactOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ManifestAddArtifactOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotation: Vec<Vec<String>>,
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub arch: Vec<String>,
            pub artifact_annotations: Vec<std::collections::HashMap<String, String>>,
            pub artifact_config: Vec<String>,
            pub artifact_config_type: Vec<String>,
            pub artifact_exclude_titles: Vec<bool>,
            pub artifact_files: Vec<Vec<String>>,
            pub artifact_layer_type: Vec<String>,
            pub artifact_subject: Vec<String>,
            pub artifact_type: Vec<String>,
            pub features: Vec<Vec<String>>,
            pub index_annotation: Vec<Vec<String>>,
            pub index_annotations: Vec<std::collections::HashMap<String, String>>,
            pub os: Vec<String>,
            pub os_features: Vec<Vec<String>>,
            pub os_version: Vec<String>,
            pub subject: Vec<String>,
            pub variant: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ManifestAddArtifactOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "annotation" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddArtifactOptions".to_string()),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddArtifactOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "arch" => intermediate_rep.arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "artifact_annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddArtifactOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "artifact_config" => intermediate_rep.artifact_config.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "artifact_config_type" => intermediate_rep.artifact_config_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "artifact_exclude_titles" => intermediate_rep.artifact_exclude_titles.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "artifact_files" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddArtifactOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "artifact_layer_type" => intermediate_rep.artifact_layer_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "artifact_subject" => intermediate_rep.artifact_subject.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "artifact_type" => intermediate_rep.artifact_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "features" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddArtifactOptions".to_string()),
                    "index_annotation" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddArtifactOptions".to_string()),
                    "index_annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddArtifactOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "os_features" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddArtifactOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os_version" => intermediate_rep.os_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subject" => intermediate_rep.subject.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ManifestAddArtifactOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ManifestAddArtifactOptions {
            annotation: intermediate_rep.annotation.into_iter().next(),
            annotations: intermediate_rep.annotations.into_iter().next(),
            arch: intermediate_rep.arch.into_iter().next(),
            artifact_annotations: intermediate_rep.artifact_annotations.into_iter().next(),
            artifact_config: intermediate_rep.artifact_config.into_iter().next(),
            artifact_config_type: intermediate_rep.artifact_config_type.into_iter().next(),
            artifact_exclude_titles: intermediate_rep.artifact_exclude_titles.into_iter().next(),
            artifact_files: intermediate_rep.artifact_files.into_iter().next(),
            artifact_layer_type: intermediate_rep.artifact_layer_type.into_iter().next(),
            artifact_subject: intermediate_rep.artifact_subject.into_iter().next(),
            artifact_type: intermediate_rep.artifact_type.into_iter().next(),
            features: intermediate_rep.features.into_iter().next(),
            index_annotation: intermediate_rep.index_annotation.into_iter().next(),
            index_annotations: intermediate_rep.index_annotations.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            os_features: intermediate_rep.os_features.into_iter().next(),
            os_version: intermediate_rep.os_version.into_iter().next(),
            subject: intermediate_rep.subject.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ManifestAddArtifactOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ManifestAddArtifactOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ManifestAddArtifactOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ManifestAddArtifactOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ManifestAddArtifactOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ManifestAddArtifactOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ManifestAddArtifactOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ManifestAddOptions provides model for adding digests to manifest list



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManifestAddOptions {
/// True when operating on a list to include all images
    #[serde(rename = "all")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub all: Option<bool>,

/// Annotation to add to the item in the manifest list
    #[serde(rename = "annotation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotation: Option<Vec<String>>,

/// Annotations to add to the item in the manifest list by a map which is preferred over Annotation
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// Arch overrides the architecture for the item in the manifest list
    #[serde(rename = "arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arch: Option<String>,

/// Feature list for the item in the manifest list
    #[serde(rename = "features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub features: Option<Vec<String>>,

/// Images is an optional list of image references to add to manifest list
    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<Vec<String>>,

/// IndexAnnotation is a slice of key=value annotations to add to the manifest list itself
    #[serde(rename = "index_annotation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_annotation: Option<Vec<String>>,

/// IndexAnnotations is a map of key:value annotations to add to the manifest list itself, by a map which is preferred over IndexAnnotation
    #[serde(rename = "index_annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_annotations: Option<std::collections::HashMap<String, String>>,

/// OS overrides the operating system for the item in the manifest list
    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

/// OS features for the item in the manifest list
    #[serde(rename = "os_features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_features: Option<Vec<String>>,

/// OSVersion overrides the operating system for the item in the manifest list
    #[serde(rename = "os_version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_version: Option<String>,

/// IndexSubject is a subject value to set in the manifest list itself
    #[serde(rename = "subject")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject: Option<String>,

/// Variant for the item in the manifest list
    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

}


impl ManifestAddOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ManifestAddOptions {
        ManifestAddOptions {
            all: None,
            annotation: None,
            annotations: None,
            arch: None,
            features: None,
            images: None,
            index_annotation: None,
            index_annotations: None,
            os: None,
            os_features: None,
            os_version: None,
            subject: None,
            variant: None,
        }
    }
}

/// Converts the ManifestAddOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ManifestAddOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.all.as_ref().map(|all| {
                [
                    "all".to_string(),
                    all.to_string(),
                ].join(",")
            }),


            self.annotation.as_ref().map(|annotation| {
                [
                    "annotation".to_string(),
                    annotation.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping annotations in query parameter serialization


            self.arch.as_ref().map(|arch| {
                [
                    "arch".to_string(),
                    arch.to_string(),
                ].join(",")
            }),


            self.features.as_ref().map(|features| {
                [
                    "features".to_string(),
                    features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.images.as_ref().map(|images| {
                [
                    "images".to_string(),
                    images.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.index_annotation.as_ref().map(|index_annotation| {
                [
                    "index_annotation".to_string(),
                    index_annotation.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping index_annotations in query parameter serialization


            self.os.as_ref().map(|os| {
                [
                    "os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.os_features.as_ref().map(|os_features| {
                [
                    "os_features".to_string(),
                    os_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os_version.as_ref().map(|os_version| {
                [
                    "os_version".to_string(),
                    os_version.to_string(),
                ].join(",")
            }),


            self.subject.as_ref().map(|subject| {
                [
                    "subject".to_string(),
                    subject.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ManifestAddOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ManifestAddOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub all: Vec<bool>,
            pub annotation: Vec<Vec<String>>,
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub arch: Vec<String>,
            pub features: Vec<Vec<String>>,
            pub images: Vec<Vec<String>>,
            pub index_annotation: Vec<Vec<String>>,
            pub index_annotations: Vec<std::collections::HashMap<String, String>>,
            pub os: Vec<String>,
            pub os_features: Vec<Vec<String>>,
            pub os_version: Vec<String>,
            pub subject: Vec<String>,
            pub variant: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ManifestAddOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "all" => intermediate_rep.all.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "annotation" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddOptions".to_string()),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "arch" => intermediate_rep.arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "features" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddOptions".to_string()),
                    "images" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddOptions".to_string()),
                    "index_annotation" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddOptions".to_string()),
                    "index_annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "os_features" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAddOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os_version" => intermediate_rep.os_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subject" => intermediate_rep.subject.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ManifestAddOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ManifestAddOptions {
            all: intermediate_rep.all.into_iter().next(),
            annotation: intermediate_rep.annotation.into_iter().next(),
            annotations: intermediate_rep.annotations.into_iter().next(),
            arch: intermediate_rep.arch.into_iter().next(),
            features: intermediate_rep.features.into_iter().next(),
            images: intermediate_rep.images.into_iter().next(),
            index_annotation: intermediate_rep.index_annotation.into_iter().next(),
            index_annotations: intermediate_rep.index_annotations.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            os_features: intermediate_rep.os_features.into_iter().next(),
            os_version: intermediate_rep.os_version.into_iter().next(),
            subject: intermediate_rep.subject.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ManifestAddOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ManifestAddOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ManifestAddOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ManifestAddOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ManifestAddOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ManifestAddOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ManifestAddOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ManifestAnnotateOptions provides model for annotating manifest list



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManifestAnnotateOptions {
/// Annotation to add to the item in the manifest list
    #[serde(rename = "annotation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotation: Option<Vec<String>>,

/// Annotations to add to the item in the manifest list by a map which is preferred over Annotation
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// Arch overrides the architecture for the item in the manifest list
    #[serde(rename = "arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arch: Option<String>,

/// Feature list for the item in the manifest list
    #[serde(rename = "features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub features: Option<Vec<String>>,

/// IndexAnnotation is a slice of key=value annotations to add to the manifest list itself
    #[serde(rename = "index_annotation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_annotation: Option<Vec<String>>,

/// IndexAnnotations is a map of key:value annotations to add to the manifest list itself, by a map which is preferred over IndexAnnotation
    #[serde(rename = "index_annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_annotations: Option<std::collections::HashMap<String, String>>,

/// OS overrides the operating system for the item in the manifest list
    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

/// OS features for the item in the manifest list
    #[serde(rename = "os_features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_features: Option<Vec<String>>,

/// OSVersion overrides the operating system for the item in the manifest list
    #[serde(rename = "os_version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_version: Option<String>,

/// IndexSubject is a subject value to set in the manifest list itself
    #[serde(rename = "subject")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject: Option<String>,

/// Variant for the item in the manifest list
    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

}


impl ManifestAnnotateOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ManifestAnnotateOptions {
        ManifestAnnotateOptions {
            annotation: None,
            annotations: None,
            arch: None,
            features: None,
            index_annotation: None,
            index_annotations: None,
            os: None,
            os_features: None,
            os_version: None,
            subject: None,
            variant: None,
        }
    }
}

/// Converts the ManifestAnnotateOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ManifestAnnotateOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.annotation.as_ref().map(|annotation| {
                [
                    "annotation".to_string(),
                    annotation.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping annotations in query parameter serialization


            self.arch.as_ref().map(|arch| {
                [
                    "arch".to_string(),
                    arch.to_string(),
                ].join(",")
            }),


            self.features.as_ref().map(|features| {
                [
                    "features".to_string(),
                    features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.index_annotation.as_ref().map(|index_annotation| {
                [
                    "index_annotation".to_string(),
                    index_annotation.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping index_annotations in query parameter serialization


            self.os.as_ref().map(|os| {
                [
                    "os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.os_features.as_ref().map(|os_features| {
                [
                    "os_features".to_string(),
                    os_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os_version.as_ref().map(|os_version| {
                [
                    "os_version".to_string(),
                    os_version.to_string(),
                ].join(",")
            }),


            self.subject.as_ref().map(|subject| {
                [
                    "subject".to_string(),
                    subject.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ManifestAnnotateOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ManifestAnnotateOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub annotation: Vec<Vec<String>>,
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub arch: Vec<String>,
            pub features: Vec<Vec<String>>,
            pub index_annotation: Vec<Vec<String>>,
            pub index_annotations: Vec<std::collections::HashMap<String, String>>,
            pub os: Vec<String>,
            pub os_features: Vec<Vec<String>>,
            pub os_version: Vec<String>,
            pub subject: Vec<String>,
            pub variant: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ManifestAnnotateOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "annotation" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAnnotateOptions".to_string()),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAnnotateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "arch" => intermediate_rep.arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "features" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAnnotateOptions".to_string()),
                    "index_annotation" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAnnotateOptions".to_string()),
                    "index_annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAnnotateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "os_features" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestAnnotateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os_version" => intermediate_rep.os_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subject" => intermediate_rep.subject.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ManifestAnnotateOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ManifestAnnotateOptions {
            annotation: intermediate_rep.annotation.into_iter().next(),
            annotations: intermediate_rep.annotations.into_iter().next(),
            arch: intermediate_rep.arch.into_iter().next(),
            features: intermediate_rep.features.into_iter().next(),
            index_annotation: intermediate_rep.index_annotation.into_iter().next(),
            index_annotations: intermediate_rep.index_annotations.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            os_features: intermediate_rep.os_features.into_iter().next(),
            os_version: intermediate_rep.os_version.into_iter().next(),
            subject: intermediate_rep.subject.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ManifestAnnotateOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ManifestAnnotateOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ManifestAnnotateOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ManifestAnnotateOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ManifestAnnotateOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ManifestAnnotateOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ManifestAnnotateOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// swagger 2.0 does not support oneOf for schema validation.  Operation \"update\" uses all fields. Operation \"remove\" uses fields: Operation and Images Operation \"annotate\" uses fields: Operation and Annotations



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManifestModifyOptions {
/// True when operating on a list to include all images
    #[serde(rename = "all")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub all: Option<bool>,

/// Annotation to add to the item in the manifest list
    #[serde(rename = "annotation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotation: Option<Vec<String>>,

/// Annotations to add to the item in the manifest list by a map which is preferred over Annotation
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// Arch overrides the architecture for the item in the manifest list
    #[serde(rename = "arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arch: Option<String>,

    #[serde(rename = "artifact_annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_annotations: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "artifact_config")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_config: Option<String>,

    #[serde(rename = "artifact_config_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_config_type: Option<String>,

    #[serde(rename = "artifact_exclude_titles")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_exclude_titles: Option<bool>,

    #[serde(rename = "artifact_files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_files: Option<Vec<String>>,

    #[serde(rename = "artifact_layer_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_layer_type: Option<String>,

    #[serde(rename = "artifact_subject")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_subject: Option<String>,

/// The following are all of the fields from ManifestAddArtifactOptions. We can't just embed the whole structure because it embeds a ManifestAnnotateOptions, which would conflict with the one that ManifestAddOptions embeds.
    #[serde(rename = "artifact_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_type: Option<String>,

/// Feature list for the item in the manifest list
    #[serde(rename = "features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub features: Option<Vec<String>>,

/// Images is an optional list of image references to add to manifest list
    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<Vec<String>>,

/// IndexAnnotation is a slice of key=value annotations to add to the manifest list itself
    #[serde(rename = "index_annotation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_annotation: Option<Vec<String>>,

/// IndexAnnotations is a map of key:value annotations to add to the manifest list itself, by a map which is preferred over IndexAnnotation
    #[serde(rename = "index_annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index_annotations: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "operation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operation: Option<String>,

/// OS overrides the operating system for the item in the manifest list
    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

/// OS features for the item in the manifest list
    #[serde(rename = "os_features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_features: Option<Vec<String>>,

/// OSVersion overrides the operating system for the item in the manifest list
    #[serde(rename = "os_version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_version: Option<String>,

/// IndexSubject is a subject value to set in the manifest list itself
    #[serde(rename = "subject")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject: Option<String>,

/// Variant for the item in the manifest list
    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

}


impl ManifestModifyOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ManifestModifyOptions {
        ManifestModifyOptions {
            all: None,
            annotation: None,
            annotations: None,
            arch: None,
            artifact_annotations: None,
            artifact_config: None,
            artifact_config_type: None,
            artifact_exclude_titles: None,
            artifact_files: None,
            artifact_layer_type: None,
            artifact_subject: None,
            artifact_type: None,
            features: None,
            images: None,
            index_annotation: None,
            index_annotations: None,
            operation: None,
            os: None,
            os_features: None,
            os_version: None,
            subject: None,
            variant: None,
        }
    }
}

/// Converts the ManifestModifyOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ManifestModifyOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.all.as_ref().map(|all| {
                [
                    "all".to_string(),
                    all.to_string(),
                ].join(",")
            }),


            self.annotation.as_ref().map(|annotation| {
                [
                    "annotation".to_string(),
                    annotation.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping annotations in query parameter serialization


            self.arch.as_ref().map(|arch| {
                [
                    "arch".to_string(),
                    arch.to_string(),
                ].join(",")
            }),

            // Skipping artifact_annotations in query parameter serialization


            self.artifact_config.as_ref().map(|artifact_config| {
                [
                    "artifact_config".to_string(),
                    artifact_config.to_string(),
                ].join(",")
            }),


            self.artifact_config_type.as_ref().map(|artifact_config_type| {
                [
                    "artifact_config_type".to_string(),
                    artifact_config_type.to_string(),
                ].join(",")
            }),


            self.artifact_exclude_titles.as_ref().map(|artifact_exclude_titles| {
                [
                    "artifact_exclude_titles".to_string(),
                    artifact_exclude_titles.to_string(),
                ].join(",")
            }),


            self.artifact_files.as_ref().map(|artifact_files| {
                [
                    "artifact_files".to_string(),
                    artifact_files.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.artifact_layer_type.as_ref().map(|artifact_layer_type| {
                [
                    "artifact_layer_type".to_string(),
                    artifact_layer_type.to_string(),
                ].join(",")
            }),


            self.artifact_subject.as_ref().map(|artifact_subject| {
                [
                    "artifact_subject".to_string(),
                    artifact_subject.to_string(),
                ].join(",")
            }),


            self.artifact_type.as_ref().map(|artifact_type| {
                [
                    "artifact_type".to_string(),
                    artifact_type.to_string(),
                ].join(",")
            }),


            self.features.as_ref().map(|features| {
                [
                    "features".to_string(),
                    features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.images.as_ref().map(|images| {
                [
                    "images".to_string(),
                    images.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.index_annotation.as_ref().map(|index_annotation| {
                [
                    "index_annotation".to_string(),
                    index_annotation.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping index_annotations in query parameter serialization


            self.operation.as_ref().map(|operation| {
                [
                    "operation".to_string(),
                    operation.to_string(),
                ].join(",")
            }),


            self.os.as_ref().map(|os| {
                [
                    "os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.os_features.as_ref().map(|os_features| {
                [
                    "os_features".to_string(),
                    os_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os_version.as_ref().map(|os_version| {
                [
                    "os_version".to_string(),
                    os_version.to_string(),
                ].join(",")
            }),


            self.subject.as_ref().map(|subject| {
                [
                    "subject".to_string(),
                    subject.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ManifestModifyOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ManifestModifyOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub all: Vec<bool>,
            pub annotation: Vec<Vec<String>>,
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub arch: Vec<String>,
            pub artifact_annotations: Vec<std::collections::HashMap<String, String>>,
            pub artifact_config: Vec<String>,
            pub artifact_config_type: Vec<String>,
            pub artifact_exclude_titles: Vec<bool>,
            pub artifact_files: Vec<Vec<String>>,
            pub artifact_layer_type: Vec<String>,
            pub artifact_subject: Vec<String>,
            pub artifact_type: Vec<String>,
            pub features: Vec<Vec<String>>,
            pub images: Vec<Vec<String>>,
            pub index_annotation: Vec<Vec<String>>,
            pub index_annotations: Vec<std::collections::HashMap<String, String>>,
            pub operation: Vec<String>,
            pub os: Vec<String>,
            pub os_features: Vec<Vec<String>>,
            pub os_version: Vec<String>,
            pub subject: Vec<String>,
            pub variant: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ManifestModifyOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "all" => intermediate_rep.all.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "annotation" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "arch" => intermediate_rep.arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "artifact_annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "artifact_config" => intermediate_rep.artifact_config.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "artifact_config_type" => intermediate_rep.artifact_config_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "artifact_exclude_titles" => intermediate_rep.artifact_exclude_titles.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "artifact_files" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "artifact_layer_type" => intermediate_rep.artifact_layer_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "artifact_subject" => intermediate_rep.artifact_subject.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "artifact_type" => intermediate_rep.artifact_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "features" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    "images" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    "index_annotation" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    "index_annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "operation" => intermediate_rep.operation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "os_features" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os_version" => intermediate_rep.os_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subject" => intermediate_rep.subject.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ManifestModifyOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ManifestModifyOptions {
            all: intermediate_rep.all.into_iter().next(),
            annotation: intermediate_rep.annotation.into_iter().next(),
            annotations: intermediate_rep.annotations.into_iter().next(),
            arch: intermediate_rep.arch.into_iter().next(),
            artifact_annotations: intermediate_rep.artifact_annotations.into_iter().next(),
            artifact_config: intermediate_rep.artifact_config.into_iter().next(),
            artifact_config_type: intermediate_rep.artifact_config_type.into_iter().next(),
            artifact_exclude_titles: intermediate_rep.artifact_exclude_titles.into_iter().next(),
            artifact_files: intermediate_rep.artifact_files.into_iter().next(),
            artifact_layer_type: intermediate_rep.artifact_layer_type.into_iter().next(),
            artifact_subject: intermediate_rep.artifact_subject.into_iter().next(),
            artifact_type: intermediate_rep.artifact_type.into_iter().next(),
            features: intermediate_rep.features.into_iter().next(),
            images: intermediate_rep.images.into_iter().next(),
            index_annotation: intermediate_rep.index_annotation.into_iter().next(),
            index_annotations: intermediate_rep.index_annotations.into_iter().next(),
            operation: intermediate_rep.operation.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            os_features: intermediate_rep.os_features.into_iter().next(),
            os_version: intermediate_rep.os_version.into_iter().next(),
            subject: intermediate_rep.subject.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ManifestModifyOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ManifestModifyOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ManifestModifyOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ManifestModifyOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ManifestModifyOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ManifestModifyOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ManifestModifyOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManifestModifyReport {
/// Manifest List ID
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Errors associated with operation
    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<String>>,

/// Files added to manifest list, otherwise not provided.
    #[serde(rename = "files")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<Vec<String>>,

/// Images added to or removed from manifest list, otherwise not provided.
    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<Vec<String>>,

}


impl ManifestModifyReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ManifestModifyReport {
        ManifestModifyReport {
            id: None,
            errors: None,
            files: None,
            images: None,
        }
    }
}

/// Converts the ManifestModifyReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ManifestModifyReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.errors.as_ref().map(|errors| {
                [
                    "errors".to_string(),
                    errors.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.files.as_ref().map(|files| {
                [
                    "files".to_string(),
                    files.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.images.as_ref().map(|images| {
                [
                    "images".to_string(),
                    images.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ManifestModifyReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ManifestModifyReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub errors: Vec<Vec<String>>,
            pub files: Vec<Vec<String>>,
            pub images: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ManifestModifyReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyReport".to_string()),
                    "files" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyReport".to_string()),
                    "images" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestModifyReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ManifestModifyReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ManifestModifyReport {
            id: intermediate_rep.id.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
            files: intermediate_rep.files.into_iter().next(),
            images: intermediate_rep.images.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ManifestModifyReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ManifestModifyReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ManifestModifyReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ManifestModifyReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ManifestModifyReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ManifestModifyReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ManifestModifyReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManifestPushReport {
/// ID of the pushed manifest
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Error contains text of errors from pushing
    #[serde(rename = "error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,

/// Stream used to provide push progress
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<String>,

}


impl ManifestPushReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ManifestPushReport {
        ManifestPushReport {
            id: None,
            error: None,
            stream: None,
        }
    }
}

/// Converts the ManifestPushReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ManifestPushReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.error.as_ref().map(|error| {
                [
                    "error".to_string(),
                    error.to_string(),
                ].join(",")
            }),


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ManifestPushReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ManifestPushReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub error: Vec<String>,
            pub stream: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ManifestPushReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stream" => intermediate_rep.stream.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ManifestPushReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ManifestPushReport {
            id: intermediate_rep.id.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
            stream: intermediate_rep.stream.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ManifestPushReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ManifestPushReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ManifestPushReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ManifestPushReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ManifestPushReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ManifestPushReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ManifestPushReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ManifestRemoveReport {
/// Deleted manifest list.
    #[serde(rename = "Deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<Vec<String>>,

/// Errors associated with operation
    #[serde(rename = "Errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<String>>,

/// ExitCode describes the exit codes as described in the `podman rmi` man page.
    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i64>,

/// Untagged images. Can be longer than Deleted.
    #[serde(rename = "Untagged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub untagged: Option<Vec<String>>,

}


impl ManifestRemoveReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ManifestRemoveReport {
        ManifestRemoveReport {
            deleted: None,
            errors: None,
            exit_code: None,
            untagged: None,
        }
    }
}

/// Converts the ManifestRemoveReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ManifestRemoveReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.deleted.as_ref().map(|deleted| {
                [
                    "Deleted".to_string(),
                    deleted.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.errors.as_ref().map(|errors| {
                [
                    "Errors".to_string(),
                    errors.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),


            self.untagged.as_ref().map(|untagged| {
                [
                    "Untagged".to_string(),
                    untagged.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ManifestRemoveReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ManifestRemoveReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub deleted: Vec<Vec<String>>,
            pub errors: Vec<Vec<String>>,
            pub exit_code: Vec<i64>,
            pub untagged: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ManifestRemoveReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Deleted" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestRemoveReport".to_string()),
                    "Errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestRemoveReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Untagged" => return std::result::Result::Err("Parsing a container in this style is not supported in ManifestRemoveReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ManifestRemoveReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ManifestRemoveReport {
            deleted: intermediate_rep.deleted.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            untagged: intermediate_rep.untagged.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ManifestRemoveReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ManifestRemoveReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ManifestRemoveReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ManifestRemoveReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ManifestRemoveReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ManifestRemoveReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ManifestRemoveReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Meta {
    #[serde(rename = "CreatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "UpdatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<models::Version>,

}


impl Meta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Meta {
        Meta {
            created_at: None,
            updated_at: None,
            version: None,
        }
    }
}

/// Converts the Meta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Meta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CreatedAt in query parameter serialization

            // Skipping UpdatedAt in query parameter serialization

            // Skipping Version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Meta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Meta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub version: Vec<models::Version>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Meta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CreatedAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UpdatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Version" => intermediate_rep.version.push(<models::Version as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Meta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Meta {
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Meta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Meta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Meta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Meta - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Meta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Meta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Meta - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Metadata {
/// LastTagTime is the date and time at which the image was last tagged.
    #[serde(rename = "LastTagTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_tag_time: Option<chrono::DateTime::<chrono::Utc>>,

}


impl Metadata {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Metadata {
        Metadata {
            last_tag_time: None,
        }
    }
}

/// Converts the Metadata value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Metadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping LastTagTime in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Metadata value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Metadata {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub last_tag_time: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Metadata".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "LastTagTime" => intermediate_rep.last_tag_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Metadata".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Metadata {
            last_tag_time: intermediate_rep.last_tag_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Metadata> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Metadata>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Metadata>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Metadata - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Metadata> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Metadata as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Metadata - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Mount {
    #[serde(rename = "BindOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bind_options: Option<models::BindOptions>,

    #[serde(rename = "ClusterOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cluster_options: Option<crate::types::Object>,

    #[serde(rename = "Consistency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub consistency: Option<String>,

    #[serde(rename = "ReadOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,

/// Source specifies the name of the mount. Depending on mount type, this may be a volume name or a host path, or even ignored. Source is not supported for tmpfs (must be an empty value)
    #[serde(rename = "Source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,

    #[serde(rename = "Target")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,

    #[serde(rename = "TmpfsOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tmpfs_options: Option<models::TmpfsOptions>,

    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "VolumeOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_options: Option<models::VolumeOptions>,

}


impl Mount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Mount {
        Mount {
            bind_options: None,
            cluster_options: None,
            consistency: None,
            read_only: None,
            source: None,
            target: None,
            tmpfs_options: None,
            r#type: None,
            volume_options: None,
        }
    }
}

/// Converts the Mount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Mount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping BindOptions in query parameter serialization

            // Skipping ClusterOptions in query parameter serialization


            self.consistency.as_ref().map(|consistency| {
                [
                    "Consistency".to_string(),
                    consistency.to_string(),
                ].join(",")
            }),


            self.read_only.as_ref().map(|read_only| {
                [
                    "ReadOnly".to_string(),
                    read_only.to_string(),
                ].join(",")
            }),


            self.source.as_ref().map(|source| {
                [
                    "Source".to_string(),
                    source.to_string(),
                ].join(",")
            }),


            self.target.as_ref().map(|target| {
                [
                    "Target".to_string(),
                    target.to_string(),
                ].join(",")
            }),

            // Skipping TmpfsOptions in query parameter serialization


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

            // Skipping VolumeOptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Mount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Mount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bind_options: Vec<models::BindOptions>,
            pub cluster_options: Vec<crate::types::Object>,
            pub consistency: Vec<String>,
            pub read_only: Vec<bool>,
            pub source: Vec<String>,
            pub target: Vec<String>,
            pub tmpfs_options: Vec<models::TmpfsOptions>,
            pub r#type: Vec<String>,
            pub volume_options: Vec<models::VolumeOptions>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Mount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "BindOptions" => intermediate_rep.bind_options.push(<models::BindOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ClusterOptions" => intermediate_rep.cluster_options.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Consistency" => intermediate_rep.consistency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ReadOnly" => intermediate_rep.read_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Source" => intermediate_rep.source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Target" => intermediate_rep.target.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "TmpfsOptions" => intermediate_rep.tmpfs_options.push(<models::TmpfsOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VolumeOptions" => intermediate_rep.volume_options.push(<models::VolumeOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Mount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Mount {
            bind_options: intermediate_rep.bind_options.into_iter().next(),
            cluster_options: intermediate_rep.cluster_options.into_iter().next(),
            consistency: intermediate_rep.consistency.into_iter().next(),
            read_only: intermediate_rep.read_only.into_iter().next(),
            source: intermediate_rep.source.into_iter().next(),
            target: intermediate_rep.target.into_iter().next(),
            tmpfs_options: intermediate_rep.tmpfs_options.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            volume_options: intermediate_rep.volume_options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Mount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Mount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Mount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Mount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Mount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Mount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Mount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// This is used for reporting the mountpoints in use by a container.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MountPoint {
/// Destination is the path relative to the container root (`/`) where the Source is mounted inside the container.
    #[serde(rename = "Destination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination: Option<String>,

/// Driver is the volume driver used to create the volume (if it is a volume).
    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// Mode is a comma separated list of options supplied by the user when creating the bind/volume mount.  The default is platform-specific (`\"z\"` on Linux, empty on Windows).
    #[serde(rename = "Mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,

/// Name is the name reference to the underlying data defined by `Source` e.g., the volume name.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Propagation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub propagation: Option<String>,

/// RW indicates whether the mount is mounted writable (read-write).
    #[serde(rename = "RW")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rw: Option<bool>,

/// Source is the source location of the mount.  For volumes, this contains the storage location of the volume (within `/var/lib/docker/volumes/`). For bind-mounts, and `npipe`, this contains the source (host) part of the bind-mount. For `tmpfs` mount points, this field is empty.
    #[serde(rename = "Source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,

    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl MountPoint {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MountPoint {
        MountPoint {
            destination: None,
            driver: None,
            mode: None,
            name: None,
            propagation: None,
            rw: None,
            source: None,
            r#type: None,
        }
    }
}

/// Converts the MountPoint value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MountPoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.destination.as_ref().map(|destination| {
                [
                    "Destination".to_string(),
                    destination.to_string(),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.mode.as_ref().map(|mode| {
                [
                    "Mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.propagation.as_ref().map(|propagation| {
                [
                    "Propagation".to_string(),
                    propagation.to_string(),
                ].join(",")
            }),


            self.rw.as_ref().map(|rw| {
                [
                    "RW".to_string(),
                    rw.to_string(),
                ].join(",")
            }),


            self.source.as_ref().map(|source| {
                [
                    "Source".to_string(),
                    source.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MountPoint value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MountPoint {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub destination: Vec<String>,
            pub driver: Vec<String>,
            pub mode: Vec<String>,
            pub name: Vec<String>,
            pub propagation: Vec<String>,
            pub rw: Vec<bool>,
            pub source: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MountPoint".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Destination" => intermediate_rep.destination.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Mode" => intermediate_rep.mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Propagation" => intermediate_rep.propagation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RW" => intermediate_rep.rw.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Source" => intermediate_rep.source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MountPoint".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MountPoint {
            destination: intermediate_rep.destination.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            mode: intermediate_rep.mode.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            propagation: intermediate_rep.propagation.into_iter().next(),
            rw: intermediate_rep.rw.into_iter().next(),
            source: intermediate_rep.source.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MountPoint> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MountPoint>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MountPoint>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MountPoint - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MountPoint> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MountPoint as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MountPoint - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NamedVolume holds information about a named volume that will be mounted into the container.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NamedVolume {
/// Destination to mount the named volume within the container. Must be an absolute path. Path will be created if it does not exist.
    #[serde(rename = "Dest")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dest: Option<String>,

/// IsAnonymous sets the named volume as anonymous even if it has a name This is used for emptyDir volumes from a kube yaml
    #[serde(rename = "IsAnonymous")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_anonymous: Option<bool>,

/// Name is the name of the named volume to be mounted. May be empty. If empty, a new named volume with a pseudorandomly generated name will be mounted at the given destination.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Options are options that the named volume will be mounted with.
    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<Vec<String>>,

/// SubPath stores the sub directory of the named volume to be mounted in the container
    #[serde(rename = "SubPath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_path: Option<String>,

}


impl NamedVolume {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NamedVolume {
        NamedVolume {
            dest: None,
            is_anonymous: None,
            name: None,
            options: None,
            sub_path: None,
        }
    }
}

/// Converts the NamedVolume value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NamedVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.dest.as_ref().map(|dest| {
                [
                    "Dest".to_string(),
                    dest.to_string(),
                ].join(",")
            }),


            self.is_anonymous.as_ref().map(|is_anonymous| {
                [
                    "IsAnonymous".to_string(),
                    is_anonymous.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.options.as_ref().map(|options| {
                [
                    "Options".to_string(),
                    options.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.sub_path.as_ref().map(|sub_path| {
                [
                    "SubPath".to_string(),
                    sub_path.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NamedVolume value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NamedVolume {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dest: Vec<String>,
            pub is_anonymous: Vec<bool>,
            pub name: Vec<String>,
            pub options: Vec<Vec<String>>,
            pub sub_path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NamedVolume".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Dest" => intermediate_rep.dest.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IsAnonymous" => intermediate_rep.is_anonymous.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in NamedVolume".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SubPath" => intermediate_rep.sub_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NamedVolume".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NamedVolume {
            dest: intermediate_rep.dest.into_iter().next(),
            is_anonymous: intermediate_rep.is_anonymous.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            sub_path: intermediate_rep.sub_path.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NamedVolume> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NamedVolume>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NamedVolume>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NamedVolume - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NamedVolume> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NamedVolume as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NamedVolume - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Namespace describes the namespace



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Namespace {
    #[serde(rename = "nsmode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nsmode: Option<String>,

    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

}


impl Namespace {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Namespace {
        Namespace {
            nsmode: None,
            value: None,
        }
    }
}

/// Converts the Namespace value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Namespace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.nsmode.as_ref().map(|nsmode| {
                [
                    "nsmode".to_string(),
                    nsmode.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Namespace value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Namespace {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub nsmode: Vec<String>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Namespace".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "nsmode" => intermediate_rep.nsmode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Namespace".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Namespace {
            nsmode: intermediate_rep.nsmode.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Namespace> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Namespace>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Namespace>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Namespace - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Namespace> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Namespace as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Namespace - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NamespaceMode(String);

impl validator::Validate for NamespaceMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for NamespaceMode {
    fn from(x: String) -> Self {
        NamespaceMode(x)
    }
}

impl std::fmt::Display for NamespaceMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for NamespaceMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NamespaceMode(x.to_string()))
    }
}

impl std::convert::From<NamespaceMode> for String {
    fn from(x: NamespaceMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for NamespaceMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NamespaceMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetAddress {
/// Gateway for the network. This can be empty if there is no gateway, e.g. internal network.
    #[serde(rename = "gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

    #[serde(rename = "ipnet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipnet: Option<models::IpNet>,

}


impl NetAddress {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetAddress {
        NetAddress {
            gateway: None,
            ipnet: None,
        }
    }
}

/// Converts the NetAddress value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.gateway.as_ref().map(|gateway| {
                [
                    "gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),

            // Skipping ipnet in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetAddress value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetAddress {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gateway: Vec<String>,
            pub ipnet: Vec<models::IpNet>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetAddress".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipnet" => intermediate_rep.ipnet.push(<models::IpNet as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetAddress".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetAddress {
            gateway: intermediate_rep.gateway.into_iter().next(),
            ipnet: intermediate_rep.ipnet.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetAddress> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetAddress>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetAddress>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetAddress - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetAddress> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetAddress as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetAddress - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetInterface {
/// MacAddress for this Interface.
    #[serde(rename = "mac_address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

/// Subnets list of assigned subnets with their gateway.
    #[serde(rename = "subnets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subnets: Option<Vec<models::NetAddress>>,

}


impl NetInterface {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetInterface {
        NetInterface {
            mac_address: None,
            subnets: None,
        }
    }
}

/// Converts the NetInterface value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.mac_address.as_ref().map(|mac_address| {
                [
                    "mac_address".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),

            // Skipping subnets in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetInterface value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetInterface {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mac_address: Vec<String>,
            pub subnets: Vec<Vec<models::NetAddress>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetInterface".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "mac_address" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "subnets" => return std::result::Result::Err("Parsing a container in this style is not supported in NetInterface".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetInterface".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetInterface {
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            subnets: intermediate_rep.subnets.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetInterface> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetInterface>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetInterface>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetInterface - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetInterface> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetInterface as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetInterface - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetOptions reflect the shared network options between pods and containers



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetOptions {
    #[serde(rename = "dns_option")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_option: Option<Vec<String>>,

    #[serde(rename = "dns_search")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

    #[serde(rename = "dns_server")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_server: Option<Vec<String>>,

    #[serde(rename = "hostadd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostadd: Option<Vec<String>>,

    #[serde(rename = "netns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub netns: Option<models::Namespace>,

    #[serde(rename = "network_alias")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_alias: Option<Vec<String>>,

/// NetworkOptions are additional options for each network
    #[serde(rename = "network_options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_options: Option<std::collections::HashMap<String, Vec<String>>>,

    #[serde(rename = "networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<std::collections::HashMap<String, models::PerNetworkOptions>>,

    #[serde(rename = "no_manage_hosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_manage_hosts: Option<bool>,

    #[serde(rename = "no_manage_resolv_conf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_manage_resolv_conf: Option<bool>,

    #[serde(rename = "portmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub portmappings: Option<Vec<models::PortMapping>>,

}


impl NetOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetOptions {
        NetOptions {
            dns_option: None,
            dns_search: None,
            dns_server: None,
            hostadd: None,
            netns: None,
            network_alias: None,
            network_options: None,
            networks: None,
            no_manage_hosts: None,
            no_manage_resolv_conf: None,
            portmappings: None,
        }
    }
}

/// Converts the NetOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.dns_option.as_ref().map(|dns_option| {
                [
                    "dns_option".to_string(),
                    dns_option.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "dns_search".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_server.as_ref().map(|dns_server| {
                [
                    "dns_server".to_string(),
                    dns_server.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.hostadd.as_ref().map(|hostadd| {
                [
                    "hostadd".to_string(),
                    hostadd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping netns in query parameter serialization


            self.network_alias.as_ref().map(|network_alias| {
                [
                    "network_alias".to_string(),
                    network_alias.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping network_options in query parameter serialization
            // Skipping network_options in query parameter serialization

            // Skipping networks in query parameter serialization
            // Skipping networks in query parameter serialization


            self.no_manage_hosts.as_ref().map(|no_manage_hosts| {
                [
                    "no_manage_hosts".to_string(),
                    no_manage_hosts.to_string(),
                ].join(",")
            }),


            self.no_manage_resolv_conf.as_ref().map(|no_manage_resolv_conf| {
                [
                    "no_manage_resolv_conf".to_string(),
                    no_manage_resolv_conf.to_string(),
                ].join(",")
            }),

            // Skipping portmappings in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub dns_option: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub dns_server: Vec<Vec<String>>,
            pub hostadd: Vec<Vec<String>>,
            pub netns: Vec<models::Namespace>,
            pub network_alias: Vec<Vec<String>>,
            pub network_options: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub networks: Vec<std::collections::HashMap<String, models::PerNetworkOptions>>,
            pub no_manage_hosts: Vec<bool>,
            pub no_manage_resolv_conf: Vec<bool>,
            pub portmappings: Vec<Vec<models::PortMapping>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "dns_option" => return std::result::Result::Err("Parsing a container in this style is not supported in NetOptions".to_string()),
                    "dns_search" => return std::result::Result::Err("Parsing a container in this style is not supported in NetOptions".to_string()),
                    "dns_server" => return std::result::Result::Err("Parsing a container in this style is not supported in NetOptions".to_string()),
                    "hostadd" => return std::result::Result::Err("Parsing a container in this style is not supported in NetOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "netns" => intermediate_rep.netns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "network_alias" => return std::result::Result::Err("Parsing a container in this style is not supported in NetOptions".to_string()),
                    "network_options" => return std::result::Result::Err("Parsing a container in this style is not supported in NetOptions".to_string()),
                    "networks" => return std::result::Result::Err("Parsing a container in this style is not supported in NetOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "no_manage_hosts" => intermediate_rep.no_manage_hosts.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "no_manage_resolv_conf" => intermediate_rep.no_manage_resolv_conf.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "portmappings" => return std::result::Result::Err("Parsing a container in this style is not supported in NetOptions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetOptions {
            dns_option: intermediate_rep.dns_option.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            dns_server: intermediate_rep.dns_server.into_iter().next(),
            hostadd: intermediate_rep.hostadd.into_iter().next(),
            netns: intermediate_rep.netns.into_iter().next(),
            network_alias: intermediate_rep.network_alias.into_iter().next(),
            network_options: intermediate_rep.network_options.into_iter().next(),
            networks: intermediate_rep.networks.into_iter().next(),
            no_manage_hosts: intermediate_rep.no_manage_hosts.into_iter().next(),
            no_manage_resolv_conf: intermediate_rep.no_manage_resolv_conf.into_iter().next(),
            portmappings: intermediate_rep.portmappings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Network {
/// Created contains the timestamp when this network was created.
    #[serde(rename = "created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

/// DNSEnabled is whether name resolution is active for container on this Network. Only supported with the bridge driver.
    #[serde(rename = "dns_enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_enabled: Option<bool>,

/// Driver for this Network, e.g. bridge, macvlan...
    #[serde(rename = "driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// ID of the Network.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Internal is whether the Network should not have external routes to public or other Networks.
    #[serde(rename = "internal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub internal: Option<bool>,

/// IPAMOptions contains options used for the ip assignment.
    #[serde(rename = "ipam_options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipam_options: Option<std::collections::HashMap<String, String>>,

/// IPv6Enabled if set to true an ipv6 subnet should be created for this net.
    #[serde(rename = "ipv6_enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_enabled: Option<bool>,

/// Labels is a set of key-value labels that have been applied to the Network.
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// Name of the Network.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// List of custom DNS server for podman's DNS resolver at network level, all the containers attached to this network will consider resolvers configured at network level.
    #[serde(rename = "network_dns_servers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_dns_servers: Option<Vec<String>>,

/// NetworkInterface is the network interface name on the host.
    #[serde(rename = "network_interface")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_interface: Option<String>,

/// Options is a set of key-value options that have been applied to the Network.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

/// Routes to use for this network.
    #[serde(rename = "routes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub routes: Option<Vec<models::Route>>,

/// Subnets to use for this network.
    #[serde(rename = "subnets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subnets: Option<Vec<models::Subnet>>,

}


impl Network {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Network {
        Network {
            created: None,
            dns_enabled: None,
            driver: None,
            id: None,
            internal: None,
            ipam_options: None,
            ipv6_enabled: None,
            labels: None,
            name: None,
            network_dns_servers: None,
            network_interface: None,
            options: None,
            routes: None,
            subnets: None,
        }
    }
}

/// Converts the Network value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Network {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping created in query parameter serialization


            self.dns_enabled.as_ref().map(|dns_enabled| {
                [
                    "dns_enabled".to_string(),
                    dns_enabled.to_string(),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.internal.as_ref().map(|internal| {
                [
                    "internal".to_string(),
                    internal.to_string(),
                ].join(",")
            }),

            // Skipping ipam_options in query parameter serialization


            self.ipv6_enabled.as_ref().map(|ipv6_enabled| {
                [
                    "ipv6_enabled".to_string(),
                    ipv6_enabled.to_string(),
                ].join(",")
            }),

            // Skipping labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.network_dns_servers.as_ref().map(|network_dns_servers| {
                [
                    "network_dns_servers".to_string(),
                    network_dns_servers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.network_interface.as_ref().map(|network_interface| {
                [
                    "network_interface".to_string(),
                    network_interface.to_string(),
                ].join(",")
            }),

            // Skipping options in query parameter serialization

            // Skipping routes in query parameter serialization

            // Skipping subnets in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Network value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Network {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub dns_enabled: Vec<bool>,
            pub driver: Vec<String>,
            pub id: Vec<String>,
            pub internal: Vec<bool>,
            pub ipam_options: Vec<std::collections::HashMap<String, String>>,
            pub ipv6_enabled: Vec<bool>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub network_dns_servers: Vec<Vec<String>>,
            pub network_interface: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub routes: Vec<Vec<models::Route>>,
            pub subnets: Vec<Vec<models::Subnet>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Network".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dns_enabled" => intermediate_rep.dns_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "internal" => intermediate_rep.internal.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ipam_options" => return std::result::Result::Err("Parsing a container in this style is not supported in Network".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ipv6_enabled" => intermediate_rep.ipv6_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in Network".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "network_dns_servers" => return std::result::Result::Err("Parsing a container in this style is not supported in Network".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "network_interface" => intermediate_rep.network_interface.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "options" => return std::result::Result::Err("Parsing a container in this style is not supported in Network".to_string()),
                    "routes" => return std::result::Result::Err("Parsing a container in this style is not supported in Network".to_string()),
                    "subnets" => return std::result::Result::Err("Parsing a container in this style is not supported in Network".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Network".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Network {
            created: intermediate_rep.created.into_iter().next(),
            dns_enabled: intermediate_rep.dns_enabled.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            internal: intermediate_rep.internal.into_iter().next(),
            ipam_options: intermediate_rep.ipam_options.into_iter().next(),
            ipv6_enabled: intermediate_rep.ipv6_enabled.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            network_dns_servers: intermediate_rep.network_dns_servers.into_iter().next(),
            network_interface: intermediate_rep.network_interface.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            routes: intermediate_rep.routes.into_iter().next(),
            subnets: intermediate_rep.subnets.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Network> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Network>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Network>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Network - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Network> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Network as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Network - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkBackend(String);

impl validator::Validate for NetworkBackend {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for NetworkBackend {
    fn from(x: String) -> Self {
        NetworkBackend(x)
    }
}

impl std::fmt::Display for NetworkBackend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for NetworkBackend {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NetworkBackend(x.to_string()))
    }
}

impl std::convert::From<NetworkBackend> for String {
    fn from(x: NetworkBackend) -> Self {
        x.0
    }
}

impl std::ops::Deref for NetworkBackend {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NetworkBackend {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// NetworkConnect represents the data to be used to connect a container to the network



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkConnect {
    #[serde(rename = "Container")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container: Option<String>,

    #[serde(rename = "EndpointConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_config: Option<models::EndpointSettings>,

}


impl NetworkConnect {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkConnect {
        NetworkConnect {
            container: None,
            endpoint_config: None,
        }
    }
}

/// Converts the NetworkConnect value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkConnect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.container.as_ref().map(|container| {
                [
                    "Container".to_string(),
                    container.to_string(),
                ].join(",")
            }),

            // Skipping EndpointConfig in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkConnect value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkConnect {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container: Vec<String>,
            pub endpoint_config: Vec<models::EndpointSettings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkConnect".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Container" => intermediate_rep.container.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "EndpointConfig" => intermediate_rep.endpoint_config.push(<models::EndpointSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkConnect".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkConnect {
            container: intermediate_rep.container.into_iter().next(),
            endpoint_config: intermediate_rep.endpoint_config.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkConnect> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkConnect>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkConnect>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkConnect - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkConnect> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkConnect as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkConnect - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetworkConnectOptions describes options for connecting a container to a network



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkConnectOptions {
/// Aliases contains a list of names which the dns server should resolve to this container. Should only be set when DNSEnabled is true on the Network. If aliases are set but there is no dns support for this network the network interface implementation should ignore this and NOT error. Optional.
    #[serde(rename = "aliases")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aliases: Option<Vec<String>>,

    #[serde(rename = "container")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container: Option<String>,

/// InterfaceName for this container. Required in the backend. Optional in the frontend. Will be filled with ethX (where X is a integer) when empty.
    #[serde(rename = "interface_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interface_name: Option<String>,

/// StaticIPs for this container. Optional.
    #[serde(rename = "static_ips")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub static_ips: Option<Vec<String>>,

/// StaticMac for this container. Optional.
    #[serde(rename = "static_mac")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub static_mac: Option<String>,

}


impl NetworkConnectOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkConnectOptions {
        NetworkConnectOptions {
            aliases: None,
            container: None,
            interface_name: None,
            static_ips: None,
            static_mac: None,
        }
    }
}

/// Converts the NetworkConnectOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkConnectOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.aliases.as_ref().map(|aliases| {
                [
                    "aliases".to_string(),
                    aliases.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.container.as_ref().map(|container| {
                [
                    "container".to_string(),
                    container.to_string(),
                ].join(",")
            }),


            self.interface_name.as_ref().map(|interface_name| {
                [
                    "interface_name".to_string(),
                    interface_name.to_string(),
                ].join(",")
            }),


            self.static_ips.as_ref().map(|static_ips| {
                [
                    "static_ips".to_string(),
                    static_ips.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.static_mac.as_ref().map(|static_mac| {
                [
                    "static_mac".to_string(),
                    static_mac.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkConnectOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkConnectOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub aliases: Vec<Vec<String>>,
            pub container: Vec<String>,
            pub interface_name: Vec<String>,
            pub static_ips: Vec<Vec<String>>,
            pub static_mac: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkConnectOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "aliases" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkConnectOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "container" => intermediate_rep.container.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "interface_name" => intermediate_rep.interface_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "static_ips" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkConnectOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "static_mac" => intermediate_rep.static_mac.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkConnectOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkConnectOptions {
            aliases: intermediate_rep.aliases.into_iter().next(),
            container: intermediate_rep.container.into_iter().next(),
            interface_name: intermediate_rep.interface_name.into_iter().next(),
            static_ips: intermediate_rep.static_ips.into_iter().next(),
            static_mac: intermediate_rep.static_mac.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkConnectOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkConnectOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkConnectOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkConnectOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkConnectOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkConnectOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkConnectOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkConnectRequest {
}


impl NetworkConnectRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkConnectRequest {
        NetworkConnectRequest {
        }
    }
}

/// Converts the NetworkConnectRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkConnectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkConnectRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkConnectRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkConnectRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkConnectRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkConnectRequest {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkConnectRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkConnectRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkConnectRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkConnectRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkConnectRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkConnectRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkConnectRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkConnectRequestLibpod {
}


impl NetworkConnectRequestLibpod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkConnectRequestLibpod {
        NetworkConnectRequestLibpod {
        }
    }
}

/// Converts the NetworkConnectRequestLibpod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkConnectRequestLibpod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkConnectRequestLibpod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkConnectRequestLibpod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkConnectRequestLibpod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkConnectRequestLibpod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkConnectRequestLibpod {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkConnectRequestLibpod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkConnectRequestLibpod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkConnectRequestLibpod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkConnectRequestLibpod - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkConnectRequestLibpod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkConnectRequestLibpod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkConnectRequestLibpod - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkContainerInfo {
/// Interfaces configured for this container with their addresses
    #[serde(rename = "interfaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interfaces: Option<std::collections::HashMap<String, models::NetInterface>>,

/// Name of the container
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl NetworkContainerInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkContainerInfo {
        NetworkContainerInfo {
            interfaces: None,
            name: None,
        }
    }
}

/// Converts the NetworkContainerInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkContainerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping interfaces in query parameter serialization
            // Skipping interfaces in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkContainerInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkContainerInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub interfaces: Vec<std::collections::HashMap<String, models::NetInterface>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkContainerInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "interfaces" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkContainerInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkContainerInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkContainerInfo {
            interfaces: intermediate_rep.interfaces.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkContainerInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkContainerInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkContainerInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkContainerInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkContainerInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkContainerInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkContainerInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkCreate {
}


impl NetworkCreate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkCreate {
        NetworkCreate {
        }
    }
}

/// Converts the NetworkCreate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkCreate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkCreate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkCreate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkCreate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkCreate {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkCreate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkCreate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkCreate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkCreate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkCreate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkCreate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkCreate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkCreate201Response {
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Warning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warning: Option<String>,

}


impl NetworkCreate201Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkCreate201Response {
        NetworkCreate201Response {
            id: None,
            warning: None,
        }
    }
}

/// Converts the NetworkCreate201Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkCreate201Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.warning.as_ref().map(|warning| {
                [
                    "Warning".to_string(),
                    warning.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkCreate201Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkCreate201Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub warning: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkCreate201Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Warning" => intermediate_rep.warning.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkCreate201Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkCreate201Response {
            id: intermediate_rep.id.into_iter().next(),
            warning: intermediate_rep.warning.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkCreate201Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkCreate201Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkCreate201Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkCreate201Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkCreate201Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkCreate201Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkCreate201Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Network create



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkCreateLibpod {
/// Created contains the timestamp when this network was created.
    #[serde(rename = "created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

/// DNSEnabled is whether name resolution is active for container on this Network. Only supported with the bridge driver.
    #[serde(rename = "dns_enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_enabled: Option<bool>,

/// Driver for this Network, e.g. bridge, macvlan...
    #[serde(rename = "driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// ID of the Network.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Internal is whether the Network should not have external routes to public or other Networks.
    #[serde(rename = "internal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub internal: Option<bool>,

/// IPAMOptions contains options used for the ip assignment.
    #[serde(rename = "ipam_options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipam_options: Option<std::collections::HashMap<String, String>>,

/// IPv6Enabled if set to true an ipv6 subnet should be created for this net.
    #[serde(rename = "ipv6_enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_enabled: Option<bool>,

/// Labels is a set of key-value labels that have been applied to the Network.
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// Name of the Network.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// List of custom DNS server for podman's DNS resolver at network level, all the containers attached to this network will consider resolvers configured at network level.
    #[serde(rename = "network_dns_servers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_dns_servers: Option<Vec<String>>,

/// NetworkInterface is the network interface name on the host.
    #[serde(rename = "network_interface")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_interface: Option<String>,

/// Options is a set of key-value options that have been applied to the Network.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

/// Routes to use for this network.
    #[serde(rename = "routes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub routes: Option<Vec<models::Route>>,

/// Subnets to use for this network.
    #[serde(rename = "subnets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subnets: Option<Vec<models::Subnet>>,

}


impl NetworkCreateLibpod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkCreateLibpod {
        NetworkCreateLibpod {
            created: None,
            dns_enabled: None,
            driver: None,
            id: None,
            internal: None,
            ipam_options: None,
            ipv6_enabled: None,
            labels: None,
            name: None,
            network_dns_servers: None,
            network_interface: None,
            options: None,
            routes: None,
            subnets: None,
        }
    }
}

/// Converts the NetworkCreateLibpod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkCreateLibpod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping created in query parameter serialization


            self.dns_enabled.as_ref().map(|dns_enabled| {
                [
                    "dns_enabled".to_string(),
                    dns_enabled.to_string(),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.internal.as_ref().map(|internal| {
                [
                    "internal".to_string(),
                    internal.to_string(),
                ].join(",")
            }),

            // Skipping ipam_options in query parameter serialization


            self.ipv6_enabled.as_ref().map(|ipv6_enabled| {
                [
                    "ipv6_enabled".to_string(),
                    ipv6_enabled.to_string(),
                ].join(",")
            }),

            // Skipping labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.network_dns_servers.as_ref().map(|network_dns_servers| {
                [
                    "network_dns_servers".to_string(),
                    network_dns_servers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.network_interface.as_ref().map(|network_interface| {
                [
                    "network_interface".to_string(),
                    network_interface.to_string(),
                ].join(",")
            }),

            // Skipping options in query parameter serialization

            // Skipping routes in query parameter serialization

            // Skipping subnets in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkCreateLibpod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkCreateLibpod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub dns_enabled: Vec<bool>,
            pub driver: Vec<String>,
            pub id: Vec<String>,
            pub internal: Vec<bool>,
            pub ipam_options: Vec<std::collections::HashMap<String, String>>,
            pub ipv6_enabled: Vec<bool>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub network_dns_servers: Vec<Vec<String>>,
            pub network_interface: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub routes: Vec<Vec<models::Route>>,
            pub subnets: Vec<Vec<models::Subnet>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkCreateLibpod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dns_enabled" => intermediate_rep.dns_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "internal" => intermediate_rep.internal.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ipam_options" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkCreateLibpod".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ipv6_enabled" => intermediate_rep.ipv6_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkCreateLibpod".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "network_dns_servers" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkCreateLibpod".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "network_interface" => intermediate_rep.network_interface.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "options" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkCreateLibpod".to_string()),
                    "routes" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkCreateLibpod".to_string()),
                    "subnets" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkCreateLibpod".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkCreateLibpod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkCreateLibpod {
            created: intermediate_rep.created.into_iter().next(),
            dns_enabled: intermediate_rep.dns_enabled.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            internal: intermediate_rep.internal.into_iter().next(),
            ipam_options: intermediate_rep.ipam_options.into_iter().next(),
            ipv6_enabled: intermediate_rep.ipv6_enabled.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            network_dns_servers: intermediate_rep.network_dns_servers.into_iter().next(),
            network_interface: intermediate_rep.network_interface.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            routes: intermediate_rep.routes.into_iter().next(),
            subnets: intermediate_rep.subnets.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkCreateLibpod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkCreateLibpod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkCreateLibpod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkCreateLibpod - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkCreateLibpod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkCreateLibpod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkCreateLibpod - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkCreateRequest {
    #[serde(rename = "Attachable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attachable: Option<bool>,

/// Deprecated: CheckDuplicate is deprecated since API v1.44, but it defaults to true when sent by the client package to older daemons.
    #[serde(rename = "CheckDuplicate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_duplicate: Option<bool>,

    #[serde(rename = "ConfigFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_from: Option<models::ConfigReference>,

    #[serde(rename = "ConfigOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_only: Option<bool>,

    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

    #[serde(rename = "EnableIPv6")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_ipv6: Option<bool>,

    #[serde(rename = "IPAM")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipam: Option<models::Ipam>,

    #[serde(rename = "Ingress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ingress: Option<bool>,

    #[serde(rename = "Internal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub internal: Option<bool>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

}


impl NetworkCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkCreateRequest {
        NetworkCreateRequest {
            attachable: None,
            check_duplicate: None,
            config_from: None,
            config_only: None,
            driver: None,
            enable_ipv6: None,
            ipam: None,
            ingress: None,
            internal: None,
            labels: None,
            name: None,
            options: None,
            scope: None,
        }
    }
}

/// Converts the NetworkCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.attachable.as_ref().map(|attachable| {
                [
                    "Attachable".to_string(),
                    attachable.to_string(),
                ].join(",")
            }),


            self.check_duplicate.as_ref().map(|check_duplicate| {
                [
                    "CheckDuplicate".to_string(),
                    check_duplicate.to_string(),
                ].join(",")
            }),

            // Skipping ConfigFrom in query parameter serialization


            self.config_only.as_ref().map(|config_only| {
                [
                    "ConfigOnly".to_string(),
                    config_only.to_string(),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.enable_ipv6.as_ref().map(|enable_ipv6| {
                [
                    "EnableIPv6".to_string(),
                    enable_ipv6.to_string(),
                ].join(",")
            }),

            // Skipping IPAM in query parameter serialization


            self.ingress.as_ref().map(|ingress| {
                [
                    "Ingress".to_string(),
                    ingress.to_string(),
                ].join(",")
            }),


            self.internal.as_ref().map(|internal| {
                [
                    "Internal".to_string(),
                    internal.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization


            self.scope.as_ref().map(|scope| {
                [
                    "Scope".to_string(),
                    scope.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub attachable: Vec<bool>,
            pub check_duplicate: Vec<bool>,
            pub config_from: Vec<models::ConfigReference>,
            pub config_only: Vec<bool>,
            pub driver: Vec<String>,
            pub enable_ipv6: Vec<bool>,
            pub ipam: Vec<models::Ipam>,
            pub ingress: Vec<bool>,
            pub internal: Vec<bool>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Attachable" => intermediate_rep.attachable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CheckDuplicate" => intermediate_rep.check_duplicate.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ConfigFrom" => intermediate_rep.config_from.push(<models::ConfigReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ConfigOnly" => intermediate_rep.config_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "EnableIPv6" => intermediate_rep.enable_ipv6.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPAM" => intermediate_rep.ipam.push(<models::Ipam as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Ingress" => intermediate_rep.ingress.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Internal" => intermediate_rep.internal.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkCreateRequest {
            attachable: intermediate_rep.attachable.into_iter().next(),
            check_duplicate: intermediate_rep.check_duplicate.into_iter().next(),
            config_from: intermediate_rep.config_from.into_iter().next(),
            config_only: intermediate_rep.config_only.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            enable_ipv6: intermediate_rep.enable_ipv6.into_iter().next(),
            ipam: intermediate_rep.ipam.into_iter().next(),
            ingress: intermediate_rep.ingress.into_iter().next(),
            internal: intermediate_rep.internal.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            scope: intermediate_rep.scope.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetworkDisconnect represents the data to be used to disconnect a container from the network



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkDisconnect {
    #[serde(rename = "Container")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container: Option<String>,

    #[serde(rename = "Force")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub force: Option<bool>,

}


impl NetworkDisconnect {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkDisconnect {
        NetworkDisconnect {
            container: None,
            force: None,
        }
    }
}

/// Converts the NetworkDisconnect value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkDisconnect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.container.as_ref().map(|container| {
                [
                    "Container".to_string(),
                    container.to_string(),
                ].join(",")
            }),


            self.force.as_ref().map(|force| {
                [
                    "Force".to_string(),
                    force.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkDisconnect value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkDisconnect {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container: Vec<String>,
            pub force: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkDisconnect".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Container" => intermediate_rep.container.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Force" => intermediate_rep.force.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkDisconnect".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkDisconnect {
            container: intermediate_rep.container.into_iter().next(),
            force: intermediate_rep.force.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkDisconnect> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkDisconnect>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkDisconnect>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkDisconnect - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkDisconnect> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkDisconnect as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkDisconnect - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkDisconnectRequest {
}


impl NetworkDisconnectRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkDisconnectRequest {
        NetworkDisconnectRequest {
        }
    }
}

/// Converts the NetworkDisconnectRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkDisconnectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkDisconnectRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkDisconnectRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkDisconnectRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkDisconnectRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkDisconnectRequest {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkDisconnectRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkDisconnectRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkDisconnectRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkDisconnectRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkDisconnectRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkDisconnectRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkDisconnectRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkInfo {
    #[serde(rename = "backend")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub backend: Option<String>,

    #[serde(rename = "dns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns: Option<models::DnsNetworkInfo>,

    #[serde(rename = "package")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<String>,

    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl NetworkInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkInfo {
        NetworkInfo {
            backend: None,
            dns: None,
            package: None,
            path: None,
            version: None,
        }
    }
}

/// Converts the NetworkInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.backend.as_ref().map(|backend| {
                [
                    "backend".to_string(),
                    backend.to_string(),
                ].join(",")
            }),

            // Skipping dns in query parameter serialization


            self.package.as_ref().map(|package| {
                [
                    "package".to_string(),
                    package.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub backend: Vec<String>,
            pub dns: Vec<models::DnsNetworkInfo>,
            pub package: Vec<String>,
            pub path: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "backend" => intermediate_rep.backend.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dns" => intermediate_rep.dns.push(<models::DnsNetworkInfo as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "package" => intermediate_rep.package.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkInfo {
            backend: intermediate_rep.backend.into_iter().next(),
            dns: intermediate_rep.dns.into_iter().next(),
            package: intermediate_rep.package.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkInspectReport {
    #[serde(rename = "containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<std::collections::HashMap<String, models::NetworkContainerInfo>>,

/// Created contains the timestamp when this network was created.
    #[serde(rename = "created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

/// DNSEnabled is whether name resolution is active for container on this Network. Only supported with the bridge driver.
    #[serde(rename = "dns_enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_enabled: Option<bool>,

/// Driver for this Network, e.g. bridge, macvlan...
    #[serde(rename = "driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// ID of the Network.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Internal is whether the Network should not have external routes to public or other Networks.
    #[serde(rename = "internal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub internal: Option<bool>,

/// IPAMOptions contains options used for the ip assignment.
    #[serde(rename = "ipam_options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipam_options: Option<std::collections::HashMap<String, String>>,

/// IPv6Enabled if set to true an ipv6 subnet should be created for this net.
    #[serde(rename = "ipv6_enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_enabled: Option<bool>,

/// Labels is a set of key-value labels that have been applied to the Network.
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// Name of the Network.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// List of custom DNS server for podman's DNS resolver at network level, all the containers attached to this network will consider resolvers configured at network level.
    #[serde(rename = "network_dns_servers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_dns_servers: Option<Vec<String>>,

/// NetworkInterface is the network interface name on the host.
    #[serde(rename = "network_interface")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_interface: Option<String>,

/// Options is a set of key-value options that have been applied to the Network.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

/// Routes to use for this network.
    #[serde(rename = "routes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub routes: Option<Vec<models::Route>>,

/// Subnets to use for this network.
    #[serde(rename = "subnets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subnets: Option<Vec<models::Subnet>>,

}


impl NetworkInspectReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkInspectReport {
        NetworkInspectReport {
            containers: None,
            created: None,
            dns_enabled: None,
            driver: None,
            id: None,
            internal: None,
            ipam_options: None,
            ipv6_enabled: None,
            labels: None,
            name: None,
            network_dns_servers: None,
            network_interface: None,
            options: None,
            routes: None,
            subnets: None,
        }
    }
}

/// Converts the NetworkInspectReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkInspectReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping containers in query parameter serialization
            // Skipping containers in query parameter serialization

            // Skipping created in query parameter serialization


            self.dns_enabled.as_ref().map(|dns_enabled| {
                [
                    "dns_enabled".to_string(),
                    dns_enabled.to_string(),
                ].join(",")
            }),


            self.driver.as_ref().map(|driver| {
                [
                    "driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.internal.as_ref().map(|internal| {
                [
                    "internal".to_string(),
                    internal.to_string(),
                ].join(",")
            }),

            // Skipping ipam_options in query parameter serialization


            self.ipv6_enabled.as_ref().map(|ipv6_enabled| {
                [
                    "ipv6_enabled".to_string(),
                    ipv6_enabled.to_string(),
                ].join(",")
            }),

            // Skipping labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.network_dns_servers.as_ref().map(|network_dns_servers| {
                [
                    "network_dns_servers".to_string(),
                    network_dns_servers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.network_interface.as_ref().map(|network_interface| {
                [
                    "network_interface".to_string(),
                    network_interface.to_string(),
                ].join(",")
            }),

            // Skipping options in query parameter serialization

            // Skipping routes in query parameter serialization

            // Skipping subnets in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkInspectReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkInspectReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub containers: Vec<std::collections::HashMap<String, models::NetworkContainerInfo>>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub dns_enabled: Vec<bool>,
            pub driver: Vec<String>,
            pub id: Vec<String>,
            pub internal: Vec<bool>,
            pub ipam_options: Vec<std::collections::HashMap<String, String>>,
            pub ipv6_enabled: Vec<bool>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub network_dns_servers: Vec<Vec<String>>,
            pub network_interface: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub routes: Vec<Vec<models::Route>>,
            pub subnets: Vec<Vec<models::Subnet>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkInspectReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "containers" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkInspectReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dns_enabled" => intermediate_rep.dns_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "internal" => intermediate_rep.internal.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "ipam_options" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkInspectReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ipv6_enabled" => intermediate_rep.ipv6_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkInspectReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "network_dns_servers" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkInspectReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "network_interface" => intermediate_rep.network_interface.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "options" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkInspectReport".to_string()),
                    "routes" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkInspectReport".to_string()),
                    "subnets" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkInspectReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkInspectReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkInspectReport {
            containers: intermediate_rep.containers.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            dns_enabled: intermediate_rep.dns_enabled.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            internal: intermediate_rep.internal.into_iter().next(),
            ipam_options: intermediate_rep.ipam_options.into_iter().next(),
            ipv6_enabled: intermediate_rep.ipv6_enabled.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            network_dns_servers: intermediate_rep.network_dns_servers.into_iter().next(),
            network_interface: intermediate_rep.network_interface.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            routes: intermediate_rep.routes.into_iter().next(),
            subnets: intermediate_rep.subnets.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkInspectReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkInspectReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkInspectReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkInspectReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkInspectReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkInspectReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkInspectReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkMode(String);

impl validator::Validate for NetworkMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for NetworkMode {
    fn from(x: String) -> Self {
        NetworkMode(x)
    }
}

impl std::fmt::Display for NetworkMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for NetworkMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(NetworkMode(x.to_string()))
    }
}

impl std::convert::From<NetworkMode> for String {
    fn from(x: NetworkMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for NetworkMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for NetworkMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkPrune200Response {
    #[serde(rename = "NetworksDeleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks_deleted: Option<Vec<String>>,

}


impl NetworkPrune200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkPrune200Response {
        NetworkPrune200Response {
            networks_deleted: None,
        }
    }
}

/// Converts the NetworkPrune200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkPrune200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.networks_deleted.as_ref().map(|networks_deleted| {
                [
                    "NetworksDeleted".to_string(),
                    networks_deleted.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkPrune200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkPrune200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub networks_deleted: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkPrune200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "NetworksDeleted" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkPrune200Response".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkPrune200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkPrune200Response {
            networks_deleted: intermediate_rep.networks_deleted.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkPrune200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkPrune200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkPrune200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkPrune200Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkPrune200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkPrune200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkPrune200Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetworkPruneReport containers the name of network and an error associated in its pruning (removal)



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkPruneReport {
    #[serde(rename = "Error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl NetworkPruneReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkPruneReport {
        NetworkPruneReport {
            error: None,
            name: None,
        }
    }
}

/// Converts the NetworkPruneReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkPruneReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.error.as_ref().map(|error| {
                [
                    "Error".to_string(),
                    error.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkPruneReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkPruneReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkPruneReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Error" => intermediate_rep.error.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkPruneReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkPruneReport {
            error: intermediate_rep.error.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkPruneReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkPruneReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkPruneReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkPruneReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkPruneReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkPruneReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkPruneReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetworkResource is the body of the \"get network\" http response message



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkResource {
    #[serde(rename = "Attachable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attachable: Option<bool>,

    #[serde(rename = "ConfigFrom")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_from: Option<models::ConfigReference>,

    #[serde(rename = "ConfigOnly")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_only: Option<bool>,

    #[serde(rename = "Containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<std::collections::HashMap<String, models::EndpointResource>>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

    #[serde(rename = "EnableIPv6")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_ipv6: Option<bool>,

    #[serde(rename = "IPAM")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipam: Option<models::Ipam>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Ingress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ingress: Option<bool>,

    #[serde(rename = "Internal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub internal: Option<bool>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Peers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub peers: Option<Vec<models::PeerInfo>>,

    #[serde(rename = "Scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

    #[serde(rename = "Services")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub services: Option<std::collections::HashMap<String, models::ServiceInfo>>,

}


impl NetworkResource {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkResource {
        NetworkResource {
            attachable: None,
            config_from: None,
            config_only: None,
            containers: None,
            created: None,
            driver: None,
            enable_ipv6: None,
            ipam: None,
            id: None,
            ingress: None,
            internal: None,
            labels: None,
            name: None,
            options: None,
            peers: None,
            scope: None,
            services: None,
        }
    }
}

/// Converts the NetworkResource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.attachable.as_ref().map(|attachable| {
                [
                    "Attachable".to_string(),
                    attachable.to_string(),
                ].join(",")
            }),

            // Skipping ConfigFrom in query parameter serialization


            self.config_only.as_ref().map(|config_only| {
                [
                    "ConfigOnly".to_string(),
                    config_only.to_string(),
                ].join(",")
            }),

            // Skipping Containers in query parameter serialization
            // Skipping Containers in query parameter serialization

            // Skipping Created in query parameter serialization


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.enable_ipv6.as_ref().map(|enable_ipv6| {
                [
                    "EnableIPv6".to_string(),
                    enable_ipv6.to_string(),
                ].join(",")
            }),

            // Skipping IPAM in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.ingress.as_ref().map(|ingress| {
                [
                    "Ingress".to_string(),
                    ingress.to_string(),
                ].join(",")
            }),


            self.internal.as_ref().map(|internal| {
                [
                    "Internal".to_string(),
                    internal.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization

            // Skipping Peers in query parameter serialization


            self.scope.as_ref().map(|scope| {
                [
                    "Scope".to_string(),
                    scope.to_string(),
                ].join(",")
            }),

            // Skipping Services in query parameter serialization
            // Skipping Services in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkResource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkResource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub attachable: Vec<bool>,
            pub config_from: Vec<models::ConfigReference>,
            pub config_only: Vec<bool>,
            pub containers: Vec<std::collections::HashMap<String, models::EndpointResource>>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub driver: Vec<String>,
            pub enable_ipv6: Vec<bool>,
            pub ipam: Vec<models::Ipam>,
            pub id: Vec<String>,
            pub ingress: Vec<bool>,
            pub internal: Vec<bool>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub peers: Vec<Vec<models::PeerInfo>>,
            pub scope: Vec<String>,
            pub services: Vec<std::collections::HashMap<String, models::ServiceInfo>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkResource".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Attachable" => intermediate_rep.attachable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ConfigFrom" => intermediate_rep.config_from.push(<models::ConfigReference as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ConfigOnly" => intermediate_rep.config_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Containers" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkResource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "EnableIPv6" => intermediate_rep.enable_ipv6.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPAM" => intermediate_rep.ipam.push(<models::Ipam as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Ingress" => intermediate_rep.ingress.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Internal" => intermediate_rep.internal.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkResource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkResource".to_string()),
                    "Peers" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkResource".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Services" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkResource".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkResource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkResource {
            attachable: intermediate_rep.attachable.into_iter().next(),
            config_from: intermediate_rep.config_from.into_iter().next(),
            config_only: intermediate_rep.config_only.into_iter().next(),
            containers: intermediate_rep.containers.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            enable_ipv6: intermediate_rep.enable_ipv6.into_iter().next(),
            ipam: intermediate_rep.ipam.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            ingress: intermediate_rep.ingress.into_iter().next(),
            internal: intermediate_rep.internal.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            peers: intermediate_rep.peers.into_iter().next(),
            scope: intermediate_rep.scope.into_iter().next(),
            services: intermediate_rep.services.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkResource> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkResource>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkResource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkResource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkResource> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkResource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkResource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetworkRmReport describes the results of network removal



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkRmReport {
    #[serde(rename = "Err")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub err: Option<String>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl NetworkRmReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkRmReport {
        NetworkRmReport {
            err: None,
            name: None,
        }
    }
}

/// Converts the NetworkRmReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkRmReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.err.as_ref().map(|err| {
                [
                    "Err".to_string(),
                    err.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkRmReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkRmReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub err: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkRmReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Err" => intermediate_rep.err.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkRmReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkRmReport {
            err: intermediate_rep.err.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkRmReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkRmReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkRmReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkRmReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkRmReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkRmReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkRmReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetworkSettings exposes the network settings in the api



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkSettings {
    #[serde(rename = "Bridge")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bridge: Option<String>,

    #[serde(rename = "EndpointID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_id: Option<String>,

    #[serde(rename = "Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

    #[serde(rename = "GlobalIPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_address: Option<String>,

    #[serde(rename = "GlobalIPv6PrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub global_ipv6_prefix_len: Option<i64>,

/// HairpinMode specifies if hairpin NAT should be enabled on the virtual interface  Deprecated: This field is never set and will be removed in a future release.
    #[serde(rename = "HairpinMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hairpin_mode: Option<bool>,

    #[serde(rename = "IPAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_address: Option<String>,

    #[serde(rename = "IPPrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_prefix_len: Option<i64>,

    #[serde(rename = "IPv6Gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipv6_gateway: Option<String>,

/// LinkLocalIPv6Address is an IPv6 unicast address using the link-local prefix  Deprecated: This field is never set and will be removed in a future release.
    #[serde(rename = "LinkLocalIPv6Address")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_local_ipv6_address: Option<String>,

/// LinkLocalIPv6PrefixLen is the prefix length of an IPv6 unicast address  Deprecated: This field is never set and will be removed in a future release.
    #[serde(rename = "LinkLocalIPv6PrefixLen")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_local_ipv6_prefix_len: Option<i64>,

    #[serde(rename = "MacAddress")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mac_address: Option<String>,

    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<std::collections::HashMap<String, models::EndpointSettings>>,

/// PortMap is a collection of PortBinding indexed by Port
    #[serde(rename = "Ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ports: Option<std::collections::HashMap<String, Vec<models::PortBinding>>>,

    #[serde(rename = "SandboxID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sandbox_id: Option<String>,

    #[serde(rename = "SandboxKey")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sandbox_key: Option<String>,

    #[serde(rename = "SecondaryIPAddresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secondary_ip_addresses: Option<Vec<models::Address>>,

    #[serde(rename = "SecondaryIPv6Addresses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secondary_ipv6_addresses: Option<Vec<models::Address>>,

}


impl NetworkSettings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkSettings {
        NetworkSettings {
            bridge: None,
            endpoint_id: None,
            gateway: None,
            global_ipv6_address: None,
            global_ipv6_prefix_len: None,
            hairpin_mode: None,
            ip_address: None,
            ip_prefix_len: None,
            ipv6_gateway: None,
            link_local_ipv6_address: None,
            link_local_ipv6_prefix_len: None,
            mac_address: None,
            networks: None,
            ports: None,
            sandbox_id: None,
            sandbox_key: None,
            secondary_ip_addresses: None,
            secondary_ipv6_addresses: None,
        }
    }
}

/// Converts the NetworkSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.bridge.as_ref().map(|bridge| {
                [
                    "Bridge".to_string(),
                    bridge.to_string(),
                ].join(",")
            }),


            self.endpoint_id.as_ref().map(|endpoint_id| {
                [
                    "EndpointID".to_string(),
                    endpoint_id.to_string(),
                ].join(",")
            }),


            self.gateway.as_ref().map(|gateway| {
                [
                    "Gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),


            self.global_ipv6_address.as_ref().map(|global_ipv6_address| {
                [
                    "GlobalIPv6Address".to_string(),
                    global_ipv6_address.to_string(),
                ].join(",")
            }),


            self.global_ipv6_prefix_len.as_ref().map(|global_ipv6_prefix_len| {
                [
                    "GlobalIPv6PrefixLen".to_string(),
                    global_ipv6_prefix_len.to_string(),
                ].join(",")
            }),


            self.hairpin_mode.as_ref().map(|hairpin_mode| {
                [
                    "HairpinMode".to_string(),
                    hairpin_mode.to_string(),
                ].join(",")
            }),


            self.ip_address.as_ref().map(|ip_address| {
                [
                    "IPAddress".to_string(),
                    ip_address.to_string(),
                ].join(",")
            }),


            self.ip_prefix_len.as_ref().map(|ip_prefix_len| {
                [
                    "IPPrefixLen".to_string(),
                    ip_prefix_len.to_string(),
                ].join(",")
            }),


            self.ipv6_gateway.as_ref().map(|ipv6_gateway| {
                [
                    "IPv6Gateway".to_string(),
                    ipv6_gateway.to_string(),
                ].join(",")
            }),


            self.link_local_ipv6_address.as_ref().map(|link_local_ipv6_address| {
                [
                    "LinkLocalIPv6Address".to_string(),
                    link_local_ipv6_address.to_string(),
                ].join(",")
            }),


            self.link_local_ipv6_prefix_len.as_ref().map(|link_local_ipv6_prefix_len| {
                [
                    "LinkLocalIPv6PrefixLen".to_string(),
                    link_local_ipv6_prefix_len.to_string(),
                ].join(",")
            }),


            self.mac_address.as_ref().map(|mac_address| {
                [
                    "MacAddress".to_string(),
                    mac_address.to_string(),
                ].join(",")
            }),

            // Skipping Networks in query parameter serialization
            // Skipping Networks in query parameter serialization

            // Skipping Ports in query parameter serialization
            // Skipping Ports in query parameter serialization


            self.sandbox_id.as_ref().map(|sandbox_id| {
                [
                    "SandboxID".to_string(),
                    sandbox_id.to_string(),
                ].join(",")
            }),


            self.sandbox_key.as_ref().map(|sandbox_key| {
                [
                    "SandboxKey".to_string(),
                    sandbox_key.to_string(),
                ].join(",")
            }),

            // Skipping SecondaryIPAddresses in query parameter serialization

            // Skipping SecondaryIPv6Addresses in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub bridge: Vec<String>,
            pub endpoint_id: Vec<String>,
            pub gateway: Vec<String>,
            pub global_ipv6_address: Vec<String>,
            pub global_ipv6_prefix_len: Vec<i64>,
            pub hairpin_mode: Vec<bool>,
            pub ip_address: Vec<String>,
            pub ip_prefix_len: Vec<i64>,
            pub ipv6_gateway: Vec<String>,
            pub link_local_ipv6_address: Vec<String>,
            pub link_local_ipv6_prefix_len: Vec<i64>,
            pub mac_address: Vec<String>,
            pub networks: Vec<std::collections::HashMap<String, models::EndpointSettings>>,
            pub ports: Vec<std::collections::HashMap<String, Vec<models::PortBinding>>>,
            pub sandbox_id: Vec<String>,
            pub sandbox_key: Vec<String>,
            pub secondary_ip_addresses: Vec<Vec<models::Address>>,
            pub secondary_ipv6_addresses: Vec<Vec<models::Address>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Bridge" => intermediate_rep.bridge.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "EndpointID" => intermediate_rep.endpoint_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6Address" => intermediate_rep.global_ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GlobalIPv6PrefixLen" => intermediate_rep.global_ipv6_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HairpinMode" => intermediate_rep.hairpin_mode.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPAddress" => intermediate_rep.ip_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPPrefixLen" => intermediate_rep.ip_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IPv6Gateway" => intermediate_rep.ipv6_gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LinkLocalIPv6Address" => intermediate_rep.link_local_ipv6_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LinkLocalIPv6PrefixLen" => intermediate_rep.link_local_ipv6_prefix_len.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MacAddress" => intermediate_rep.mac_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkSettings".to_string()),
                    "Ports" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkSettings".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SandboxID" => intermediate_rep.sandbox_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SandboxKey" => intermediate_rep.sandbox_key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "SecondaryIPAddresses" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkSettings".to_string()),
                    "SecondaryIPv6Addresses" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkSettings".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkSettings {
            bridge: intermediate_rep.bridge.into_iter().next(),
            endpoint_id: intermediate_rep.endpoint_id.into_iter().next(),
            gateway: intermediate_rep.gateway.into_iter().next(),
            global_ipv6_address: intermediate_rep.global_ipv6_address.into_iter().next(),
            global_ipv6_prefix_len: intermediate_rep.global_ipv6_prefix_len.into_iter().next(),
            hairpin_mode: intermediate_rep.hairpin_mode.into_iter().next(),
            ip_address: intermediate_rep.ip_address.into_iter().next(),
            ip_prefix_len: intermediate_rep.ip_prefix_len.into_iter().next(),
            ipv6_gateway: intermediate_rep.ipv6_gateway.into_iter().next(),
            link_local_ipv6_address: intermediate_rep.link_local_ipv6_address.into_iter().next(),
            link_local_ipv6_prefix_len: intermediate_rep.link_local_ipv6_prefix_len.into_iter().next(),
            mac_address: intermediate_rep.mac_address.into_iter().next(),
            networks: intermediate_rep.networks.into_iter().next(),
            ports: intermediate_rep.ports.into_iter().next(),
            sandbox_id: intermediate_rep.sandbox_id.into_iter().next(),
            sandbox_key: intermediate_rep.sandbox_key.into_iter().next(),
            secondary_ip_addresses: intermediate_rep.secondary_ip_addresses.into_iter().next(),
            secondary_ipv6_addresses: intermediate_rep.secondary_ipv6_addresses.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkSettings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkSettings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkSettings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkSettings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkSettings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetworkUpdateOptions describes options to update a network



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkUpdateOptions {
    #[serde(rename = "adddnsservers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adddnsservers: Option<Vec<String>>,

    #[serde(rename = "removednsservers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub removednsservers: Option<Vec<String>>,

}


impl NetworkUpdateOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkUpdateOptions {
        NetworkUpdateOptions {
            adddnsservers: None,
            removednsservers: None,
        }
    }
}

/// Converts the NetworkUpdateOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkUpdateOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.adddnsservers.as_ref().map(|adddnsservers| {
                [
                    "adddnsservers".to_string(),
                    adddnsservers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.removednsservers.as_ref().map(|removednsservers| {
                [
                    "removednsservers".to_string(),
                    removednsservers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkUpdateOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkUpdateOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub adddnsservers: Vec<Vec<String>>,
            pub removednsservers: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkUpdateOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "adddnsservers" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkUpdateOptions".to_string()),
                    "removednsservers" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkUpdateOptions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkUpdateOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkUpdateOptions {
            adddnsservers: intermediate_rep.adddnsservers.into_iter().next(),
            removednsservers: intermediate_rep.removednsservers.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkUpdateOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkUpdateOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkUpdateOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkUpdateOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkUpdateOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkUpdateOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkUpdateOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkUpdateRequestLibpod {
}


impl NetworkUpdateRequestLibpod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkUpdateRequestLibpod {
        NetworkUpdateRequestLibpod {
        }
    }
}

/// Converts the NetworkUpdateRequestLibpod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkUpdateRequestLibpod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkUpdateRequestLibpod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkUpdateRequestLibpod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkUpdateRequestLibpod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkUpdateRequestLibpod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkUpdateRequestLibpod {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkUpdateRequestLibpod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkUpdateRequestLibpod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkUpdateRequestLibpod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkUpdateRequestLibpod - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkUpdateRequestLibpod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkUpdateRequestLibpod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkUpdateRequestLibpod - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// NetworkingConfig represents the container's networking configuration for each of its interfaces Carries the networking configs specified in the `docker run` and `docker network connect` commands



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NetworkingConfig {
    #[serde(rename = "EndpointsConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoints_config: Option<std::collections::HashMap<String, models::EndpointSettings>>,

}


impl NetworkingConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> NetworkingConfig {
        NetworkingConfig {
            endpoints_config: None,
        }
    }
}

/// Converts the NetworkingConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NetworkingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping EndpointsConfig in query parameter serialization
            // Skipping EndpointsConfig in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NetworkingConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NetworkingConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub endpoints_config: Vec<std::collections::HashMap<String, models::EndpointSettings>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NetworkingConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "EndpointsConfig" => return std::result::Result::Err("Parsing a container in this style is not supported in NetworkingConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NetworkingConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NetworkingConfig {
            endpoints_config: intermediate_rep.endpoints_config.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NetworkingConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NetworkingConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NetworkingConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for NetworkingConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NetworkingConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NetworkingConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into NetworkingConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// OCIRuntimeInfo describes the runtime (crun or runc) being used with podman



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OciRuntimeInfo {
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "package")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<String>,

    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl OciRuntimeInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OciRuntimeInfo {
        OciRuntimeInfo {
            name: None,
            package: None,
            path: None,
            version: None,
        }
    }
}

/// Converts the OciRuntimeInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OciRuntimeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.package.as_ref().map(|package| {
                [
                    "package".to_string(),
                    package.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OciRuntimeInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OciRuntimeInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub package: Vec<String>,
            pub path: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OciRuntimeInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "package" => intermediate_rep.package.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OciRuntimeInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OciRuntimeInfo {
            name: intermediate_rep.name.into_iter().next(),
            package: intermediate_rep.package.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OciRuntimeInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OciRuntimeInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OciRuntimeInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OciRuntimeInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OciRuntimeInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OciRuntimeInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OciRuntimeInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// OverlayVolume holds information about an overlay volume that will be mounted into the container.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OverlayVolume {
/// Destination is the absolute path where the mount will be placed in the container.
    #[serde(rename = "destination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination: Option<String>,

/// Options holds overlay volume options.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<Vec<String>>,

/// Source specifies the source path of the mount.
    #[serde(rename = "source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,

}


impl OverlayVolume {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> OverlayVolume {
        OverlayVolume {
            destination: None,
            options: None,
            source: None,
        }
    }
}

/// Converts the OverlayVolume value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OverlayVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.destination.as_ref().map(|destination| {
                [
                    "destination".to_string(),
                    destination.to_string(),
                ].join(",")
            }),


            self.options.as_ref().map(|options| {
                [
                    "options".to_string(),
                    options.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.source.as_ref().map(|source| {
                [
                    "source".to_string(),
                    source.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OverlayVolume value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OverlayVolume {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub destination: Vec<String>,
            pub options: Vec<Vec<String>>,
            pub source: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OverlayVolume".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "destination" => intermediate_rep.destination.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "options" => return std::result::Result::Err("Parsing a container in this style is not supported in OverlayVolume".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "source" => intermediate_rep.source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OverlayVolume".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OverlayVolume {
            destination: intermediate_rep.destination.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            source: intermediate_rep.source.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OverlayVolume> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OverlayVolume>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OverlayVolume>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OverlayVolume - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OverlayVolume> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OverlayVolume as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OverlayVolume - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PastaInfo describes the pasta executable that is being used



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PastaInfo {
    #[serde(rename = "executable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub executable: Option<String>,

    #[serde(rename = "package")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<String>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl PastaInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PastaInfo {
        PastaInfo {
            executable: None,
            package: None,
            version: None,
        }
    }
}

/// Converts the PastaInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PastaInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.executable.as_ref().map(|executable| {
                [
                    "executable".to_string(),
                    executable.to_string(),
                ].join(",")
            }),


            self.package.as_ref().map(|package| {
                [
                    "package".to_string(),
                    package.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PastaInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PastaInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub executable: Vec<String>,
            pub package: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PastaInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "executable" => intermediate_rep.executable.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "package" => intermediate_rep.package.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PastaInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PastaInfo {
            executable: intermediate_rep.executable.into_iter().next(),
            package: intermediate_rep.package.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PastaInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PastaInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PastaInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PastaInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PastaInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PastaInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PastaInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PeerInfo represents one peer of an overlay network



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PeerInfo {
    #[serde(rename = "IP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip: Option<String>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl PeerInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PeerInfo {
        PeerInfo {
            ip: None,
            name: None,
        }
    }
}

/// Converts the PeerInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PeerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ip.as_ref().map(|ip| {
                [
                    "IP".to_string(),
                    ip.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PeerInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PeerInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ip: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PeerInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IP" => intermediate_rep.ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PeerInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PeerInfo {
            ip: intermediate_rep.ip.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PeerInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PeerInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PeerInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PeerInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PeerInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PeerInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PeerInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PerNetworkOptions {
/// Aliases contains a list of names which the dns server should resolve to this container. Should only be set when DNSEnabled is true on the Network. If aliases are set but there is no dns support for this network the network interface implementation should ignore this and NOT error. Optional.
    #[serde(rename = "aliases")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub aliases: Option<Vec<String>>,

/// InterfaceName for this container. Required in the backend. Optional in the frontend. Will be filled with ethX (where X is a integer) when empty.
    #[serde(rename = "interface_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interface_name: Option<String>,

/// StaticIPs for this container. Optional.
    #[serde(rename = "static_ips")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub static_ips: Option<Vec<String>>,

/// StaticMac for this container. Optional.
    #[serde(rename = "static_mac")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub static_mac: Option<String>,

}


impl PerNetworkOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PerNetworkOptions {
        PerNetworkOptions {
            aliases: None,
            interface_name: None,
            static_ips: None,
            static_mac: None,
        }
    }
}

/// Converts the PerNetworkOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PerNetworkOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.aliases.as_ref().map(|aliases| {
                [
                    "aliases".to_string(),
                    aliases.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.interface_name.as_ref().map(|interface_name| {
                [
                    "interface_name".to_string(),
                    interface_name.to_string(),
                ].join(",")
            }),


            self.static_ips.as_ref().map(|static_ips| {
                [
                    "static_ips".to_string(),
                    static_ips.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.static_mac.as_ref().map(|static_mac| {
                [
                    "static_mac".to_string(),
                    static_mac.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PerNetworkOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PerNetworkOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub aliases: Vec<Vec<String>>,
            pub interface_name: Vec<String>,
            pub static_ips: Vec<Vec<String>>,
            pub static_mac: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PerNetworkOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "aliases" => return std::result::Result::Err("Parsing a container in this style is not supported in PerNetworkOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "interface_name" => intermediate_rep.interface_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "static_ips" => return std::result::Result::Err("Parsing a container in this style is not supported in PerNetworkOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "static_mac" => intermediate_rep.static_mac.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PerNetworkOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PerNetworkOptions {
            aliases: intermediate_rep.aliases.into_iter().next(),
            interface_name: intermediate_rep.interface_name.into_iter().next(),
            static_ips: intermediate_rep.static_ips.into_iter().next(),
            static_mac: intermediate_rep.static_mac.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PerNetworkOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PerNetworkOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PerNetworkOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PerNetworkOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PerNetworkOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PerNetworkOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PerNetworkOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PidMode(String);

impl validator::Validate for PidMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PidMode {
    fn from(x: String) -> Self {
        PidMode(x)
    }
}

impl std::fmt::Display for PidMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for PidMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PidMode(x.to_string()))
    }
}

impl std::convert::From<PidMode> for String {
    fn from(x: PidMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for PidMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PidMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Platform {
/// Architecture field specifies the CPU architecture, for example `amd64` or `ppc64le`.
    #[serde(rename = "architecture")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub architecture: Option<String>,

/// OS specifies the operating system, for example `linux` or `windows`.
    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

/// OSFeatures is an optional field specifying an array of strings, each listing a required OS feature (for example on Windows `win32k`).
    #[serde(rename = "os.features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_period_features: Option<Vec<String>>,

/// OSVersion is an optional field specifying the operating system version, for example on Windows `10.0.14393.1066`.
    #[serde(rename = "os.version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_period_version: Option<String>,

/// Variant is an optional field specifying a variant of the CPU, for example `v7` to specify ARMv7 when architecture is `arm`.
    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

}


impl Platform {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Platform {
        Platform {
            architecture: None,
            os: None,
            os_period_features: None,
            os_period_version: None,
            variant: None,
        }
    }
}

/// Converts the Platform value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Platform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.architecture.as_ref().map(|architecture| {
                [
                    "architecture".to_string(),
                    architecture.to_string(),
                ].join(",")
            }),


            self.os.as_ref().map(|os| {
                [
                    "os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.os_period_features.as_ref().map(|os_period_features| {
                [
                    "os.features".to_string(),
                    os_period_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os_period_version.as_ref().map(|os_period_version| {
                [
                    "os.version".to_string(),
                    os_period_version.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Platform value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Platform {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub architecture: Vec<String>,
            pub os: Vec<String>,
            pub os_period_features: Vec<Vec<String>>,
            pub os_period_version: Vec<String>,
            pub variant: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Platform".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "architecture" => intermediate_rep.architecture.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "os.features" => return std::result::Result::Err("Parsing a container in this style is not supported in Platform".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os.version" => intermediate_rep.os_period_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Platform".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Platform {
            architecture: intermediate_rep.architecture.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            os_period_features: intermediate_rep.os_period_features.into_iter().next(),
            os_period_version: intermediate_rep.os_period_version.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Platform> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Platform>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Platform>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Platform - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Platform> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Platform as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Platform - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlayKubePod {
/// ContainerErrors - any errors that occurred while starting containers in the pod.
    #[serde(rename = "ContainerErrors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_errors: Option<Vec<String>>,

/// Containers - the IDs of the containers running in the created pod.
    #[serde(rename = "Containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<Vec<String>>,

/// ID - ID of the pod created as a result of play kube.
    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// InitContainers - the IDs of the init containers to be run in the created pod.
    #[serde(rename = "InitContainers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init_containers: Option<Vec<String>>,

/// Logs - non-fatal errors and log messages while processing.
    #[serde(rename = "Logs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs: Option<Vec<String>>,

}


impl PlayKubePod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PlayKubePod {
        PlayKubePod {
            container_errors: None,
            containers: None,
            id: None,
            init_containers: None,
            logs: None,
        }
    }
}

/// Converts the PlayKubePod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PlayKubePod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.container_errors.as_ref().map(|container_errors| {
                [
                    "ContainerErrors".to_string(),
                    container_errors.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.containers.as_ref().map(|containers| {
                [
                    "Containers".to_string(),
                    containers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.init_containers.as_ref().map(|init_containers| {
                [
                    "InitContainers".to_string(),
                    init_containers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.logs.as_ref().map(|logs| {
                [
                    "Logs".to_string(),
                    logs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlayKubePod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlayKubePod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container_errors: Vec<Vec<String>>,
            pub containers: Vec<Vec<String>>,
            pub id: Vec<String>,
            pub init_containers: Vec<Vec<String>>,
            pub logs: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PlayKubePod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ContainerErrors" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubePod".to_string()),
                    "Containers" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubePod".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "InitContainers" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubePod".to_string()),
                    "Logs" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubePod".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PlayKubePod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlayKubePod {
            container_errors: intermediate_rep.container_errors.into_iter().next(),
            containers: intermediate_rep.containers.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            init_containers: intermediate_rep.init_containers.into_iter().next(),
            logs: intermediate_rep.logs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlayKubePod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PlayKubePod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PlayKubePod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PlayKubePod - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PlayKubePod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PlayKubePod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PlayKubePod - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlayKubeReport {
/// If set, exit with the specified exit code.
    #[serde(rename = "ExitCode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_code: Option<i32>,

/// Pods - pods created by play kube.
    #[serde(rename = "Pods")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pods: Option<Vec<models::PlayKubePod>>,

    #[serde(rename = "RmReport")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rm_report: Option<Vec<models::PodRmReport>>,

    #[serde(rename = "SecretRmReport")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_rm_report: Option<Vec<models::SecretRmReport>>,

/// Secrets - secrets created by play kube
    #[serde(rename = "Secrets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<models::PlaySecret>>,

/// ServiceContainerID - ID of the service container if one is created
    #[serde(rename = "ServiceContainerID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_container_id: Option<String>,

    #[serde(rename = "StopReport")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_report: Option<Vec<models::PodStopReport>>,

    #[serde(rename = "VolumeRmReport")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_rm_report: Option<Vec<models::VolumeRmReport>>,

/// Volumes - volumes created by play kube.
    #[serde(rename = "Volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<Vec<models::PlayKubeVolume>>,

}


impl PlayKubeReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PlayKubeReport {
        PlayKubeReport {
            exit_code: None,
            pods: None,
            rm_report: None,
            secret_rm_report: None,
            secrets: None,
            service_container_id: None,
            stop_report: None,
            volume_rm_report: None,
            volumes: None,
        }
    }
}

/// Converts the PlayKubeReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PlayKubeReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.exit_code.as_ref().map(|exit_code| {
                [
                    "ExitCode".to_string(),
                    exit_code.to_string(),
                ].join(",")
            }),

            // Skipping Pods in query parameter serialization

            // Skipping RmReport in query parameter serialization

            // Skipping SecretRmReport in query parameter serialization

            // Skipping Secrets in query parameter serialization


            self.service_container_id.as_ref().map(|service_container_id| {
                [
                    "ServiceContainerID".to_string(),
                    service_container_id.to_string(),
                ].join(",")
            }),

            // Skipping StopReport in query parameter serialization

            // Skipping VolumeRmReport in query parameter serialization

            // Skipping Volumes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlayKubeReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlayKubeReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub exit_code: Vec<i32>,
            pub pods: Vec<Vec<models::PlayKubePod>>,
            pub rm_report: Vec<Vec<models::PodRmReport>>,
            pub secret_rm_report: Vec<Vec<models::SecretRmReport>>,
            pub secrets: Vec<Vec<models::PlaySecret>>,
            pub service_container_id: Vec<String>,
            pub stop_report: Vec<Vec<models::PodStopReport>>,
            pub volume_rm_report: Vec<Vec<models::VolumeRmReport>>,
            pub volumes: Vec<Vec<models::PlayKubeVolume>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PlayKubeReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ExitCode" => intermediate_rep.exit_code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Pods" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubeReport".to_string()),
                    "RmReport" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubeReport".to_string()),
                    "SecretRmReport" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubeReport".to_string()),
                    "Secrets" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubeReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ServiceContainerID" => intermediate_rep.service_container_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "StopReport" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubeReport".to_string()),
                    "VolumeRmReport" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubeReport".to_string()),
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in PlayKubeReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PlayKubeReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlayKubeReport {
            exit_code: intermediate_rep.exit_code.into_iter().next(),
            pods: intermediate_rep.pods.into_iter().next(),
            rm_report: intermediate_rep.rm_report.into_iter().next(),
            secret_rm_report: intermediate_rep.secret_rm_report.into_iter().next(),
            secrets: intermediate_rep.secrets.into_iter().next(),
            service_container_id: intermediate_rep.service_container_id.into_iter().next(),
            stop_report: intermediate_rep.stop_report.into_iter().next(),
            volume_rm_report: intermediate_rep.volume_rm_report.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlayKubeReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PlayKubeReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PlayKubeReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PlayKubeReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PlayKubeReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PlayKubeReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PlayKubeReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlayKubeVolume {
/// Name - Name of the volume created by play kube.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl PlayKubeVolume {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PlayKubeVolume {
        PlayKubeVolume {
            name: None,
        }
    }
}

/// Converts the PlayKubeVolume value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PlayKubeVolume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlayKubeVolume value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlayKubeVolume {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PlayKubeVolume".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PlayKubeVolume".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlayKubeVolume {
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlayKubeVolume> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PlayKubeVolume>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PlayKubeVolume>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PlayKubeVolume - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PlayKubeVolume> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PlayKubeVolume as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PlayKubeVolume - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PlaySecret {
    #[serde(rename = "CreateReport")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_report: Option<models::SecretCreateReport>,

}


impl PlaySecret {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PlaySecret {
        PlaySecret {
            create_report: None,
        }
    }
}

/// Converts the PlaySecret value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PlaySecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CreateReport in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PlaySecret value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PlaySecret {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub create_report: Vec<models::SecretCreateReport>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PlaySecret".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CreateReport" => intermediate_rep.create_report.push(<models::SecretCreateReport as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PlaySecret".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PlaySecret {
            create_report: intermediate_rep.create_report.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PlaySecret> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PlaySecret>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PlaySecret>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PlaySecret - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PlaySecret> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PlaySecret as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PlaySecret - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Plugin A plugin for the Engine API



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Plugin {
    #[serde(rename = "Config")]
    pub config: models::PluginConfig,

/// True if the plugin is running. False if the plugin is not running, only installed.
    #[serde(rename = "Enabled")]
    pub enabled: bool,

/// Id
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// plugin remote reference used to push/pull the plugin
    #[serde(rename = "PluginReference")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plugin_reference: Option<String>,

    #[serde(rename = "Settings")]
    pub settings: models::PluginSettings,

}


impl Plugin {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(config: models::PluginConfig, enabled: bool, name: String, settings: models::PluginSettings, ) -> Plugin {
        Plugin {
            config,
            enabled,
            id: None,
            name,
            plugin_reference: None,
            settings,
        }
    }
}

/// Converts the Plugin value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Plugin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Config in query parameter serialization


            Some("Enabled".to_string()),
            Some(self.enabled.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            self.plugin_reference.as_ref().map(|plugin_reference| {
                [
                    "PluginReference".to_string(),
                    plugin_reference.to_string(),
                ].join(",")
            }),

            // Skipping Settings in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Plugin value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Plugin {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config: Vec<models::PluginConfig>,
            pub enabled: Vec<bool>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub plugin_reference: Vec<String>,
            pub settings: Vec<models::PluginSettings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Plugin".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Config" => intermediate_rep.config.push(<models::PluginConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Enabled" => intermediate_rep.enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PluginReference" => intermediate_rep.plugin_reference.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Settings" => intermediate_rep.settings.push(<models::PluginSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Plugin".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Plugin {
            config: intermediate_rep.config.into_iter().next().ok_or_else(|| "Config missing in Plugin".to_string())?,
            enabled: intermediate_rep.enabled.into_iter().next().ok_or_else(|| "Enabled missing in Plugin".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in Plugin".to_string())?,
            plugin_reference: intermediate_rep.plugin_reference.into_iter().next(),
            settings: intermediate_rep.settings.into_iter().next().ok_or_else(|| "Settings missing in Plugin".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Plugin> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Plugin>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Plugin>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Plugin - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Plugin> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Plugin as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Plugin - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfig {
    #[serde(rename = "Args")]
    pub args: models::PluginConfigArgs,

/// description
    #[serde(rename = "Description")]
    pub description: String,

/// Docker Version used to create the plugin
    #[serde(rename = "DockerVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker_version: Option<String>,

/// documentation
    #[serde(rename = "Documentation")]
    pub documentation: String,

/// entrypoint
    #[serde(rename = "Entrypoint")]
    pub entrypoint: Vec<String>,

/// env
    #[serde(rename = "Env")]
    pub env: Vec<models::PluginEnv>,

    #[serde(rename = "Interface")]
    pub interface: models::PluginConfigInterface,

/// ipc host
    #[serde(rename = "IpcHost")]
    pub ipc_host: bool,

    #[serde(rename = "Linux")]
    pub linux: models::PluginConfigLinux,

/// mounts
    #[serde(rename = "Mounts")]
    pub mounts: Vec<models::PluginMount>,

    #[serde(rename = "Network")]
    pub network: models::PluginConfigNetwork,

/// pid host
    #[serde(rename = "PidHost")]
    pub pid_host: bool,

/// propagated mount
    #[serde(rename = "PropagatedMount")]
    pub propagated_mount: String,

    #[serde(rename = "User")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<models::PluginConfigUser>,

/// work dir
    #[serde(rename = "WorkDir")]
    pub work_dir: String,

    #[serde(rename = "rootfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs: Option<models::PluginConfigRootfs>,

}


impl PluginConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(args: models::PluginConfigArgs, description: String, documentation: String, entrypoint: Vec<String>, env: Vec<models::PluginEnv>, interface: models::PluginConfigInterface, ipc_host: bool, linux: models::PluginConfigLinux, mounts: Vec<models::PluginMount>, network: models::PluginConfigNetwork, pid_host: bool, propagated_mount: String, work_dir: String, ) -> PluginConfig {
        PluginConfig {
            args,
            description,
            docker_version: None,
            documentation,
            entrypoint,
            env,
            interface,
            ipc_host,
            linux,
            mounts,
            network,
            pid_host,
            propagated_mount,
            user: None,
            work_dir,
            rootfs: None,
        }
    }
}

/// Converts the PluginConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Args in query parameter serialization


            Some("Description".to_string()),
            Some(self.description.to_string()),


            self.docker_version.as_ref().map(|docker_version| {
                [
                    "DockerVersion".to_string(),
                    docker_version.to_string(),
                ].join(",")
            }),


            Some("Documentation".to_string()),
            Some(self.documentation.to_string()),


            Some("Entrypoint".to_string()),
            Some(self.entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping Env in query parameter serialization

            // Skipping Interface in query parameter serialization


            Some("IpcHost".to_string()),
            Some(self.ipc_host.to_string()),

            // Skipping Linux in query parameter serialization

            // Skipping Mounts in query parameter serialization

            // Skipping Network in query parameter serialization


            Some("PidHost".to_string()),
            Some(self.pid_host.to_string()),


            Some("PropagatedMount".to_string()),
            Some(self.propagated_mount.to_string()),

            // Skipping User in query parameter serialization


            Some("WorkDir".to_string()),
            Some(self.work_dir.to_string()),

            // Skipping rootfs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args: Vec<models::PluginConfigArgs>,
            pub description: Vec<String>,
            pub docker_version: Vec<String>,
            pub documentation: Vec<String>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<Vec<models::PluginEnv>>,
            pub interface: Vec<models::PluginConfigInterface>,
            pub ipc_host: Vec<bool>,
            pub linux: Vec<models::PluginConfigLinux>,
            pub mounts: Vec<Vec<models::PluginMount>>,
            pub network: Vec<models::PluginConfigNetwork>,
            pub pid_host: Vec<bool>,
            pub propagated_mount: Vec<String>,
            pub user: Vec<models::PluginConfigUser>,
            pub work_dir: Vec<String>,
            pub rootfs: Vec<models::PluginConfigRootfs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Args" => intermediate_rep.args.push(<models::PluginConfigArgs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "DockerVersion" => intermediate_rep.docker_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Documentation" => intermediate_rep.documentation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfig".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Interface" => intermediate_rep.interface.push(<models::PluginConfigInterface as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IpcHost" => intermediate_rep.ipc_host.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Linux" => intermediate_rep.linux.push(<models::PluginConfigLinux as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Network" => intermediate_rep.network.push(<models::PluginConfigNetwork as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidHost" => intermediate_rep.pid_host.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PropagatedMount" => intermediate_rep.propagated_mount.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "User" => intermediate_rep.user.push(<models::PluginConfigUser as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "WorkDir" => intermediate_rep.work_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs" => intermediate_rep.rootfs.push(<models::PluginConfigRootfs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfig {
            args: intermediate_rep.args.into_iter().next().ok_or_else(|| "Args missing in PluginConfig".to_string())?,
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginConfig".to_string())?,
            docker_version: intermediate_rep.docker_version.into_iter().next(),
            documentation: intermediate_rep.documentation.into_iter().next().ok_or_else(|| "Documentation missing in PluginConfig".to_string())?,
            entrypoint: intermediate_rep.entrypoint.into_iter().next().ok_or_else(|| "Entrypoint missing in PluginConfig".to_string())?,
            env: intermediate_rep.env.into_iter().next().ok_or_else(|| "Env missing in PluginConfig".to_string())?,
            interface: intermediate_rep.interface.into_iter().next().ok_or_else(|| "Interface missing in PluginConfig".to_string())?,
            ipc_host: intermediate_rep.ipc_host.into_iter().next().ok_or_else(|| "IpcHost missing in PluginConfig".to_string())?,
            linux: intermediate_rep.linux.into_iter().next().ok_or_else(|| "Linux missing in PluginConfig".to_string())?,
            mounts: intermediate_rep.mounts.into_iter().next().ok_or_else(|| "Mounts missing in PluginConfig".to_string())?,
            network: intermediate_rep.network.into_iter().next().ok_or_else(|| "Network missing in PluginConfig".to_string())?,
            pid_host: intermediate_rep.pid_host.into_iter().next().ok_or_else(|| "PidHost missing in PluginConfig".to_string())?,
            propagated_mount: intermediate_rep.propagated_mount.into_iter().next().ok_or_else(|| "PropagatedMount missing in PluginConfig".to_string())?,
            user: intermediate_rep.user.into_iter().next(),
            work_dir: intermediate_rep.work_dir.into_iter().next().ok_or_else(|| "WorkDir missing in PluginConfig".to_string())?,
            rootfs: intermediate_rep.rootfs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigArgs plugin config args



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigArgs {
/// description
    #[serde(rename = "Description")]
    pub description: String,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// settable
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,

/// value
    #[serde(rename = "Value")]
    pub value: Vec<String>,

}


impl PluginConfigArgs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(description: String, name: String, settable: Vec<String>, value: Vec<String>, ) -> PluginConfigArgs {
        PluginConfigArgs {
            description,
            name,
            settable,
            value,
        }
    }
}

/// Converts the PluginConfigArgs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginConfigArgs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Description".to_string()),
            Some(self.description.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            Some("Settable".to_string()),
            Some(self.settable.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("Value".to_string()),
            Some(self.value.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigArgs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigArgs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub settable: Vec<Vec<String>>,
            pub value: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigArgs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Settable" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigArgs".to_string()),
                    "Value" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigArgs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigArgs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigArgs {
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginConfigArgs".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in PluginConfigArgs".to_string())?,
            settable: intermediate_rep.settable.into_iter().next().ok_or_else(|| "Settable missing in PluginConfigArgs".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "Value missing in PluginConfigArgs".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigArgs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigArgs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigArgs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigArgs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigArgs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigArgs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigArgs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigInterface The interface between Docker and the plugin



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigInterface {
/// Protocol to use for clients connecting to the plugin.
    #[serde(rename = "ProtocolScheme")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub protocol_scheme: Option<String>,

/// socket
    #[serde(rename = "Socket")]
    pub socket: String,

/// types
    #[serde(rename = "Types")]
    pub types: Vec<models::PluginInterfaceType>,

}


impl PluginConfigInterface {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(socket: String, types: Vec<models::PluginInterfaceType>, ) -> PluginConfigInterface {
        PluginConfigInterface {
            protocol_scheme: None,
            socket,
            types,
        }
    }
}

/// Converts the PluginConfigInterface value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginConfigInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.protocol_scheme.as_ref().map(|protocol_scheme| {
                [
                    "ProtocolScheme".to_string(),
                    protocol_scheme.to_string(),
                ].join(",")
            }),


            Some("Socket".to_string()),
            Some(self.socket.to_string()),

            // Skipping Types in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigInterface value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigInterface {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub protocol_scheme: Vec<String>,
            pub socket: Vec<String>,
            pub types: Vec<Vec<models::PluginInterfaceType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigInterface".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ProtocolScheme" => intermediate_rep.protocol_scheme.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Socket" => intermediate_rep.socket.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Types" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigInterface".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigInterface".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigInterface {
            protocol_scheme: intermediate_rep.protocol_scheme.into_iter().next(),
            socket: intermediate_rep.socket.into_iter().next().ok_or_else(|| "Socket missing in PluginConfigInterface".to_string())?,
            types: intermediate_rep.types.into_iter().next().ok_or_else(|| "Types missing in PluginConfigInterface".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigInterface> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigInterface>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigInterface>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigInterface - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigInterface> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigInterface as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigInterface - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigLinux plugin config linux



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigLinux {
/// allow all devices
    #[serde(rename = "AllowAllDevices")]
    pub allow_all_devices: bool,

/// capabilities
    #[serde(rename = "Capabilities")]
    pub capabilities: Vec<String>,

/// devices
    #[serde(rename = "Devices")]
    pub devices: Vec<models::PluginDevice>,

}


impl PluginConfigLinux {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(allow_all_devices: bool, capabilities: Vec<String>, devices: Vec<models::PluginDevice>, ) -> PluginConfigLinux {
        PluginConfigLinux {
            allow_all_devices,
            capabilities,
            devices,
        }
    }
}

/// Converts the PluginConfigLinux value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginConfigLinux {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("AllowAllDevices".to_string()),
            Some(self.allow_all_devices.to_string()),


            Some("Capabilities".to_string()),
            Some(self.capabilities.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping Devices in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigLinux value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigLinux {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub allow_all_devices: Vec<bool>,
            pub capabilities: Vec<Vec<String>>,
            pub devices: Vec<Vec<models::PluginDevice>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigLinux".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "AllowAllDevices" => intermediate_rep.allow_all_devices.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Capabilities" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigLinux".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigLinux".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigLinux".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigLinux {
            allow_all_devices: intermediate_rep.allow_all_devices.into_iter().next().ok_or_else(|| "AllowAllDevices missing in PluginConfigLinux".to_string())?,
            capabilities: intermediate_rep.capabilities.into_iter().next().ok_or_else(|| "Capabilities missing in PluginConfigLinux".to_string())?,
            devices: intermediate_rep.devices.into_iter().next().ok_or_else(|| "Devices missing in PluginConfigLinux".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigLinux> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigLinux>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigLinux>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigLinux - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigLinux> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigLinux as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigLinux - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigNetwork plugin config network



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigNetwork {
/// type
    #[serde(rename = "Type")]
    pub r#type: String,

}


impl PluginConfigNetwork {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, ) -> PluginConfigNetwork {
        PluginConfigNetwork {
            r#type,
        }
    }
}

/// Converts the PluginConfigNetwork value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginConfigNetwork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Type".to_string()),
            Some(self.r#type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigNetwork value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigNetwork {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigNetwork".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigNetwork".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigNetwork {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "Type missing in PluginConfigNetwork".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigNetwork> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigNetwork>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigNetwork>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigNetwork - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigNetwork> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigNetwork as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigNetwork - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigRootfs plugin config rootfs



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigRootfs {
/// diff ids
    #[serde(rename = "diff_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_ids: Option<Vec<String>>,

/// type
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl PluginConfigRootfs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PluginConfigRootfs {
        PluginConfigRootfs {
            diff_ids: None,
            r#type: None,
        }
    }
}

/// Converts the PluginConfigRootfs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginConfigRootfs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.diff_ids.as_ref().map(|diff_ids| {
                [
                    "diff_ids".to_string(),
                    diff_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigRootfs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigRootfs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub diff_ids: Vec<Vec<String>>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigRootfs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "diff_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginConfigRootfs".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigRootfs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigRootfs {
            diff_ids: intermediate_rep.diff_ids.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigRootfs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigRootfs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigRootfs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigRootfs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigRootfs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigRootfs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigRootfs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginConfigUser plugin config user



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginConfigUser {
/// g ID
    #[serde(rename = "GID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gid: Option<i32>,

/// UID
    #[serde(rename = "UID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid: Option<i32>,

}


impl PluginConfigUser {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PluginConfigUser {
        PluginConfigUser {
            gid: None,
            uid: None,
        }
    }
}

/// Converts the PluginConfigUser value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginConfigUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.gid.as_ref().map(|gid| {
                [
                    "GID".to_string(),
                    gid.to_string(),
                ].join(",")
            }),


            self.uid.as_ref().map(|uid| {
                [
                    "UID".to_string(),
                    uid.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginConfigUser value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginConfigUser {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gid: Vec<i32>,
            pub uid: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginConfigUser".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "GID" => intermediate_rep.gid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UID" => intermediate_rep.uid.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginConfigUser".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginConfigUser {
            gid: intermediate_rep.gid.into_iter().next(),
            uid: intermediate_rep.uid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginConfigUser> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginConfigUser>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginConfigUser>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginConfigUser - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginConfigUser> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginConfigUser as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginConfigUser - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginDevice plugin device



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginDevice {
/// description
    #[serde(rename = "Description")]
    pub description: String,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// path
    #[serde(rename = "Path")]
    pub path: String,

/// settable
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,

}


impl PluginDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(description: String, name: String, path: String, settable: Vec<String>, ) -> PluginDevice {
        PluginDevice {
            description,
            name,
            path,
            settable,
        }
    }
}

/// Converts the PluginDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Description".to_string()),
            Some(self.description.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            Some("Path".to_string()),
            Some(self.path.to_string()),


            Some("Settable".to_string()),
            Some(self.settable.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub path: Vec<String>,
            pub settable: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Settable" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginDevice".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginDevice {
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginDevice".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in PluginDevice".to_string())?,
            path: intermediate_rep.path.into_iter().next().ok_or_else(|| "Path missing in PluginDevice".to_string())?,
            settable: intermediate_rep.settable.into_iter().next().ok_or_else(|| "Settable missing in PluginDevice".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginEnv plugin env



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginEnv {
/// description
    #[serde(rename = "Description")]
    pub description: String,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// settable
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,

/// value
    #[serde(rename = "Value")]
    pub value: String,

}


impl PluginEnv {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(description: String, name: String, settable: Vec<String>, value: String, ) -> PluginEnv {
        PluginEnv {
            description,
            name,
            settable,
            value,
        }
    }
}

/// Converts the PluginEnv value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginEnv {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Description".to_string()),
            Some(self.description.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            Some("Settable".to_string()),
            Some(self.settable.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("Value".to_string()),
            Some(self.value.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginEnv value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginEnv {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub settable: Vec<Vec<String>>,
            pub value: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginEnv".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Settable" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginEnv".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginEnv".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginEnv {
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginEnv".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in PluginEnv".to_string())?,
            settable: intermediate_rep.settable.into_iter().next().ok_or_else(|| "Settable missing in PluginEnv".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "Value missing in PluginEnv".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginEnv> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginEnv>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginEnv>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginEnv - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginEnv> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginEnv as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginEnv - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginInterfaceType plugin interface type



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginInterfaceType {
/// capability
    #[serde(rename = "Capability")]
    pub capability: String,

/// prefix
    #[serde(rename = "Prefix")]
    pub prefix: String,

/// version
    #[serde(rename = "Version")]
    pub version: String,

}


impl PluginInterfaceType {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(capability: String, prefix: String, version: String, ) -> PluginInterfaceType {
        PluginInterfaceType {
            capability,
            prefix,
            version,
        }
    }
}

/// Converts the PluginInterfaceType value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginInterfaceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Capability".to_string()),
            Some(self.capability.to_string()),


            Some("Prefix".to_string()),
            Some(self.prefix.to_string()),


            Some("Version".to_string()),
            Some(self.version.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginInterfaceType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginInterfaceType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub capability: Vec<String>,
            pub prefix: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginInterfaceType".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Capability" => intermediate_rep.capability.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Prefix" => intermediate_rep.prefix.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginInterfaceType".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginInterfaceType {
            capability: intermediate_rep.capability.into_iter().next().ok_or_else(|| "Capability missing in PluginInterfaceType".to_string())?,
            prefix: intermediate_rep.prefix.into_iter().next().ok_or_else(|| "Prefix missing in PluginInterfaceType".to_string())?,
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| "Version missing in PluginInterfaceType".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginInterfaceType> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginInterfaceType>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginInterfaceType>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginInterfaceType - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginInterfaceType> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginInterfaceType as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginInterfaceType - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PluginMount plugin mount



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginMount {
/// description
    #[serde(rename = "Description")]
    pub description: String,

/// destination
    #[serde(rename = "Destination")]
    pub destination: String,

/// name
    #[serde(rename = "Name")]
    pub name: String,

/// options
    #[serde(rename = "Options")]
    pub options: Vec<String>,

/// settable
    #[serde(rename = "Settable")]
    pub settable: Vec<String>,

/// source
    #[serde(rename = "Source")]
    pub source: String,

/// type
    #[serde(rename = "Type")]
    pub r#type: String,

}


impl PluginMount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(description: String, destination: String, name: String, options: Vec<String>, settable: Vec<String>, source: String, r#type: String, ) -> PluginMount {
        PluginMount {
            description,
            destination,
            name,
            options,
            settable,
            source,
            r#type,
        }
    }
}

/// Converts the PluginMount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginMount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Description".to_string()),
            Some(self.description.to_string()),


            Some("Destination".to_string()),
            Some(self.destination.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),


            Some("Options".to_string()),
            Some(self.options.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("Settable".to_string()),
            Some(self.settable.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("Source".to_string()),
            Some(self.source.to_string()),


            Some("Type".to_string()),
            Some(self.r#type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginMount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginMount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub destination: Vec<String>,
            pub name: Vec<String>,
            pub options: Vec<Vec<String>>,
            pub settable: Vec<Vec<String>>,
            pub source: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginMount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Destination" => intermediate_rep.destination.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginMount".to_string()),
                    "Settable" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginMount".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Source" => intermediate_rep.source.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginMount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginMount {
            description: intermediate_rep.description.into_iter().next().ok_or_else(|| "Description missing in PluginMount".to_string())?,
            destination: intermediate_rep.destination.into_iter().next().ok_or_else(|| "Destination missing in PluginMount".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in PluginMount".to_string())?,
            options: intermediate_rep.options.into_iter().next().ok_or_else(|| "Options missing in PluginMount".to_string())?,
            settable: intermediate_rep.settable.into_iter().next().ok_or_else(|| "Settable missing in PluginMount".to_string())?,
            source: intermediate_rep.source.into_iter().next().ok_or_else(|| "Source missing in PluginMount".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "Type missing in PluginMount".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginMount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginMount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginMount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginMount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginMount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginMount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginMount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PluginSettings {
/// args
    #[serde(rename = "Args")]
    pub args: Vec<String>,

/// devices
    #[serde(rename = "Devices")]
    pub devices: Vec<models::PluginDevice>,

/// env
    #[serde(rename = "Env")]
    pub env: Vec<String>,

/// mounts
    #[serde(rename = "Mounts")]
    pub mounts: Vec<models::PluginMount>,

}


impl PluginSettings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(args: Vec<String>, devices: Vec<models::PluginDevice>, env: Vec<String>, mounts: Vec<models::PluginMount>, ) -> PluginSettings {
        PluginSettings {
            args,
            devices,
            env,
            mounts,
        }
    }
}

/// Converts the PluginSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PluginSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Args".to_string()),
            Some(self.args.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping Devices in query parameter serialization


            Some("Env".to_string()),
            Some(self.env.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping Mounts in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PluginSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PluginSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub args: Vec<Vec<String>>,
            pub devices: Vec<Vec<models::PluginDevice>>,
            pub env: Vec<Vec<String>>,
            pub mounts: Vec<Vec<models::PluginMount>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PluginSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Args" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginSettings".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginSettings".to_string()),
                    "Env" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginSettings".to_string()),
                    "Mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in PluginSettings".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PluginSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PluginSettings {
            args: intermediate_rep.args.into_iter().next().ok_or_else(|| "Args missing in PluginSettings".to_string())?,
            devices: intermediate_rep.devices.into_iter().next().ok_or_else(|| "Devices missing in PluginSettings".to_string())?,
            env: intermediate_rep.env.into_iter().next().ok_or_else(|| "Env missing in PluginSettings".to_string())?,
            mounts: intermediate_rep.mounts.into_iter().next().ok_or_else(|| "Mounts missing in PluginSettings".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PluginSettings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PluginSettings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PluginSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PluginSettings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PluginSettings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PluginSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PluginSettings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Plugins {
/// Authorization is provided for compatibility, will always be nil as Podman has no daemon
    #[serde(rename = "authorization")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub authorization: Option<Vec<String>>,

    #[serde(rename = "log")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log: Option<Vec<String>>,

    #[serde(rename = "network")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network: Option<Vec<String>>,

    #[serde(rename = "volume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume: Option<Vec<String>>,

}


impl Plugins {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Plugins {
        Plugins {
            authorization: None,
            log: None,
            network: None,
            volume: None,
        }
    }
}

/// Converts the Plugins value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Plugins {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.authorization.as_ref().map(|authorization| {
                [
                    "authorization".to_string(),
                    authorization.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.log.as_ref().map(|log| {
                [
                    "log".to_string(),
                    log.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.network.as_ref().map(|network| {
                [
                    "network".to_string(),
                    network.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.volume.as_ref().map(|volume| {
                [
                    "volume".to_string(),
                    volume.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Plugins value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Plugins {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub authorization: Vec<Vec<String>>,
            pub log: Vec<Vec<String>>,
            pub network: Vec<Vec<String>>,
            pub volume: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Plugins".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "authorization" => return std::result::Result::Err("Parsing a container in this style is not supported in Plugins".to_string()),
                    "log" => return std::result::Result::Err("Parsing a container in this style is not supported in Plugins".to_string()),
                    "network" => return std::result::Result::Err("Parsing a container in this style is not supported in Plugins".to_string()),
                    "volume" => return std::result::Result::Err("Parsing a container in this style is not supported in Plugins".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Plugins".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Plugins {
            authorization: intermediate_rep.authorization.into_iter().next(),
            log: intermediate_rep.log.into_iter().next(),
            network: intermediate_rep.network.into_iter().next(),
            volume: intermediate_rep.volume.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Plugins> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Plugins>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Plugins>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Plugins - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Plugins> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Plugins as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Plugins - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodBasicConfig {
/// ExitPolicy determines the pod's exit and stop behaviour.
    #[serde(rename = "exit_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_policy: Option<String>,

/// Hostname is the pod's hostname. If not set, the name of the pod will be used (if a name was not provided here, the name auto-generated for the pod will be used). This will be used by the infra container and all containers in the pod as long as the UTS namespace is shared. Optional.
    #[serde(rename = "hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

/// InfraCommand sets the command that will be used to start the infra container. If not set, the default set in the Libpod configuration file will be used. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "infra_command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_command: Option<Vec<String>>,

/// InfraConmonPidFile is a custom path to store the infra container's conmon PID.
    #[serde(rename = "infra_conmon_pid_file")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_conmon_pid_file: Option<String>,

/// InfraImage is the image that will be used for the infra container. If not set, the default set in the Libpod configuration file will be used. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "infra_image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_image: Option<String>,

/// InfraName is the name that will be used for the infra container. If not set, the default set in the Libpod configuration file will be used. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "infra_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_name: Option<String>,

    #[serde(rename = "ipcns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipcns: Option<models::Namespace>,

/// Labels are key-value pairs that are used to add metadata to pods. Optional.
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// Name is the name of the pod. If not provided, a name will be generated when the pod is created. Optional.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// NoInfra tells the pod not to create an infra container. If this is done, many networking-related options will become unavailable. Conflicts with setting any options in PodNetworkConfig, and the InfraCommand and InfraImages in this struct. Optional.
    #[serde(rename = "no_infra")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_infra: Option<bool>,

    #[serde(rename = "pidns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pidns: Option<models::Namespace>,

    #[serde(rename = "pod_create_command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_create_command: Option<Vec<String>>,

/// Devices contains user specified Devices to be added to the Pod
    #[serde(rename = "pod_devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_devices: Option<Vec<String>>,

/// RestartPolicy is the pod's restart policy - an action which will be taken when one or all the containers in the pod exits. If not given, the default policy will be set to Always, which restarts the containers in the pod when they exit indefinitely. Optional.
    #[serde(rename = "restart_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<String>,

/// RestartRetries is the number of attempts that will be made to restart the container. Only available when RestartPolicy is set to \"on-failure\". Optional.
    #[serde(rename = "restart_tries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_tries: Option<i32>,

/// PodCreateCommand is the command used to create this pod. This will be shown in the output of Inspect() on the pod, and may also be used by some tools that wish to recreate the pod (e.g. `podman generate systemd --new`). Optional. ShareParent determines if all containers in the pod will share the pod's cgroup as the cgroup parent
    #[serde(rename = "share_parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub share_parent: Option<bool>,

/// SharedNamespaces instructs the pod to share a set of namespaces. Shared namespaces will be joined (by default) by every container which joins the pod. If not set and NoInfra is false, the pod will set a default set of namespaces to share. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "shared_namespaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shared_namespaces: Option<Vec<String>>,

/// Sysctl sets kernel parameters for the pod
    #[serde(rename = "sysctl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sysctl: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "userns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub userns: Option<models::Namespace>,

    #[serde(rename = "utsns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub utsns: Option<models::Namespace>,

}


impl PodBasicConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodBasicConfig {
        PodBasicConfig {
            exit_policy: None,
            hostname: None,
            infra_command: None,
            infra_conmon_pid_file: None,
            infra_image: None,
            infra_name: None,
            ipcns: None,
            labels: None,
            name: None,
            no_infra: None,
            pidns: None,
            pod_create_command: None,
            pod_devices: None,
            restart_policy: None,
            restart_tries: None,
            share_parent: None,
            shared_namespaces: None,
            sysctl: None,
            userns: None,
            utsns: None,
        }
    }
}

/// Converts the PodBasicConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodBasicConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.exit_policy.as_ref().map(|exit_policy| {
                [
                    "exit_policy".to_string(),
                    exit_policy.to_string(),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.infra_command.as_ref().map(|infra_command| {
                [
                    "infra_command".to_string(),
                    infra_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.infra_conmon_pid_file.as_ref().map(|infra_conmon_pid_file| {
                [
                    "infra_conmon_pid_file".to_string(),
                    infra_conmon_pid_file.to_string(),
                ].join(",")
            }),


            self.infra_image.as_ref().map(|infra_image| {
                [
                    "infra_image".to_string(),
                    infra_image.to_string(),
                ].join(",")
            }),


            self.infra_name.as_ref().map(|infra_name| {
                [
                    "infra_name".to_string(),
                    infra_name.to_string(),
                ].join(",")
            }),

            // Skipping ipcns in query parameter serialization

            // Skipping labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.no_infra.as_ref().map(|no_infra| {
                [
                    "no_infra".to_string(),
                    no_infra.to_string(),
                ].join(",")
            }),

            // Skipping pidns in query parameter serialization


            self.pod_create_command.as_ref().map(|pod_create_command| {
                [
                    "pod_create_command".to_string(),
                    pod_create_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.pod_devices.as_ref().map(|pod_devices| {
                [
                    "pod_devices".to_string(),
                    pod_devices.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.restart_policy.as_ref().map(|restart_policy| {
                [
                    "restart_policy".to_string(),
                    restart_policy.to_string(),
                ].join(",")
            }),


            self.restart_tries.as_ref().map(|restart_tries| {
                [
                    "restart_tries".to_string(),
                    restart_tries.to_string(),
                ].join(",")
            }),


            self.share_parent.as_ref().map(|share_parent| {
                [
                    "share_parent".to_string(),
                    share_parent.to_string(),
                ].join(",")
            }),


            self.shared_namespaces.as_ref().map(|shared_namespaces| {
                [
                    "shared_namespaces".to_string(),
                    shared_namespaces.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping sysctl in query parameter serialization

            // Skipping userns in query parameter serialization

            // Skipping utsns in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodBasicConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodBasicConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub exit_policy: Vec<String>,
            pub hostname: Vec<String>,
            pub infra_command: Vec<Vec<String>>,
            pub infra_conmon_pid_file: Vec<String>,
            pub infra_image: Vec<String>,
            pub infra_name: Vec<String>,
            pub ipcns: Vec<models::Namespace>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub no_infra: Vec<bool>,
            pub pidns: Vec<models::Namespace>,
            pub pod_create_command: Vec<Vec<String>>,
            pub pod_devices: Vec<Vec<String>>,
            pub restart_policy: Vec<String>,
            pub restart_tries: Vec<i32>,
            pub share_parent: Vec<bool>,
            pub shared_namespaces: Vec<Vec<String>>,
            pub sysctl: Vec<std::collections::HashMap<String, String>>,
            pub userns: Vec<models::Namespace>,
            pub utsns: Vec<models::Namespace>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodBasicConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "exit_policy" => intermediate_rep.exit_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "infra_command" => return std::result::Result::Err("Parsing a container in this style is not supported in PodBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "infra_conmon_pid_file" => intermediate_rep.infra_conmon_pid_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "infra_image" => intermediate_rep.infra_image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "infra_name" => intermediate_rep.infra_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipcns" => intermediate_rep.ipcns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in PodBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "no_infra" => intermediate_rep.no_infra.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pidns" => intermediate_rep.pidns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pod_create_command" => return std::result::Result::Err("Parsing a container in this style is not supported in PodBasicConfig".to_string()),
                    "pod_devices" => return std::result::Result::Err("Parsing a container in this style is not supported in PodBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "restart_policy" => intermediate_rep.restart_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "restart_tries" => intermediate_rep.restart_tries.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "share_parent" => intermediate_rep.share_parent.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "shared_namespaces" => return std::result::Result::Err("Parsing a container in this style is not supported in PodBasicConfig".to_string()),
                    "sysctl" => return std::result::Result::Err("Parsing a container in this style is not supported in PodBasicConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "userns" => intermediate_rep.userns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "utsns" => intermediate_rep.utsns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodBasicConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodBasicConfig {
            exit_policy: intermediate_rep.exit_policy.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            infra_command: intermediate_rep.infra_command.into_iter().next(),
            infra_conmon_pid_file: intermediate_rep.infra_conmon_pid_file.into_iter().next(),
            infra_image: intermediate_rep.infra_image.into_iter().next(),
            infra_name: intermediate_rep.infra_name.into_iter().next(),
            ipcns: intermediate_rep.ipcns.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            no_infra: intermediate_rep.no_infra.into_iter().next(),
            pidns: intermediate_rep.pidns.into_iter().next(),
            pod_create_command: intermediate_rep.pod_create_command.into_iter().next(),
            pod_devices: intermediate_rep.pod_devices.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            restart_tries: intermediate_rep.restart_tries.into_iter().next(),
            share_parent: intermediate_rep.share_parent.into_iter().next(),
            shared_namespaces: intermediate_rep.shared_namespaces.into_iter().next(),
            sysctl: intermediate_rep.sysctl.into_iter().next(),
            userns: intermediate_rep.userns.into_iter().next(),
            utsns: intermediate_rep.utsns.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodBasicConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodBasicConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodBasicConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodBasicConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodBasicConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodBasicConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodBasicConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// This will be expanded in future updates to pods.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodCgroupConfig {
/// CgroupParent is the parent for the Cgroup that the pod will create. This pod cgroup will, in turn, be the default cgroup parent for all containers in the pod. Optional.
    #[serde(rename = "cgroup_parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

}


impl PodCgroupConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodCgroupConfig {
        PodCgroupConfig {
            cgroup_parent: None,
        }
    }
}

/// Converts the PodCgroupConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodCgroupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "cgroup_parent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodCgroupConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodCgroupConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup_parent: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodCgroupConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cgroup_parent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodCgroupConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodCgroupConfig {
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodCgroupConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodCgroupConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodCgroupConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodCgroupConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodCgroupConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodCgroupConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodCgroupConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The JSON tags below are made to match the respective field in ContainerCreateOptions for the purpose of mapping.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodCreateOptions {
    #[serde(rename = "cgroup_parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

    #[serde(rename = "container_command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_command: Option<String>,

    #[serde(rename = "container_conmon_pidfile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_conmon_pidfile: Option<String>,

    #[serde(rename = "container_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_name: Option<String>,

    #[serde(rename = "cpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpus: Option<f64>,

    #[serde(rename = "cpuset_cpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

    #[serde(rename = "create_command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_command: Option<Vec<String>>,

    #[serde(rename = "device_read_bps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_read_bps: Option<Vec<String>>,

    #[serde(rename = "devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<String>>,

    #[serde(rename = "exit_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_policy: Option<String>,

    #[serde(rename = "hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

    #[serde(rename = "infra")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra: Option<bool>,

    #[serde(rename = "infra_image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_image: Option<String>,

    #[serde(rename = "ipc")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipc: Option<String>,

    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "net")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub net: Option<models::NetOptions>,

    #[serde(rename = "pid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pid: Option<String>,

    #[serde(rename = "restart")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart: Option<String>,

    #[serde(rename = "security_opt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_opt: Option<Vec<String>>,

    #[serde(rename = "share")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub share: Option<Vec<String>>,

    #[serde(rename = "share_parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub share_parent: Option<bool>,

    #[serde(rename = "sysctl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sysctl: Option<Vec<String>>,

    #[serde(rename = "uts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uts: Option<String>,

    #[serde(rename = "volume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume: Option<Vec<String>>,

    #[serde(rename = "volumes_from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

}


impl PodCreateOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodCreateOptions {
        PodCreateOptions {
            cgroup_parent: None,
            container_command: None,
            container_conmon_pidfile: None,
            container_name: None,
            cpus: None,
            cpuset_cpus: None,
            create_command: None,
            device_read_bps: None,
            devices: None,
            exit_policy: None,
            hostname: None,
            infra: None,
            infra_image: None,
            ipc: None,
            labels: None,
            name: None,
            net: None,
            pid: None,
            restart: None,
            security_opt: None,
            share: None,
            share_parent: None,
            sysctl: None,
            uts: None,
            volume: None,
            volumes_from: None,
        }
    }
}

/// Converts the PodCreateOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodCreateOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "cgroup_parent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.container_command.as_ref().map(|container_command| {
                [
                    "container_command".to_string(),
                    container_command.to_string(),
                ].join(",")
            }),


            self.container_conmon_pidfile.as_ref().map(|container_conmon_pidfile| {
                [
                    "container_conmon_pidfile".to_string(),
                    container_conmon_pidfile.to_string(),
                ].join(",")
            }),


            self.container_name.as_ref().map(|container_name| {
                [
                    "container_name".to_string(),
                    container_name.to_string(),
                ].join(",")
            }),


            self.cpus.as_ref().map(|cpus| {
                [
                    "cpus".to_string(),
                    cpus.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "cpuset_cpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.create_command.as_ref().map(|create_command| {
                [
                    "create_command".to_string(),
                    create_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.device_read_bps.as_ref().map(|device_read_bps| {
                [
                    "device_read_bps".to_string(),
                    device_read_bps.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.devices.as_ref().map(|devices| {
                [
                    "devices".to_string(),
                    devices.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.exit_policy.as_ref().map(|exit_policy| {
                [
                    "exit_policy".to_string(),
                    exit_policy.to_string(),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.infra.as_ref().map(|infra| {
                [
                    "infra".to_string(),
                    infra.to_string(),
                ].join(",")
            }),


            self.infra_image.as_ref().map(|infra_image| {
                [
                    "infra_image".to_string(),
                    infra_image.to_string(),
                ].join(",")
            }),


            self.ipc.as_ref().map(|ipc| {
                [
                    "ipc".to_string(),
                    ipc.to_string(),
                ].join(",")
            }),

            // Skipping labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping net in query parameter serialization


            self.pid.as_ref().map(|pid| {
                [
                    "pid".to_string(),
                    pid.to_string(),
                ].join(",")
            }),


            self.restart.as_ref().map(|restart| {
                [
                    "restart".to_string(),
                    restart.to_string(),
                ].join(",")
            }),


            self.security_opt.as_ref().map(|security_opt| {
                [
                    "security_opt".to_string(),
                    security_opt.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.share.as_ref().map(|share| {
                [
                    "share".to_string(),
                    share.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.share_parent.as_ref().map(|share_parent| {
                [
                    "share_parent".to_string(),
                    share_parent.to_string(),
                ].join(",")
            }),


            self.sysctl.as_ref().map(|sysctl| {
                [
                    "sysctl".to_string(),
                    sysctl.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.uts.as_ref().map(|uts| {
                [
                    "uts".to_string(),
                    uts.to_string(),
                ].join(",")
            }),


            self.volume.as_ref().map(|volume| {
                [
                    "volume".to_string(),
                    volume.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "volumes_from".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodCreateOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodCreateOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cgroup_parent: Vec<String>,
            pub container_command: Vec<String>,
            pub container_conmon_pidfile: Vec<String>,
            pub container_name: Vec<String>,
            pub cpus: Vec<f64>,
            pub cpuset_cpus: Vec<String>,
            pub create_command: Vec<Vec<String>>,
            pub device_read_bps: Vec<Vec<String>>,
            pub devices: Vec<Vec<String>>,
            pub exit_policy: Vec<String>,
            pub hostname: Vec<String>,
            pub infra: Vec<bool>,
            pub infra_image: Vec<String>,
            pub ipc: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub net: Vec<models::NetOptions>,
            pub pid: Vec<String>,
            pub restart: Vec<String>,
            pub security_opt: Vec<Vec<String>>,
            pub share: Vec<Vec<String>>,
            pub share_parent: Vec<bool>,
            pub sysctl: Vec<Vec<String>>,
            pub uts: Vec<String>,
            pub volume: Vec<Vec<String>>,
            pub volumes_from: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodCreateOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cgroup_parent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "container_command" => intermediate_rep.container_command.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "container_conmon_pidfile" => intermediate_rep.container_conmon_pidfile.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "container_name" => intermediate_rep.container_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpus" => intermediate_rep.cpus.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpuset_cpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "create_command" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    "device_read_bps" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    "devices" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "exit_policy" => intermediate_rep.exit_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "infra" => intermediate_rep.infra.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "infra_image" => intermediate_rep.infra_image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipc" => intermediate_rep.ipc.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "net" => intermediate_rep.net.push(<models::NetOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pid" => intermediate_rep.pid.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "restart" => intermediate_rep.restart.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "security_opt" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    "share" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "share_parent" => intermediate_rep.share_parent.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "sysctl" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "uts" => intermediate_rep.uts.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volume" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    "volumes_from" => return std::result::Result::Err("Parsing a container in this style is not supported in PodCreateOptions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodCreateOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodCreateOptions {
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            container_command: intermediate_rep.container_command.into_iter().next(),
            container_conmon_pidfile: intermediate_rep.container_conmon_pidfile.into_iter().next(),
            container_name: intermediate_rep.container_name.into_iter().next(),
            cpus: intermediate_rep.cpus.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            create_command: intermediate_rep.create_command.into_iter().next(),
            device_read_bps: intermediate_rep.device_read_bps.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            exit_policy: intermediate_rep.exit_policy.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            infra: intermediate_rep.infra.into_iter().next(),
            infra_image: intermediate_rep.infra_image.into_iter().next(),
            ipc: intermediate_rep.ipc.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            net: intermediate_rep.net.into_iter().next(),
            pid: intermediate_rep.pid.into_iter().next(),
            restart: intermediate_rep.restart.into_iter().next(),
            security_opt: intermediate_rep.security_opt.into_iter().next(),
            share: intermediate_rep.share.into_iter().next(),
            share_parent: intermediate_rep.share_parent.into_iter().next(),
            sysctl: intermediate_rep.sysctl.into_iter().next(),
            uts: intermediate_rep.uts.into_iter().next(),
            volume: intermediate_rep.volume.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodCreateOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodCreateOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodCreateOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodCreateOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodCreateOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodCreateOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodCreateOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodKillReport {
    #[serde(rename = "Errs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errs: Option<Vec<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl PodKillReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodKillReport {
        PodKillReport {
            errs: None,
            id: None,
        }
    }
}

/// Converts the PodKillReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodKillReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.errs.as_ref().map(|errs| {
                [
                    "Errs".to_string(),
                    errs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodKillReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodKillReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errs: Vec<Vec<String>>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodKillReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Errs" => return std::result::Result::Err("Parsing a container in this style is not supported in PodKillReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodKillReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodKillReport {
            errs: intermediate_rep.errs.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodKillReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodKillReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodKillReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodKillReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodKillReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodKillReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodKillReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodNetworkConfig {
/// Map of networks names to ids the container should join to. You can request additional settings for each network, you can set network aliases, static ips, static mac address  and the network interface name for this container on the specific network. If the map is empty and the bridge network mode is set the container will be joined to the default network.
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<std::collections::HashMap<String, models::PerNetworkOptions>>,

/// CNINetworks is a list of CNI networks to join the container to. If this list is empty, the default CNI network will be joined instead. If at least one entry is present, we will not join the default network (unless it is part of this list). Only available if NetNS is set to bridge. Optional. Deprecated: as of podman 4.0 use \"Networks\" instead.
    #[serde(rename = "cni_networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cni_networks: Option<Vec<String>>,

/// DNSOption is a set of DNS options that will be used in the infra container's resolv.conf, which will, by default, be shared with all containers in the pod. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "dns_option")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_option: Option<Vec<String>>,

/// DNSSearch is a set of DNS search domains that will be used in the infra container's resolv.conf, which will, by default, be shared with all containers in the pod. If not provided, DNS search domains from the host's resolv.conf will be used. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "dns_search")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

/// DNSServer is a set of DNS servers that will be used in the infra container's resolv.conf, which will, by default, be shared with all containers in the pod. If not provided, the host's DNS servers will be used, unless the only server set is a localhost address. As the container cannot connect to the host's localhost, a default server will instead be set. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "dns_server")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_server: Option<Vec<String>>,

/// HostAdd is a set of hosts that will be added to the infra container's etc/hosts that will, by default, be shared with all containers in the pod. Conflicts with NoInfra=true and NoManageHosts. Optional.
    #[serde(rename = "hostadd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostadd: Option<Vec<String>>,

    #[serde(rename = "netns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub netns: Option<models::Namespace>,

/// NetworkOptions are additional options for each network Optional.
    #[serde(rename = "network_options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_options: Option<std::collections::HashMap<String, Vec<String>>>,

/// NoManageHosts indicates that /etc/hosts should not be managed by the pod. Instead, each container will create a separate /etc/hosts as they would if not in a pod. Conflicts with HostAdd.
    #[serde(rename = "no_manage_hosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_manage_hosts: Option<bool>,

/// NoManageResolvConf indicates that /etc/resolv.conf should not be managed by the pod. Instead, each container will create and manage a separate resolv.conf as if they had not joined a pod. Conflicts with NoInfra=true and DNSServer, DNSSearch, DNSOption. Optional.
    #[serde(rename = "no_manage_resolv_conf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_manage_resolv_conf: Option<bool>,

/// PortMappings is a set of ports to map into the infra container. As, by default, containers share their network with the infra container, this will forward the ports to the entire pod. Only available if NetNS is set to Bridge, Slirp, or Pasta. Optional.
    #[serde(rename = "portmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub portmappings: Option<Vec<models::PortMapping>>,

}


impl PodNetworkConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodNetworkConfig {
        PodNetworkConfig {
            networks: None,
            cni_networks: None,
            dns_option: None,
            dns_search: None,
            dns_server: None,
            hostadd: None,
            netns: None,
            network_options: None,
            no_manage_hosts: None,
            no_manage_resolv_conf: None,
            portmappings: None,
        }
    }
}

/// Converts the PodNetworkConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Networks in query parameter serialization
            // Skipping Networks in query parameter serialization


            self.cni_networks.as_ref().map(|cni_networks| {
                [
                    "cni_networks".to_string(),
                    cni_networks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_option.as_ref().map(|dns_option| {
                [
                    "dns_option".to_string(),
                    dns_option.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "dns_search".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_server.as_ref().map(|dns_server| {
                [
                    "dns_server".to_string(),
                    dns_server.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.hostadd.as_ref().map(|hostadd| {
                [
                    "hostadd".to_string(),
                    hostadd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping netns in query parameter serialization

            // Skipping network_options in query parameter serialization
            // Skipping network_options in query parameter serialization


            self.no_manage_hosts.as_ref().map(|no_manage_hosts| {
                [
                    "no_manage_hosts".to_string(),
                    no_manage_hosts.to_string(),
                ].join(",")
            }),


            self.no_manage_resolv_conf.as_ref().map(|no_manage_resolv_conf| {
                [
                    "no_manage_resolv_conf".to_string(),
                    no_manage_resolv_conf.to_string(),
                ].join(",")
            }),

            // Skipping portmappings in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodNetworkConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodNetworkConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub networks: Vec<std::collections::HashMap<String, models::PerNetworkOptions>>,
            pub cni_networks: Vec<Vec<String>>,
            pub dns_option: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub dns_server: Vec<Vec<String>>,
            pub hostadd: Vec<Vec<String>>,
            pub netns: Vec<models::Namespace>,
            pub network_options: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub no_manage_hosts: Vec<bool>,
            pub no_manage_resolv_conf: Vec<bool>,
            pub portmappings: Vec<Vec<models::PortMapping>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodNetworkConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in PodNetworkConfig".to_string()),
                    "cni_networks" => return std::result::Result::Err("Parsing a container in this style is not supported in PodNetworkConfig".to_string()),
                    "dns_option" => return std::result::Result::Err("Parsing a container in this style is not supported in PodNetworkConfig".to_string()),
                    "dns_search" => return std::result::Result::Err("Parsing a container in this style is not supported in PodNetworkConfig".to_string()),
                    "dns_server" => return std::result::Result::Err("Parsing a container in this style is not supported in PodNetworkConfig".to_string()),
                    "hostadd" => return std::result::Result::Err("Parsing a container in this style is not supported in PodNetworkConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "netns" => intermediate_rep.netns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "network_options" => return std::result::Result::Err("Parsing a container in this style is not supported in PodNetworkConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "no_manage_hosts" => intermediate_rep.no_manage_hosts.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "no_manage_resolv_conf" => intermediate_rep.no_manage_resolv_conf.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "portmappings" => return std::result::Result::Err("Parsing a container in this style is not supported in PodNetworkConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodNetworkConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodNetworkConfig {
            networks: intermediate_rep.networks.into_iter().next(),
            cni_networks: intermediate_rep.cni_networks.into_iter().next(),
            dns_option: intermediate_rep.dns_option.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            dns_server: intermediate_rep.dns_server.into_iter().next(),
            hostadd: intermediate_rep.hostadd.into_iter().next(),
            netns: intermediate_rep.netns.into_iter().next(),
            network_options: intermediate_rep.network_options.into_iter().next(),
            no_manage_hosts: intermediate_rep.no_manage_hosts.into_iter().next(),
            no_manage_resolv_conf: intermediate_rep.no_manage_resolv_conf.into_iter().next(),
            portmappings: intermediate_rep.portmappings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodNetworkConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodNetworkConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodNetworkConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodNetworkConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodNetworkConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodNetworkConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodNetworkConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodPauseReport {
    #[serde(rename = "Errs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errs: Option<Vec<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl PodPauseReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodPauseReport {
        PodPauseReport {
            errs: None,
            id: None,
        }
    }
}

/// Converts the PodPauseReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodPauseReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.errs.as_ref().map(|errs| {
                [
                    "Errs".to_string(),
                    errs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodPauseReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodPauseReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errs: Vec<Vec<String>>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodPauseReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Errs" => return std::result::Result::Err("Parsing a container in this style is not supported in PodPauseReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodPauseReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodPauseReport {
            errs: intermediate_rep.errs.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodPauseReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodPauseReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodPauseReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodPauseReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodPauseReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodPauseReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodPauseReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodPruneReport {
    #[serde(rename = "Err")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub err: Option<String>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl PodPruneReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodPruneReport {
        PodPruneReport {
            err: None,
            id: None,
        }
    }
}

/// Converts the PodPruneReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodPruneReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.err.as_ref().map(|err| {
                [
                    "Err".to_string(),
                    err.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodPruneReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodPruneReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub err: Vec<String>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodPruneReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Err" => intermediate_rep.err.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodPruneReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodPruneReport {
            err: intermediate_rep.err.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodPruneReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodPruneReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodPruneReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodPruneReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodPruneReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodPruneReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodPruneReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodResourceConfig {
/// CPU period of the cpuset, determined by --cpus
    #[serde(rename = "cpu_period")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i32>,

/// CPU quota of the cpuset, determined by --cpus
    #[serde(rename = "cpu_quota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

    #[serde(rename = "resource_limits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_limits: Option<models::LinuxResources>,

/// ThrottleReadBpsDevice contains the rate at which the devices in the pod can be read from/accessed
    #[serde(rename = "throttleReadBpsDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_read_bps_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

}


impl PodResourceConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodResourceConfig {
        PodResourceConfig {
            cpu_period: None,
            cpu_quota: None,
            resource_limits: None,
            throttle_read_bps_device: None,
        }
    }
}

/// Converts the PodResourceConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodResourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "cpu_period".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "cpu_quota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),

            // Skipping resource_limits in query parameter serialization

            // Skipping throttleReadBpsDevice in query parameter serialization
            // Skipping throttleReadBpsDevice in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodResourceConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodResourceConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cpu_period: Vec<i32>,
            pub cpu_quota: Vec<i64>,
            pub resource_limits: Vec<models::LinuxResources>,
            pub throttle_read_bps_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodResourceConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cpu_period" => intermediate_rep.cpu_period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpu_quota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resource_limits" => intermediate_rep.resource_limits.push(<models::LinuxResources as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "throttleReadBpsDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in PodResourceConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodResourceConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodResourceConfig {
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            resource_limits: intermediate_rep.resource_limits.into_iter().next(),
            throttle_read_bps_device: intermediate_rep.throttle_read_bps_device.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodResourceConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodResourceConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodResourceConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodResourceConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodResourceConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodResourceConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodResourceConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodRestartReport {
    #[serde(rename = "Errs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errs: Option<Vec<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl PodRestartReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodRestartReport {
        PodRestartReport {
            errs: None,
            id: None,
        }
    }
}

/// Converts the PodRestartReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodRestartReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.errs.as_ref().map(|errs| {
                [
                    "Errs".to_string(),
                    errs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodRestartReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodRestartReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errs: Vec<Vec<String>>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodRestartReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Errs" => return std::result::Result::Err("Parsing a container in this style is not supported in PodRestartReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodRestartReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodRestartReport {
            errs: intermediate_rep.errs.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodRestartReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodRestartReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodRestartReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodRestartReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodRestartReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodRestartReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodRestartReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate, Default)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodRmReport {
    #[serde(rename = "Err")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub err: Option<String>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "RemovedCtrs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub removed_ctrs: Option<std::collections::HashMap<String, String>>,

}


impl PodRmReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodRmReport {
        PodRmReport {
            err: None,
            id: None,
            removed_ctrs: None,
        }
    }
}

/// Converts the PodRmReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodRmReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.err.as_ref().map(|err| {
                [
                    "Err".to_string(),
                    err.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping RemovedCtrs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodRmReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodRmReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub err: Vec<String>,
            pub id: Vec<String>,
            pub removed_ctrs: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodRmReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Err" => intermediate_rep.err.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "RemovedCtrs" => return std::result::Result::Err("Parsing a container in this style is not supported in PodRmReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodRmReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodRmReport {
            err: intermediate_rep.err.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            removed_ctrs: intermediate_rep.removed_ctrs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodRmReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodRmReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodRmReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodRmReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodRmReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodRmReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodRmReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodSecurityConfig {
    #[serde(rename = "idmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub idmappings: Option<models::IdMappingOptions>,

    #[serde(rename = "security_opt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_opt: Option<Vec<String>>,

}


impl PodSecurityConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodSecurityConfig {
        PodSecurityConfig {
            idmappings: None,
            security_opt: None,
        }
    }
}

/// Converts the PodSecurityConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodSecurityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping idmappings in query parameter serialization


            self.security_opt.as_ref().map(|security_opt| {
                [
                    "security_opt".to_string(),
                    security_opt.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodSecurityConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodSecurityConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub idmappings: Vec<models::IdMappingOptions>,
            pub security_opt: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodSecurityConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "idmappings" => intermediate_rep.idmappings.push(<models::IdMappingOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "security_opt" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSecurityConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodSecurityConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodSecurityConfig {
            idmappings: intermediate_rep.idmappings.into_iter().next(),
            security_opt: intermediate_rep.security_opt.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodSecurityConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodSecurityConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodSecurityConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodSecurityConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodSecurityConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodSecurityConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodSecurityConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PodSpecGenerator describes options to create a pod



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodSpecGenerator {
/// Map of networks names to ids the container should join to. You can request additional settings for each network, you can set network aliases, static ips, static mac address  and the network interface name for this container on the specific network. If the map is empty and the bridge network mode is set the container will be joined to the default network.
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<std::collections::HashMap<String, models::PerNetworkOptions>>,

/// CgroupParent is the parent for the Cgroup that the pod will create. This pod cgroup will, in turn, be the default cgroup parent for all containers in the pod. Optional.
    #[serde(rename = "cgroup_parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

/// CNINetworks is a list of CNI networks to join the container to. If this list is empty, the default CNI network will be joined instead. If at least one entry is present, we will not join the default network (unless it is part of this list). Only available if NetNS is set to bridge. Optional. Deprecated: as of podman 4.0 use \"Networks\" instead.
    #[serde(rename = "cni_networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cni_networks: Option<Vec<String>>,

/// CPU period of the cpuset, determined by --cpus
    #[serde(rename = "cpu_period")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i32>,

/// CPU quota of the cpuset, determined by --cpus
    #[serde(rename = "cpu_quota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

/// DNSOption is a set of DNS options that will be used in the infra container's resolv.conf, which will, by default, be shared with all containers in the pod. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "dns_option")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_option: Option<Vec<String>>,

/// DNSSearch is a set of DNS search domains that will be used in the infra container's resolv.conf, which will, by default, be shared with all containers in the pod. If not provided, DNS search domains from the host's resolv.conf will be used. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "dns_search")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

/// DNSServer is a set of DNS servers that will be used in the infra container's resolv.conf, which will, by default, be shared with all containers in the pod. If not provided, the host's DNS servers will be used, unless the only server set is a localhost address. As the container cannot connect to the host's localhost, a default server will instead be set. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "dns_server")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_server: Option<Vec<String>>,

/// ExitPolicy determines the pod's exit and stop behaviour.
    #[serde(rename = "exit_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exit_policy: Option<String>,

/// HostAdd is a set of hosts that will be added to the infra container's etc/hosts that will, by default, be shared with all containers in the pod. Conflicts with NoInfra=true and NoManageHosts. Optional.
    #[serde(rename = "hostadd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostadd: Option<Vec<String>>,

/// Hostname is the pod's hostname. If not set, the name of the pod will be used (if a name was not provided here, the name auto-generated for the pod will be used). This will be used by the infra container and all containers in the pod as long as the UTS namespace is shared. Optional.
    #[serde(rename = "hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

    #[serde(rename = "idmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub idmappings: Option<models::IdMappingOptions>,

/// Image volumes bind-mount a container-image mount into the pod's infra container. Optional.
    #[serde(rename = "image_volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_volumes: Option<Vec<models::ImageVolume>>,

/// InfraCommand sets the command that will be used to start the infra container. If not set, the default set in the Libpod configuration file will be used. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "infra_command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_command: Option<Vec<String>>,

/// InfraConmonPidFile is a custom path to store the infra container's conmon PID.
    #[serde(rename = "infra_conmon_pid_file")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_conmon_pid_file: Option<String>,

/// InfraImage is the image that will be used for the infra container. If not set, the default set in the Libpod configuration file will be used. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "infra_image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_image: Option<String>,

/// InfraName is the name that will be used for the infra container. If not set, the default set in the Libpod configuration file will be used. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "infra_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub infra_name: Option<String>,

    #[serde(rename = "ipcns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipcns: Option<models::Namespace>,

/// Labels are key-value pairs that are used to add metadata to pods. Optional.
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// Mounts are mounts that will be added to the pod. These will supersede Image Volumes and VolumesFrom volumes where there are conflicts. Optional.
    #[serde(rename = "mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::Mount>>,

/// Name is the name of the pod. If not provided, a name will be generated when the pod is created. Optional.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "netns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub netns: Option<models::Namespace>,

/// NetworkOptions are additional options for each network Optional.
    #[serde(rename = "network_options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_options: Option<std::collections::HashMap<String, Vec<String>>>,

/// NoInfra tells the pod not to create an infra container. If this is done, many networking-related options will become unavailable. Conflicts with setting any options in PodNetworkConfig, and the InfraCommand and InfraImages in this struct. Optional.
    #[serde(rename = "no_infra")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_infra: Option<bool>,

/// NoManageHosts indicates that /etc/hosts should not be managed by the pod. Instead, each container will create a separate /etc/hosts as they would if not in a pod. Conflicts with HostAdd.
    #[serde(rename = "no_manage_hosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_manage_hosts: Option<bool>,

/// NoManageResolvConf indicates that /etc/resolv.conf should not be managed by the pod. Instead, each container will create and manage a separate resolv.conf as if they had not joined a pod. Conflicts with NoInfra=true and DNSServer, DNSSearch, DNSOption. Optional.
    #[serde(rename = "no_manage_resolv_conf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_manage_resolv_conf: Option<bool>,

/// Overlay volumes are named volumes that will be added to the pod. Optional.
    #[serde(rename = "overlay_volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub overlay_volumes: Option<Vec<models::OverlayVolume>>,

    #[serde(rename = "pidns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pidns: Option<models::Namespace>,

    #[serde(rename = "pod_create_command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_create_command: Option<Vec<String>>,

/// Devices contains user specified Devices to be added to the Pod
    #[serde(rename = "pod_devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_devices: Option<Vec<String>>,

/// PortMappings is a set of ports to map into the infra container. As, by default, containers share their network with the infra container, this will forward the ports to the entire pod. Only available if NetNS is set to Bridge, Slirp, or Pasta. Optional.
    #[serde(rename = "portmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub portmappings: Option<Vec<models::PortMapping>>,

    #[serde(rename = "resource_limits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_limits: Option<models::LinuxResources>,

/// RestartPolicy is the pod's restart policy - an action which will be taken when one or all the containers in the pod exits. If not given, the default policy will be set to Always, which restarts the containers in the pod when they exit indefinitely. Optional.
    #[serde(rename = "restart_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<String>,

/// RestartRetries is the number of attempts that will be made to restart the container. Only available when RestartPolicy is set to \"on-failure\". Optional.
    #[serde(rename = "restart_tries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_tries: Option<i32>,

    #[serde(rename = "security_opt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_opt: Option<Vec<String>>,

/// The ID of the pod's service container.
    #[serde(rename = "serviceContainerID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_container_id: Option<String>,

/// PodCreateCommand is the command used to create this pod. This will be shown in the output of Inspect() on the pod, and may also be used by some tools that wish to recreate the pod (e.g. `podman generate systemd --new`). Optional. ShareParent determines if all containers in the pod will share the pod's cgroup as the cgroup parent
    #[serde(rename = "share_parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub share_parent: Option<bool>,

/// SharedNamespaces instructs the pod to share a set of namespaces. Shared namespaces will be joined (by default) by every container which joins the pod. If not set and NoInfra is false, the pod will set a default set of namespaces to share. Conflicts with NoInfra=true. Optional.
    #[serde(rename = "shared_namespaces")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shared_namespaces: Option<Vec<String>>,

/// ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes. Conflicts with ShmSize if IpcNS is not private. Optional.
    #[serde(rename = "shm_size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size: Option<i64>,

/// ShmSizeSystemd is the size of systemd-specific tmpfs mounts specifically /run, /run/lock, /var/log/journal and /tmp. Optional
    #[serde(rename = "shm_size_systemd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size_systemd: Option<i64>,

/// Sysctl sets kernel parameters for the pod
    #[serde(rename = "sysctl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sysctl: Option<std::collections::HashMap<String, String>>,

/// ThrottleReadBpsDevice contains the rate at which the devices in the pod can be read from/accessed
    #[serde(rename = "throttleReadBpsDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_read_bps_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

    #[serde(rename = "userns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub userns: Option<models::Namespace>,

    #[serde(rename = "utsns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub utsns: Option<models::Namespace>,

/// Volumes are named volumes that will be added to the pod. These will supersede Image Volumes and VolumesFrom  volumes where there are conflicts. Optional.
    #[serde(rename = "volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<Vec<models::NamedVolume>>,

/// VolumesFrom is a set of containers whose volumes will be added to this pod. The name or ID of the container must be provided, and may optionally be followed by a : and then one or more comma-separated options. Valid options are 'ro', 'rw', and 'z'. Options will be used for all volumes sourced from the container.
    #[serde(rename = "volumes_from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

}


impl PodSpecGenerator {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodSpecGenerator {
        PodSpecGenerator {
            networks: None,
            cgroup_parent: None,
            cni_networks: None,
            cpu_period: None,
            cpu_quota: None,
            dns_option: None,
            dns_search: None,
            dns_server: None,
            exit_policy: None,
            hostadd: None,
            hostname: None,
            idmappings: None,
            image_volumes: None,
            infra_command: None,
            infra_conmon_pid_file: None,
            infra_image: None,
            infra_name: None,
            ipcns: None,
            labels: None,
            mounts: None,
            name: None,
            netns: None,
            network_options: None,
            no_infra: None,
            no_manage_hosts: None,
            no_manage_resolv_conf: None,
            overlay_volumes: None,
            pidns: None,
            pod_create_command: None,
            pod_devices: None,
            portmappings: None,
            resource_limits: None,
            restart_policy: None,
            restart_tries: None,
            security_opt: None,
            service_container_id: None,
            share_parent: None,
            shared_namespaces: None,
            shm_size: None,
            shm_size_systemd: None,
            sysctl: None,
            throttle_read_bps_device: None,
            userns: None,
            utsns: None,
            volumes: None,
            volumes_from: None,
        }
    }
}

/// Converts the PodSpecGenerator value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodSpecGenerator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Networks in query parameter serialization
            // Skipping Networks in query parameter serialization


            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "cgroup_parent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.cni_networks.as_ref().map(|cni_networks| {
                [
                    "cni_networks".to_string(),
                    cni_networks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "cpu_period".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "cpu_quota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.dns_option.as_ref().map(|dns_option| {
                [
                    "dns_option".to_string(),
                    dns_option.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "dns_search".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_server.as_ref().map(|dns_server| {
                [
                    "dns_server".to_string(),
                    dns_server.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.exit_policy.as_ref().map(|exit_policy| {
                [
                    "exit_policy".to_string(),
                    exit_policy.to_string(),
                ].join(",")
            }),


            self.hostadd.as_ref().map(|hostadd| {
                [
                    "hostadd".to_string(),
                    hostadd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),

            // Skipping idmappings in query parameter serialization

            // Skipping image_volumes in query parameter serialization


            self.infra_command.as_ref().map(|infra_command| {
                [
                    "infra_command".to_string(),
                    infra_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.infra_conmon_pid_file.as_ref().map(|infra_conmon_pid_file| {
                [
                    "infra_conmon_pid_file".to_string(),
                    infra_conmon_pid_file.to_string(),
                ].join(",")
            }),


            self.infra_image.as_ref().map(|infra_image| {
                [
                    "infra_image".to_string(),
                    infra_image.to_string(),
                ].join(",")
            }),


            self.infra_name.as_ref().map(|infra_name| {
                [
                    "infra_name".to_string(),
                    infra_name.to_string(),
                ].join(",")
            }),

            // Skipping ipcns in query parameter serialization

            // Skipping labels in query parameter serialization

            // Skipping mounts in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping netns in query parameter serialization

            // Skipping network_options in query parameter serialization
            // Skipping network_options in query parameter serialization


            self.no_infra.as_ref().map(|no_infra| {
                [
                    "no_infra".to_string(),
                    no_infra.to_string(),
                ].join(",")
            }),


            self.no_manage_hosts.as_ref().map(|no_manage_hosts| {
                [
                    "no_manage_hosts".to_string(),
                    no_manage_hosts.to_string(),
                ].join(",")
            }),


            self.no_manage_resolv_conf.as_ref().map(|no_manage_resolv_conf| {
                [
                    "no_manage_resolv_conf".to_string(),
                    no_manage_resolv_conf.to_string(),
                ].join(",")
            }),

            // Skipping overlay_volumes in query parameter serialization

            // Skipping pidns in query parameter serialization


            self.pod_create_command.as_ref().map(|pod_create_command| {
                [
                    "pod_create_command".to_string(),
                    pod_create_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.pod_devices.as_ref().map(|pod_devices| {
                [
                    "pod_devices".to_string(),
                    pod_devices.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping portmappings in query parameter serialization

            // Skipping resource_limits in query parameter serialization


            self.restart_policy.as_ref().map(|restart_policy| {
                [
                    "restart_policy".to_string(),
                    restart_policy.to_string(),
                ].join(",")
            }),


            self.restart_tries.as_ref().map(|restart_tries| {
                [
                    "restart_tries".to_string(),
                    restart_tries.to_string(),
                ].join(",")
            }),


            self.security_opt.as_ref().map(|security_opt| {
                [
                    "security_opt".to_string(),
                    security_opt.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.service_container_id.as_ref().map(|service_container_id| {
                [
                    "serviceContainerID".to_string(),
                    service_container_id.to_string(),
                ].join(",")
            }),


            self.share_parent.as_ref().map(|share_parent| {
                [
                    "share_parent".to_string(),
                    share_parent.to_string(),
                ].join(",")
            }),


            self.shared_namespaces.as_ref().map(|shared_namespaces| {
                [
                    "shared_namespaces".to_string(),
                    shared_namespaces.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.shm_size.as_ref().map(|shm_size| {
                [
                    "shm_size".to_string(),
                    shm_size.to_string(),
                ].join(",")
            }),


            self.shm_size_systemd.as_ref().map(|shm_size_systemd| {
                [
                    "shm_size_systemd".to_string(),
                    shm_size_systemd.to_string(),
                ].join(",")
            }),

            // Skipping sysctl in query parameter serialization

            // Skipping throttleReadBpsDevice in query parameter serialization
            // Skipping throttleReadBpsDevice in query parameter serialization

            // Skipping userns in query parameter serialization

            // Skipping utsns in query parameter serialization

            // Skipping volumes in query parameter serialization


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "volumes_from".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodSpecGenerator value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodSpecGenerator {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub networks: Vec<std::collections::HashMap<String, models::PerNetworkOptions>>,
            pub cgroup_parent: Vec<String>,
            pub cni_networks: Vec<Vec<String>>,
            pub cpu_period: Vec<i32>,
            pub cpu_quota: Vec<i64>,
            pub dns_option: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub dns_server: Vec<Vec<String>>,
            pub exit_policy: Vec<String>,
            pub hostadd: Vec<Vec<String>>,
            pub hostname: Vec<String>,
            pub idmappings: Vec<models::IdMappingOptions>,
            pub image_volumes: Vec<Vec<models::ImageVolume>>,
            pub infra_command: Vec<Vec<String>>,
            pub infra_conmon_pid_file: Vec<String>,
            pub infra_image: Vec<String>,
            pub infra_name: Vec<String>,
            pub ipcns: Vec<models::Namespace>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub mounts: Vec<Vec<models::Mount>>,
            pub name: Vec<String>,
            pub netns: Vec<models::Namespace>,
            pub network_options: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub no_infra: Vec<bool>,
            pub no_manage_hosts: Vec<bool>,
            pub no_manage_resolv_conf: Vec<bool>,
            pub overlay_volumes: Vec<Vec<models::OverlayVolume>>,
            pub pidns: Vec<models::Namespace>,
            pub pod_create_command: Vec<Vec<String>>,
            pub pod_devices: Vec<Vec<String>>,
            pub portmappings: Vec<Vec<models::PortMapping>>,
            pub resource_limits: Vec<models::LinuxResources>,
            pub restart_policy: Vec<String>,
            pub restart_tries: Vec<i32>,
            pub security_opt: Vec<Vec<String>>,
            pub service_container_id: Vec<String>,
            pub share_parent: Vec<bool>,
            pub shared_namespaces: Vec<Vec<String>>,
            pub shm_size: Vec<i64>,
            pub shm_size_systemd: Vec<i64>,
            pub sysctl: Vec<std::collections::HashMap<String, String>>,
            pub throttle_read_bps_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub userns: Vec<models::Namespace>,
            pub utsns: Vec<models::Namespace>,
            pub volumes: Vec<Vec<models::NamedVolume>>,
            pub volumes_from: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodSpecGenerator".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cgroup_parent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "cni_networks" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cpu_period" => intermediate_rep.cpu_period.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cpu_quota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "dns_option" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    "dns_search" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    "dns_server" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "exit_policy" => intermediate_rep.exit_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hostadd" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "idmappings" => intermediate_rep.idmappings.push(<models::IdMappingOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "image_volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    "infra_command" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "infra_conmon_pid_file" => intermediate_rep.infra_conmon_pid_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "infra_image" => intermediate_rep.infra_image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "infra_name" => intermediate_rep.infra_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipcns" => intermediate_rep.ipcns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    "mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "netns" => intermediate_rep.netns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "network_options" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "no_infra" => intermediate_rep.no_infra.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "no_manage_hosts" => intermediate_rep.no_manage_hosts.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "no_manage_resolv_conf" => intermediate_rep.no_manage_resolv_conf.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "overlay_volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pidns" => intermediate_rep.pidns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pod_create_command" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    "pod_devices" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    "portmappings" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "resource_limits" => intermediate_rep.resource_limits.push(<models::LinuxResources as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "restart_policy" => intermediate_rep.restart_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "restart_tries" => intermediate_rep.restart_tries.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "security_opt" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "serviceContainerID" => intermediate_rep.service_container_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "share_parent" => intermediate_rep.share_parent.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "shared_namespaces" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shm_size" => intermediate_rep.shm_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shm_size_systemd" => intermediate_rep.shm_size_systemd.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "sysctl" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    "throttleReadBpsDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "userns" => intermediate_rep.userns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "utsns" => intermediate_rep.utsns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    "volumes_from" => return std::result::Result::Err("Parsing a container in this style is not supported in PodSpecGenerator".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodSpecGenerator".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodSpecGenerator {
            networks: intermediate_rep.networks.into_iter().next(),
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cni_networks: intermediate_rep.cni_networks.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            dns_option: intermediate_rep.dns_option.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            dns_server: intermediate_rep.dns_server.into_iter().next(),
            exit_policy: intermediate_rep.exit_policy.into_iter().next(),
            hostadd: intermediate_rep.hostadd.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            idmappings: intermediate_rep.idmappings.into_iter().next(),
            image_volumes: intermediate_rep.image_volumes.into_iter().next(),
            infra_command: intermediate_rep.infra_command.into_iter().next(),
            infra_conmon_pid_file: intermediate_rep.infra_conmon_pid_file.into_iter().next(),
            infra_image: intermediate_rep.infra_image.into_iter().next(),
            infra_name: intermediate_rep.infra_name.into_iter().next(),
            ipcns: intermediate_rep.ipcns.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            netns: intermediate_rep.netns.into_iter().next(),
            network_options: intermediate_rep.network_options.into_iter().next(),
            no_infra: intermediate_rep.no_infra.into_iter().next(),
            no_manage_hosts: intermediate_rep.no_manage_hosts.into_iter().next(),
            no_manage_resolv_conf: intermediate_rep.no_manage_resolv_conf.into_iter().next(),
            overlay_volumes: intermediate_rep.overlay_volumes.into_iter().next(),
            pidns: intermediate_rep.pidns.into_iter().next(),
            pod_create_command: intermediate_rep.pod_create_command.into_iter().next(),
            pod_devices: intermediate_rep.pod_devices.into_iter().next(),
            portmappings: intermediate_rep.portmappings.into_iter().next(),
            resource_limits: intermediate_rep.resource_limits.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            restart_tries: intermediate_rep.restart_tries.into_iter().next(),
            security_opt: intermediate_rep.security_opt.into_iter().next(),
            service_container_id: intermediate_rep.service_container_id.into_iter().next(),
            share_parent: intermediate_rep.share_parent.into_iter().next(),
            shared_namespaces: intermediate_rep.shared_namespaces.into_iter().next(),
            shm_size: intermediate_rep.shm_size.into_iter().next(),
            shm_size_systemd: intermediate_rep.shm_size_systemd.into_iter().next(),
            sysctl: intermediate_rep.sysctl.into_iter().next(),
            throttle_read_bps_device: intermediate_rep.throttle_read_bps_device.into_iter().next(),
            userns: intermediate_rep.userns.into_iter().next(),
            utsns: intermediate_rep.utsns.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodSpecGenerator> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodSpecGenerator>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodSpecGenerator>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodSpecGenerator - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodSpecGenerator> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodSpecGenerator as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodSpecGenerator - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate, Default)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodStartReport {
    #[serde(rename = "Errs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errs: Option<Vec<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "RawInput")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_input: Option<String>,

}


impl PodStartReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodStartReport {
        PodStartReport {
            errs: None,
            id: None,
            raw_input: None,
        }
    }
}

/// Converts the PodStartReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodStartReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.errs.as_ref().map(|errs| {
                [
                    "Errs".to_string(),
                    errs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.raw_input.as_ref().map(|raw_input| {
                [
                    "RawInput".to_string(),
                    raw_input.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodStartReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodStartReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errs: Vec<Vec<String>>,
            pub id: Vec<String>,
            pub raw_input: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodStartReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Errs" => return std::result::Result::Err("Parsing a container in this style is not supported in PodStartReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RawInput" => intermediate_rep.raw_input.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodStartReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodStartReport {
            errs: intermediate_rep.errs.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            raw_input: intermediate_rep.raw_input.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodStartReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodStartReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodStartReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodStartReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodStartReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodStartReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodStartReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodStatsReport {
/// Humanized disk usage read + write
    #[serde(rename = "BlockIO")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_io: Option<String>,

/// Container ID
    #[serde(rename = "CID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cid: Option<String>,

/// Percentage of CPU utilized by pod
    #[serde(rename = "CPU")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu: Option<String>,

/// Percentage of Memory utilized by pod
    #[serde(rename = "Mem")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem: Option<String>,

/// Humanized Memory usage and maximum
    #[serde(rename = "MemUsage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem_usage: Option<String>,

/// Memory usage and maximum in bytes
    #[serde(rename = "MemUsageBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mem_usage_bytes: Option<String>,

/// Pod Name
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Network usage inbound + outbound
    #[serde(rename = "NetIO")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub net_io: Option<String>,

/// Container PID
    #[serde(rename = "PIDS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids: Option<String>,

/// Pod ID
    #[serde(rename = "Pod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod: Option<String>,

}


impl PodStatsReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodStatsReport {
        PodStatsReport {
            block_io: None,
            cid: None,
            cpu: None,
            mem: None,
            mem_usage: None,
            mem_usage_bytes: None,
            name: None,
            net_io: None,
            pids: None,
            pod: None,
        }
    }
}

/// Converts the PodStatsReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodStatsReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.block_io.as_ref().map(|block_io| {
                [
                    "BlockIO".to_string(),
                    block_io.to_string(),
                ].join(",")
            }),


            self.cid.as_ref().map(|cid| {
                [
                    "CID".to_string(),
                    cid.to_string(),
                ].join(",")
            }),


            self.cpu.as_ref().map(|cpu| {
                [
                    "CPU".to_string(),
                    cpu.to_string(),
                ].join(",")
            }),


            self.mem.as_ref().map(|mem| {
                [
                    "Mem".to_string(),
                    mem.to_string(),
                ].join(",")
            }),


            self.mem_usage.as_ref().map(|mem_usage| {
                [
                    "MemUsage".to_string(),
                    mem_usage.to_string(),
                ].join(",")
            }),


            self.mem_usage_bytes.as_ref().map(|mem_usage_bytes| {
                [
                    "MemUsageBytes".to_string(),
                    mem_usage_bytes.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.net_io.as_ref().map(|net_io| {
                [
                    "NetIO".to_string(),
                    net_io.to_string(),
                ].join(",")
            }),


            self.pids.as_ref().map(|pids| {
                [
                    "PIDS".to_string(),
                    pids.to_string(),
                ].join(",")
            }),


            self.pod.as_ref().map(|pod| {
                [
                    "Pod".to_string(),
                    pod.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodStatsReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodStatsReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub block_io: Vec<String>,
            pub cid: Vec<String>,
            pub cpu: Vec<String>,
            pub mem: Vec<String>,
            pub mem_usage: Vec<String>,
            pub mem_usage_bytes: Vec<String>,
            pub name: Vec<String>,
            pub net_io: Vec<String>,
            pub pids: Vec<String>,
            pub pod: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodStatsReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "BlockIO" => intermediate_rep.block_io.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CID" => intermediate_rep.cid.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CPU" => intermediate_rep.cpu.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Mem" => intermediate_rep.mem.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemUsage" => intermediate_rep.mem_usage.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemUsageBytes" => intermediate_rep.mem_usage_bytes.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NetIO" => intermediate_rep.net_io.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PIDS" => intermediate_rep.pids.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Pod" => intermediate_rep.pod.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodStatsReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodStatsReport {
            block_io: intermediate_rep.block_io.into_iter().next(),
            cid: intermediate_rep.cid.into_iter().next(),
            cpu: intermediate_rep.cpu.into_iter().next(),
            mem: intermediate_rep.mem.into_iter().next(),
            mem_usage: intermediate_rep.mem_usage.into_iter().next(),
            mem_usage_bytes: intermediate_rep.mem_usage_bytes.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            net_io: intermediate_rep.net_io.into_iter().next(),
            pids: intermediate_rep.pids.into_iter().next(),
            pod: intermediate_rep.pod.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodStatsReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodStatsReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodStatsReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodStatsReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodStatsReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodStatsReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodStatsReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate, Default)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodStopReport {
    #[serde(rename = "Errs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errs: Option<Vec<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "RawInput")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_input: Option<String>,

}


impl PodStopReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodStopReport {
        PodStopReport {
            errs: None,
            id: None,
            raw_input: None,
        }
    }
}

/// Converts the PodStopReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodStopReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.errs.as_ref().map(|errs| {
                [
                    "Errs".to_string(),
                    errs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.raw_input.as_ref().map(|raw_input| {
                [
                    "RawInput".to_string(),
                    raw_input.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodStopReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodStopReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errs: Vec<Vec<String>>,
            pub id: Vec<String>,
            pub raw_input: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodStopReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Errs" => return std::result::Result::Err("Parsing a container in this style is not supported in PodStopReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RawInput" => intermediate_rep.raw_input.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodStopReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodStopReport {
            errs: intermediate_rep.errs.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            raw_input: intermediate_rep.raw_input.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodStopReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodStopReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodStopReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodStopReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodStopReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodStopReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodStopReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodStorageConfig {
/// Image volumes bind-mount a container-image mount into the pod's infra container. Optional.
    #[serde(rename = "image_volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_volumes: Option<Vec<models::ImageVolume>>,

/// Mounts are mounts that will be added to the pod. These will supersede Image Volumes and VolumesFrom volumes where there are conflicts. Optional.
    #[serde(rename = "mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::Mount>>,

/// Overlay volumes are named volumes that will be added to the pod. Optional.
    #[serde(rename = "overlay_volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub overlay_volumes: Option<Vec<models::OverlayVolume>>,

/// ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes. Conflicts with ShmSize if IpcNS is not private. Optional.
    #[serde(rename = "shm_size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size: Option<i64>,

/// ShmSizeSystemd is the size of systemd-specific tmpfs mounts specifically /run, /run/lock, /var/log/journal and /tmp. Optional
    #[serde(rename = "shm_size_systemd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size_systemd: Option<i64>,

/// Volumes are named volumes that will be added to the pod. These will supersede Image Volumes and VolumesFrom  volumes where there are conflicts. Optional.
    #[serde(rename = "volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<Vec<models::NamedVolume>>,

/// VolumesFrom is a set of containers whose volumes will be added to this pod. The name or ID of the container must be provided, and may optionally be followed by a : and then one or more comma-separated options. Valid options are 'ro', 'rw', and 'z'. Options will be used for all volumes sourced from the container.
    #[serde(rename = "volumes_from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

}


impl PodStorageConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodStorageConfig {
        PodStorageConfig {
            image_volumes: None,
            mounts: None,
            overlay_volumes: None,
            shm_size: None,
            shm_size_systemd: None,
            volumes: None,
            volumes_from: None,
        }
    }
}

/// Converts the PodStorageConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodStorageConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping image_volumes in query parameter serialization

            // Skipping mounts in query parameter serialization

            // Skipping overlay_volumes in query parameter serialization


            self.shm_size.as_ref().map(|shm_size| {
                [
                    "shm_size".to_string(),
                    shm_size.to_string(),
                ].join(",")
            }),


            self.shm_size_systemd.as_ref().map(|shm_size_systemd| {
                [
                    "shm_size_systemd".to_string(),
                    shm_size_systemd.to_string(),
                ].join(",")
            }),

            // Skipping volumes in query parameter serialization


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "volumes_from".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodStorageConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodStorageConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub image_volumes: Vec<Vec<models::ImageVolume>>,
            pub mounts: Vec<Vec<models::Mount>>,
            pub overlay_volumes: Vec<Vec<models::OverlayVolume>>,
            pub shm_size: Vec<i64>,
            pub shm_size_systemd: Vec<i64>,
            pub volumes: Vec<Vec<models::NamedVolume>>,
            pub volumes_from: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodStorageConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "image_volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in PodStorageConfig".to_string()),
                    "mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in PodStorageConfig".to_string()),
                    "overlay_volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in PodStorageConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shm_size" => intermediate_rep.shm_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shm_size_systemd" => intermediate_rep.shm_size_systemd.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in PodStorageConfig".to_string()),
                    "volumes_from" => return std::result::Result::Err("Parsing a container in this style is not supported in PodStorageConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodStorageConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodStorageConfig {
            image_volumes: intermediate_rep.image_volumes.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            overlay_volumes: intermediate_rep.overlay_volumes.into_iter().next(),
            shm_size: intermediate_rep.shm_size.into_iter().next(),
            shm_size_systemd: intermediate_rep.shm_size_systemd.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodStorageConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodStorageConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodStorageConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodStorageConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodStorageConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodStorageConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodStorageConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodTopOkBody {
/// Each process running in the container, where each is process is an array of values corresponding to the titles.
    #[serde(rename = "Processes")]
    pub processes: Vec<Vec<String>>,

/// The ps column titles
    #[serde(rename = "Titles")]
    pub titles: Vec<String>,

}


impl PodTopOkBody {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(processes: Vec<Vec<String>>, titles: Vec<String>, ) -> PodTopOkBody {
        PodTopOkBody {
            processes,
            titles,
        }
    }
}

/// Converts the PodTopOkBody value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodTopOkBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Processes in query parameter serialization


            Some("Titles".to_string()),
            Some(self.titles.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodTopOkBody value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodTopOkBody {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub processes: Vec<Vec<Vec<String>>>,
            pub titles: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodTopOkBody".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Processes" => return std::result::Result::Err("Parsing a container in this style is not supported in PodTopOkBody".to_string()),
                    "Titles" => return std::result::Result::Err("Parsing a container in this style is not supported in PodTopOkBody".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodTopOkBody".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodTopOkBody {
            processes: intermediate_rep.processes.into_iter().next().ok_or_else(|| "Processes missing in PodTopOkBody".to_string())?,
            titles: intermediate_rep.titles.into_iter().next().ok_or_else(|| "Titles missing in PodTopOkBody".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodTopOkBody> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodTopOkBody>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodTopOkBody>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodTopOkBody - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodTopOkBody> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodTopOkBody as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodTopOkBody - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PodUnpauseReport {
    #[serde(rename = "Errs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errs: Option<Vec<String>>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl PodUnpauseReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PodUnpauseReport {
        PodUnpauseReport {
            errs: None,
            id: None,
        }
    }
}

/// Converts the PodUnpauseReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PodUnpauseReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.errs.as_ref().map(|errs| {
                [
                    "Errs".to_string(),
                    errs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PodUnpauseReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PodUnpauseReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub errs: Vec<Vec<String>>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PodUnpauseReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Errs" => return std::result::Result::Err("Parsing a container in this style is not supported in PodUnpauseReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PodUnpauseReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PodUnpauseReport {
            errs: intermediate_rep.errs.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PodUnpauseReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PodUnpauseReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PodUnpauseReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PodUnpauseReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PodUnpauseReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PodUnpauseReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PodUnpauseReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Port An open port on a container



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Port {
/// Host IP address that the container's port is mapped to
    #[serde(rename = "IP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip: Option<String>,

/// Port on the container
    #[serde(rename = "PrivatePort")]
    pub private_port: i32,

/// Port exposed on the host
    #[serde(rename = "PublicPort")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_port: Option<i32>,

/// type
    #[serde(rename = "Type")]
    pub r#type: String,

}


impl Port {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(private_port: i32, r#type: String, ) -> Port {
        Port {
            ip: None,
            private_port,
            public_port: None,
            r#type,
        }
    }
}

/// Converts the Port value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Port {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ip.as_ref().map(|ip| {
                [
                    "IP".to_string(),
                    ip.to_string(),
                ].join(",")
            }),


            Some("PrivatePort".to_string()),
            Some(self.private_port.to_string()),


            self.public_port.as_ref().map(|public_port| {
                [
                    "PublicPort".to_string(),
                    public_port.to_string(),
                ].join(",")
            }),


            Some("Type".to_string()),
            Some(self.r#type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Port value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Port {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ip: Vec<String>,
            pub private_port: Vec<i32>,
            pub public_port: Vec<i32>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Port".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "IP" => intermediate_rep.ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PrivatePort" => intermediate_rep.private_port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PublicPort" => intermediate_rep.public_port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Port".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Port {
            ip: intermediate_rep.ip.into_iter().next(),
            private_port: intermediate_rep.private_port.into_iter().next().ok_or_else(|| "PrivatePort missing in Port".to_string())?,
            public_port: intermediate_rep.public_port.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "Type missing in Port".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Port> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Port>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Port>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Port - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Port> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Port as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Port - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PortBinding represents a binding between a Host IP address and a Host Port



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PortBinding {
/// HostIP is the host IP Address
    #[serde(rename = "HostIp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_ip: Option<String>,

/// HostPort is the host port number
    #[serde(rename = "HostPort")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_port: Option<String>,

}


impl PortBinding {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PortBinding {
        PortBinding {
            host_ip: None,
            host_port: None,
        }
    }
}

/// Converts the PortBinding value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PortBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.host_ip.as_ref().map(|host_ip| {
                [
                    "HostIp".to_string(),
                    host_ip.to_string(),
                ].join(",")
            }),


            self.host_port.as_ref().map(|host_port| {
                [
                    "HostPort".to_string(),
                    host_port.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PortBinding value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PortBinding {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub host_ip: Vec<String>,
            pub host_port: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PortBinding".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "HostIp" => intermediate_rep.host_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "HostPort" => intermediate_rep.host_port.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PortBinding".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PortBinding {
            host_ip: intermediate_rep.host_ip.into_iter().next(),
            host_port: intermediate_rep.host_port.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PortBinding> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PortBinding>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PortBinding>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PortBinding - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PortBinding> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PortBinding as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PortBinding - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PortMapping {
/// ContainerPort is the port number that will be exposed from the container. Mandatory.
    #[serde(rename = "container_port")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_port: Option<i32>,

/// HostIP is the IP that we will bind to on the host. If unset, assumed to be 0.0.0.0 (all interfaces).
    #[serde(rename = "host_ip")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_ip: Option<String>,

/// HostPort is the port number that will be forwarded from the host into the container. If omitted, a random port on the host (guaranteed to be over 1024) will be assigned.
    #[serde(rename = "host_port")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_port: Option<i32>,

/// Protocol is the protocol forward. Must be either \"tcp\", \"udp\", and \"sctp\", or some combination of these separated by commas. If unset, assumed to be TCP.
    #[serde(rename = "protocol")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub protocol: Option<String>,

/// Range is the number of ports that will be forwarded, starting at HostPort and ContainerPort and counting up. This is 1-indexed, so 1 is assumed to be a single port (only the Hostport:Containerport mapping will be added), 2 is two ports (both Hostport:Containerport and Hostport+1:Containerport+1), etc. If unset, assumed to be 1 (a single port). Both hostport + range and containerport + range must be less than 65536.
    #[serde(rename = "range")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub range: Option<i32>,

}


impl PortMapping {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PortMapping {
        PortMapping {
            container_port: None,
            host_ip: None,
            host_port: None,
            protocol: None,
            range: None,
        }
    }
}

/// Converts the PortMapping value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PortMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.container_port.as_ref().map(|container_port| {
                [
                    "container_port".to_string(),
                    container_port.to_string(),
                ].join(",")
            }),


            self.host_ip.as_ref().map(|host_ip| {
                [
                    "host_ip".to_string(),
                    host_ip.to_string(),
                ].join(",")
            }),


            self.host_port.as_ref().map(|host_port| {
                [
                    "host_port".to_string(),
                    host_port.to_string(),
                ].join(",")
            }),


            self.protocol.as_ref().map(|protocol| {
                [
                    "protocol".to_string(),
                    protocol.to_string(),
                ].join(",")
            }),


            self.range.as_ref().map(|range| {
                [
                    "range".to_string(),
                    range.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PortMapping value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PortMapping {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container_port: Vec<i32>,
            pub host_ip: Vec<String>,
            pub host_port: Vec<i32>,
            pub protocol: Vec<String>,
            pub range: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PortMapping".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "container_port" => intermediate_rep.container_port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "host_ip" => intermediate_rep.host_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "host_port" => intermediate_rep.host_port.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "protocol" => intermediate_rep.protocol.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "range" => intermediate_rep.range.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PortMapping".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PortMapping {
            container_port: intermediate_rep.container_port.into_iter().next(),
            host_ip: intermediate_rep.host_ip.into_iter().next(),
            host_port: intermediate_rep.host_port.into_iter().next(),
            protocol: intermediate_rep.protocol.into_iter().next(),
            range: intermediate_rep.range.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PortMapping> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PortMapping>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PortMapping>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PortMapping - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PortMapping> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PortMapping as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PortMapping - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// POSIXRlimit type and restrictions



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PosixRlimit {
/// Hard is the hard limit for the specified type
    #[serde(rename = "hard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hard: Option<i32>,

/// Soft is the soft limit for the specified type
    #[serde(rename = "soft")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub soft: Option<i32>,

/// Type of the rlimit to set
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl PosixRlimit {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PosixRlimit {
        PosixRlimit {
            hard: None,
            soft: None,
            r#type: None,
        }
    }
}

/// Converts the PosixRlimit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PosixRlimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.hard.as_ref().map(|hard| {
                [
                    "hard".to_string(),
                    hard.to_string(),
                ].join(",")
            }),


            self.soft.as_ref().map(|soft| {
                [
                    "soft".to_string(),
                    soft.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PosixRlimit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PosixRlimit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hard: Vec<i32>,
            pub soft: Vec<i32>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PosixRlimit".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hard" => intermediate_rep.hard.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "soft" => intermediate_rep.soft.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PosixRlimit".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PosixRlimit {
            hard: intermediate_rep.hard.into_iter().next(),
            soft: intermediate_rep.soft.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PosixRlimit> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PosixRlimit>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PosixRlimit>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PosixRlimit - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PosixRlimit> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PosixRlimit as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PosixRlimit - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Propagation(String);

impl validator::Validate for Propagation {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Propagation {
    fn from(x: String) -> Self {
        Propagation(x)
    }
}

impl std::fmt::Display for Propagation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for Propagation {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Propagation(x.to_string()))
    }
}

impl std::convert::From<Propagation> for String {
    fn from(x: Propagation) -> Self {
        x.0
    }
}

impl std::ops::Deref for Propagation {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Propagation {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PruneReport {
    #[serde(rename = "Err")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub err: Option<String>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i32>,

}


impl PruneReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PruneReport {
        PruneReport {
            err: None,
            id: None,
            size: None,
        }
    }
}

/// Converts the PruneReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PruneReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.err.as_ref().map(|err| {
                [
                    "Err".to_string(),
                    err.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PruneReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PruneReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub err: Vec<String>,
            pub id: Vec<String>,
            pub size: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PruneReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Err" => intermediate_rep.err.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PruneReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PruneReport {
            err: intermediate_rep.err.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PruneReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PruneReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PruneReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PruneReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PruneReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PruneReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PruneReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// PublishState represents the state of a Volume as it pertains to its use on a particular Node.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PublishState(String);

impl validator::Validate for PublishState {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for PublishState {
    fn from(x: String) -> Self {
        PublishState(x)
    }
}

impl std::fmt::Display for PublishState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for PublishState {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(PublishState(x.to_string()))
    }
}

impl std::convert::From<PublishState> for String {
    fn from(x: PublishState) -> Self {
        x.0
    }
}

impl std::ops::Deref for PublishState {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for PublishState {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// PublishStatus represents the status of the volume as published to an individual node



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PublishStatus {
/// NodeID is the ID of the swarm node this Volume is published to.
    #[serde(rename = "NodeID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,

/// PublishContext is the PublishContext returned by the CSI plugin when a volume is published.
    #[serde(rename = "PublishContext")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_context: Option<std::collections::HashMap<String, String>>,

/// PublishState represents the state of a Volume as it pertains to its use on a particular Node.
    #[serde(rename = "State")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,

}


impl PublishStatus {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PublishStatus {
        PublishStatus {
            node_id: None,
            publish_context: None,
            state: None,
        }
    }
}

/// Converts the PublishStatus value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PublishStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.node_id.as_ref().map(|node_id| {
                [
                    "NodeID".to_string(),
                    node_id.to_string(),
                ].join(",")
            }),

            // Skipping PublishContext in query parameter serialization


            self.state.as_ref().map(|state| {
                [
                    "State".to_string(),
                    state.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PublishStatus value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PublishStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub node_id: Vec<String>,
            pub publish_context: Vec<std::collections::HashMap<String, String>>,
            pub state: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PublishStatus".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "NodeID" => intermediate_rep.node_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "PublishContext" => return std::result::Result::Err("Parsing a container in this style is not supported in PublishStatus".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "State" => intermediate_rep.state.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PublishStatus".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PublishStatus {
            node_id: intermediate_rep.node_id.into_iter().next(),
            publish_context: intermediate_rep.publish_context.into_iter().next(),
            state: intermediate_rep.state.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PublishStatus> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PublishStatus>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PublishStatus>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PublishStatus - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PublishStatus> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PublishStatus as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PublishStatus - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// RemoteSocket describes information about the API socket



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RemoteSocket {
    #[serde(rename = "exists")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub exists: Option<bool>,

    #[serde(rename = "path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

}


impl RemoteSocket {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RemoteSocket {
        RemoteSocket {
            exists: None,
            path: None,
        }
    }
}

/// Converts the RemoteSocket value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RemoteSocket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.exists.as_ref().map(|exists| {
                [
                    "exists".to_string(),
                    exists.to_string(),
                ].join(",")
            }),


            self.path.as_ref().map(|path| {
                [
                    "path".to_string(),
                    path.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RemoteSocket value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RemoteSocket {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub exists: Vec<bool>,
            pub path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RemoteSocket".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "exists" => intermediate_rep.exists.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RemoteSocket".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RemoteSocket {
            exists: intermediate_rep.exists.into_iter().next(),
            path: intermediate_rep.path.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RemoteSocket> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RemoteSocket>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RemoteSocket>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RemoteSocket - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RemoteSocket> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RemoteSocket as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RemoteSocket - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Resources contains container's resources (cgroups config, ulimits...)



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Resources {
    #[serde(rename = "BlkioDeviceReadBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceReadIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioWeight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight: Option<i32>,

    #[serde(rename = "BlkioWeightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight_device: Option<Vec<models::WeightDevice>>,

/// Applicable to UNIX platforms
    #[serde(rename = "CgroupParent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

/// Applicable to Windows
    #[serde(rename = "CpuCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_count: Option<i64>,

    #[serde(rename = "CpuPercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_percent: Option<i64>,

    #[serde(rename = "CpuPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i64>,

    #[serde(rename = "CpuQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

    #[serde(rename = "CpuRealtimePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_period: Option<i64>,

    #[serde(rename = "CpuRealtimeRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_runtime: Option<i64>,

/// Applicable to all platforms
    #[serde(rename = "CpuShares")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_shares: Option<i64>,

    #[serde(rename = "CpusetCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

    #[serde(rename = "CpusetMems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_mems: Option<String>,

    #[serde(rename = "DeviceCgroupRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_cgroup_rules: Option<Vec<String>>,

    #[serde(rename = "DeviceRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_requests: Option<Vec<models::DeviceRequest>>,

    #[serde(rename = "Devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::DeviceMapping>>,

    #[serde(rename = "IOMaximumBandwidth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_bandwidth: Option<i32>,

    #[serde(rename = "IOMaximumIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_i_ops: Option<i32>,

/// KernelMemory specifies the kernel memory limit (in bytes) for the container. Deprecated: kernel 5.4 deprecated kmem.limit_in_bytes.
    #[serde(rename = "KernelMemory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory: Option<i64>,

    #[serde(rename = "KernelMemoryTCP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory_tcp: Option<i64>,

    #[serde(rename = "Memory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory: Option<i64>,

    #[serde(rename = "MemoryReservation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_reservation: Option<i64>,

    #[serde(rename = "MemorySwap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swap: Option<i64>,

    #[serde(rename = "MemorySwappiness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swappiness: Option<i64>,

    #[serde(rename = "NanoCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nano_cpus: Option<i64>,

    #[serde(rename = "OomKillDisable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_kill_disable: Option<bool>,

    #[serde(rename = "PidsLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids_limit: Option<i64>,

    #[serde(rename = "Ulimits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ulimits: Option<Vec<models::Ulimit>>,

}


impl Resources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Resources {
        Resources {
            blkio_device_read_bps: None,
            blkio_device_read_i_ops: None,
            blkio_device_write_bps: None,
            blkio_device_write_i_ops: None,
            blkio_weight: None,
            blkio_weight_device: None,
            cgroup_parent: None,
            cpu_count: None,
            cpu_percent: None,
            cpu_period: None,
            cpu_quota: None,
            cpu_realtime_period: None,
            cpu_realtime_runtime: None,
            cpu_shares: None,
            cpuset_cpus: None,
            cpuset_mems: None,
            device_cgroup_rules: None,
            device_requests: None,
            devices: None,
            io_maximum_bandwidth: None,
            io_maximum_i_ops: None,
            kernel_memory: None,
            kernel_memory_tcp: None,
            memory: None,
            memory_reservation: None,
            memory_swap: None,
            memory_swappiness: None,
            nano_cpus: None,
            oom_kill_disable: None,
            pids_limit: None,
            ulimits: None,
        }
    }
}

/// Converts the Resources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Resources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping BlkioDeviceReadBps in query parameter serialization

            // Skipping BlkioDeviceReadIOps in query parameter serialization

            // Skipping BlkioDeviceWriteBps in query parameter serialization

            // Skipping BlkioDeviceWriteIOps in query parameter serialization


            self.blkio_weight.as_ref().map(|blkio_weight| {
                [
                    "BlkioWeight".to_string(),
                    blkio_weight.to_string(),
                ].join(",")
            }),

            // Skipping BlkioWeightDevice in query parameter serialization


            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "CgroupParent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.cpu_count.as_ref().map(|cpu_count| {
                [
                    "CpuCount".to_string(),
                    cpu_count.to_string(),
                ].join(",")
            }),


            self.cpu_percent.as_ref().map(|cpu_percent| {
                [
                    "CpuPercent".to_string(),
                    cpu_percent.to_string(),
                ].join(",")
            }),


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "CpuPeriod".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "CpuQuota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_period.as_ref().map(|cpu_realtime_period| {
                [
                    "CpuRealtimePeriod".to_string(),
                    cpu_realtime_period.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_runtime.as_ref().map(|cpu_realtime_runtime| {
                [
                    "CpuRealtimeRuntime".to_string(),
                    cpu_realtime_runtime.to_string(),
                ].join(",")
            }),


            self.cpu_shares.as_ref().map(|cpu_shares| {
                [
                    "CpuShares".to_string(),
                    cpu_shares.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "CpusetCpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.cpuset_mems.as_ref().map(|cpuset_mems| {
                [
                    "CpusetMems".to_string(),
                    cpuset_mems.to_string(),
                ].join(",")
            }),


            self.device_cgroup_rules.as_ref().map(|device_cgroup_rules| {
                [
                    "DeviceCgroupRules".to_string(),
                    device_cgroup_rules.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping DeviceRequests in query parameter serialization

            // Skipping Devices in query parameter serialization


            self.io_maximum_bandwidth.as_ref().map(|io_maximum_bandwidth| {
                [
                    "IOMaximumBandwidth".to_string(),
                    io_maximum_bandwidth.to_string(),
                ].join(",")
            }),


            self.io_maximum_i_ops.as_ref().map(|io_maximum_i_ops| {
                [
                    "IOMaximumIOps".to_string(),
                    io_maximum_i_ops.to_string(),
                ].join(",")
            }),


            self.kernel_memory.as_ref().map(|kernel_memory| {
                [
                    "KernelMemory".to_string(),
                    kernel_memory.to_string(),
                ].join(",")
            }),


            self.kernel_memory_tcp.as_ref().map(|kernel_memory_tcp| {
                [
                    "KernelMemoryTCP".to_string(),
                    kernel_memory_tcp.to_string(),
                ].join(",")
            }),


            self.memory.as_ref().map(|memory| {
                [
                    "Memory".to_string(),
                    memory.to_string(),
                ].join(",")
            }),


            self.memory_reservation.as_ref().map(|memory_reservation| {
                [
                    "MemoryReservation".to_string(),
                    memory_reservation.to_string(),
                ].join(",")
            }),


            self.memory_swap.as_ref().map(|memory_swap| {
                [
                    "MemorySwap".to_string(),
                    memory_swap.to_string(),
                ].join(",")
            }),


            self.memory_swappiness.as_ref().map(|memory_swappiness| {
                [
                    "MemorySwappiness".to_string(),
                    memory_swappiness.to_string(),
                ].join(",")
            }),


            self.nano_cpus.as_ref().map(|nano_cpus| {
                [
                    "NanoCpus".to_string(),
                    nano_cpus.to_string(),
                ].join(",")
            }),


            self.oom_kill_disable.as_ref().map(|oom_kill_disable| {
                [
                    "OomKillDisable".to_string(),
                    oom_kill_disable.to_string(),
                ].join(",")
            }),


            self.pids_limit.as_ref().map(|pids_limit| {
                [
                    "PidsLimit".to_string(),
                    pids_limit.to_string(),
                ].join(",")
            }),

            // Skipping Ulimits in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Resources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Resources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub blkio_device_read_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_read_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_weight: Vec<i32>,
            pub blkio_weight_device: Vec<Vec<models::WeightDevice>>,
            pub cgroup_parent: Vec<String>,
            pub cpu_count: Vec<i64>,
            pub cpu_percent: Vec<i64>,
            pub cpu_period: Vec<i64>,
            pub cpu_quota: Vec<i64>,
            pub cpu_realtime_period: Vec<i64>,
            pub cpu_realtime_runtime: Vec<i64>,
            pub cpu_shares: Vec<i64>,
            pub cpuset_cpus: Vec<String>,
            pub cpuset_mems: Vec<String>,
            pub device_cgroup_rules: Vec<Vec<String>>,
            pub device_requests: Vec<Vec<models::DeviceRequest>>,
            pub devices: Vec<Vec<models::DeviceMapping>>,
            pub io_maximum_bandwidth: Vec<i32>,
            pub io_maximum_i_ops: Vec<i32>,
            pub kernel_memory: Vec<i64>,
            pub kernel_memory_tcp: Vec<i64>,
            pub memory: Vec<i64>,
            pub memory_reservation: Vec<i64>,
            pub memory_swap: Vec<i64>,
            pub memory_swappiness: Vec<i64>,
            pub nano_cpus: Vec<i64>,
            pub oom_kill_disable: Vec<bool>,
            pub pids_limit: Vec<i64>,
            pub ulimits: Vec<Vec<models::Ulimit>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Resources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "BlkioDeviceReadBps" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "BlkioDeviceReadIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "BlkioDeviceWriteBps" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "BlkioDeviceWriteIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "BlkioWeight" => intermediate_rep.blkio_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "BlkioWeightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "CgroupParent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuCount" => intermediate_rep.cpu_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPercent" => intermediate_rep.cpu_percent.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPeriod" => intermediate_rep.cpu_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuQuota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimePeriod" => intermediate_rep.cpu_realtime_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimeRuntime" => intermediate_rep.cpu_realtime_runtime.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuShares" => intermediate_rep.cpu_shares.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetCpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetMems" => intermediate_rep.cpuset_mems.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DeviceCgroupRules" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "DeviceRequests" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumBandwidth" => intermediate_rep.io_maximum_bandwidth.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumIOps" => intermediate_rep.io_maximum_i_ops.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemory" => intermediate_rep.kernel_memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemoryTCP" => intermediate_rep.kernel_memory_tcp.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Memory" => intermediate_rep.memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemoryReservation" => intermediate_rep.memory_reservation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwap" => intermediate_rep.memory_swap.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwappiness" => intermediate_rep.memory_swappiness.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NanoCpus" => intermediate_rep.nano_cpus.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomKillDisable" => intermediate_rep.oom_kill_disable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidsLimit" => intermediate_rep.pids_limit.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ulimits" => return std::result::Result::Err("Parsing a container in this style is not supported in Resources".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Resources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Resources {
            blkio_device_read_bps: intermediate_rep.blkio_device_read_bps.into_iter().next(),
            blkio_device_read_i_ops: intermediate_rep.blkio_device_read_i_ops.into_iter().next(),
            blkio_device_write_bps: intermediate_rep.blkio_device_write_bps.into_iter().next(),
            blkio_device_write_i_ops: intermediate_rep.blkio_device_write_i_ops.into_iter().next(),
            blkio_weight: intermediate_rep.blkio_weight.into_iter().next(),
            blkio_weight_device: intermediate_rep.blkio_weight_device.into_iter().next(),
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cpu_count: intermediate_rep.cpu_count.into_iter().next(),
            cpu_percent: intermediate_rep.cpu_percent.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            cpu_realtime_period: intermediate_rep.cpu_realtime_period.into_iter().next(),
            cpu_realtime_runtime: intermediate_rep.cpu_realtime_runtime.into_iter().next(),
            cpu_shares: intermediate_rep.cpu_shares.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            cpuset_mems: intermediate_rep.cpuset_mems.into_iter().next(),
            device_cgroup_rules: intermediate_rep.device_cgroup_rules.into_iter().next(),
            device_requests: intermediate_rep.device_requests.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            io_maximum_bandwidth: intermediate_rep.io_maximum_bandwidth.into_iter().next(),
            io_maximum_i_ops: intermediate_rep.io_maximum_i_ops.into_iter().next(),
            kernel_memory: intermediate_rep.kernel_memory.into_iter().next(),
            kernel_memory_tcp: intermediate_rep.kernel_memory_tcp.into_iter().next(),
            memory: intermediate_rep.memory.into_iter().next(),
            memory_reservation: intermediate_rep.memory_reservation.into_iter().next(),
            memory_swap: intermediate_rep.memory_swap.into_iter().next(),
            memory_swappiness: intermediate_rep.memory_swappiness.into_iter().next(),
            nano_cpus: intermediate_rep.nano_cpus.into_iter().next(),
            oom_kill_disable: intermediate_rep.oom_kill_disable.into_iter().next(),
            pids_limit: intermediate_rep.pids_limit.into_iter().next(),
            ulimits: intermediate_rep.ulimits.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Resources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Resources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Resources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Resources - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Resources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Resources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Resources - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RestartPolicy {
    #[serde(rename = "MaximumRetryCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub maximum_retry_count: Option<i64>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl RestartPolicy {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RestartPolicy {
        RestartPolicy {
            maximum_retry_count: None,
            name: None,
        }
    }
}

/// Converts the RestartPolicy value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RestartPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.maximum_retry_count.as_ref().map(|maximum_retry_count| {
                [
                    "MaximumRetryCount".to_string(),
                    maximum_retry_count.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RestartPolicy value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RestartPolicy {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub maximum_retry_count: Vec<i64>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RestartPolicy".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "MaximumRetryCount" => intermediate_rep.maximum_retry_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RestartPolicy".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RestartPolicy {
            maximum_retry_count: intermediate_rep.maximum_retry_count.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RestartPolicy> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RestartPolicy>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RestartPolicy>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RestartPolicy - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RestartPolicy> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RestartPolicy as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RestartPolicy - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RestartPolicyMode(String);

impl validator::Validate for RestartPolicyMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for RestartPolicyMode {
    fn from(x: String) -> Self {
        RestartPolicyMode(x)
    }
}

impl std::fmt::Display for RestartPolicyMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for RestartPolicyMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(RestartPolicyMode(x.to_string()))
    }
}

impl std::convert::From<RestartPolicyMode> for String {
    fn from(x: RestartPolicyMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for RestartPolicyMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for RestartPolicyMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RootFs {
    #[serde(rename = "Layers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub layers: Option<Vec<models::Digest>>,

    #[serde(rename = "Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl RootFs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RootFs {
        RootFs {
            layers: None,
            r#type: None,
        }
    }
}

/// Converts the RootFs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RootFs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.layers.as_ref().map(|layers| {
                [
                    "Layers".to_string(),
                    layers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "Type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RootFs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RootFs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub layers: Vec<Vec<models::Digest>>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RootFs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Layers" => return std::result::Result::Err("Parsing a container in this style is not supported in RootFs".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RootFs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RootFs {
            layers: intermediate_rep.layers.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RootFs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RootFs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RootFs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RootFs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RootFs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RootFs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RootFs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Route {
/// Destination for this route in CIDR form.
    #[serde(rename = "destination")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination: Option<String>,

/// Gateway IP for this route.
    #[serde(rename = "gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

/// Metric for this route. Optional.
    #[serde(rename = "metric")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metric: Option<i32>,

}


impl Route {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Route {
        Route {
            destination: None,
            gateway: None,
            metric: None,
        }
    }
}

/// Converts the Route value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Route {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.destination.as_ref().map(|destination| {
                [
                    "destination".to_string(),
                    destination.to_string(),
                ].join(",")
            }),


            self.gateway.as_ref().map(|gateway| {
                [
                    "gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),


            self.metric.as_ref().map(|metric| {
                [
                    "metric".to_string(),
                    metric.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Route value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Route {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub destination: Vec<String>,
            pub gateway: Vec<String>,
            pub metric: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Route".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "destination" => intermediate_rep.destination.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metric" => intermediate_rep.metric.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Route".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Route {
            destination: intermediate_rep.destination.into_iter().next(),
            gateway: intermediate_rep.gateway.into_iter().next(),
            metric: intermediate_rep.metric.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Route> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Route>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Route>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Route - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Route> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Route as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Route - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Schema2HealthConfig is a HealthConfig, which holds configuration settings for the HEALTHCHECK feature, from docker/docker/api/types/container.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Schema2HealthConfig {
/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "Interval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interval: Option<i64>,

/// Retries is the number of consecutive failures needed to consider a container as unhealthy. Zero means inherit.
    #[serde(rename = "Retries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retries: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "StartInterval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_interval: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "StartPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_period: Option<i64>,

/// Test is the test to perform to check that the container is healthy. An empty slice means to inherit the default. The options are: {} : inherit healthcheck {\"NONE\"} : disable healthcheck {\"CMD\", args...} : exec arguments directly {\"CMD-SHELL\", command} : run command with system's default shell
    #[serde(rename = "Test")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub test: Option<Vec<String>>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "Timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i64>,

}


impl Schema2HealthConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Schema2HealthConfig {
        Schema2HealthConfig {
            interval: None,
            retries: None,
            start_interval: None,
            start_period: None,
            test: None,
            timeout: None,
        }
    }
}

/// Converts the Schema2HealthConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Schema2HealthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.interval.as_ref().map(|interval| {
                [
                    "Interval".to_string(),
                    interval.to_string(),
                ].join(",")
            }),


            self.retries.as_ref().map(|retries| {
                [
                    "Retries".to_string(),
                    retries.to_string(),
                ].join(",")
            }),


            self.start_interval.as_ref().map(|start_interval| {
                [
                    "StartInterval".to_string(),
                    start_interval.to_string(),
                ].join(",")
            }),


            self.start_period.as_ref().map(|start_period| {
                [
                    "StartPeriod".to_string(),
                    start_period.to_string(),
                ].join(",")
            }),


            self.test.as_ref().map(|test| {
                [
                    "Test".to_string(),
                    test.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "Timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Schema2HealthConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Schema2HealthConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub interval: Vec<i64>,
            pub retries: Vec<i64>,
            pub start_interval: Vec<i64>,
            pub start_period: Vec<i64>,
            pub test: Vec<Vec<String>>,
            pub timeout: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Schema2HealthConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Interval" => intermediate_rep.interval.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Retries" => intermediate_rep.retries.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartInterval" => intermediate_rep.start_interval.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartPeriod" => intermediate_rep.start_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Test" => return std::result::Result::Err("Parsing a container in this style is not supported in Schema2HealthConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Timeout" => intermediate_rep.timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Schema2HealthConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Schema2HealthConfig {
            interval: intermediate_rep.interval.into_iter().next(),
            retries: intermediate_rep.retries.into_iter().next(),
            start_interval: intermediate_rep.start_interval.into_iter().next(),
            start_period: intermediate_rep.start_period.into_iter().next(),
            test: intermediate_rep.test.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Schema2HealthConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Schema2HealthConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Schema2HealthConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Schema2HealthConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Schema2HealthConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Schema2HealthConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Schema2HealthConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// This is publicly visible as c/image/manifest.Schema2List. Internal users should usually use Schema2List instead.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Schema2ListPublic {
    #[serde(rename = "manifests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifests: Option<Vec<models::Schema2ManifestDescriptor>>,

    #[serde(rename = "mediaType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

    #[serde(rename = "schemaVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub schema_version: Option<i64>,

}


impl Schema2ListPublic {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Schema2ListPublic {
        Schema2ListPublic {
            manifests: None,
            media_type: None,
            schema_version: None,
        }
    }
}

/// Converts the Schema2ListPublic value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Schema2ListPublic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping manifests in query parameter serialization


            self.media_type.as_ref().map(|media_type| {
                [
                    "mediaType".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),


            self.schema_version.as_ref().map(|schema_version| {
                [
                    "schemaVersion".to_string(),
                    schema_version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Schema2ListPublic value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Schema2ListPublic {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub manifests: Vec<Vec<models::Schema2ManifestDescriptor>>,
            pub media_type: Vec<String>,
            pub schema_version: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Schema2ListPublic".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "manifests" => return std::result::Result::Err("Parsing a container in this style is not supported in Schema2ListPublic".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "mediaType" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "schemaVersion" => intermediate_rep.schema_version.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Schema2ListPublic".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Schema2ListPublic {
            manifests: intermediate_rep.manifests.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            schema_version: intermediate_rep.schema_version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Schema2ListPublic> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Schema2ListPublic>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Schema2ListPublic>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Schema2ListPublic - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Schema2ListPublic> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Schema2ListPublic as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Schema2ListPublic - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// This is publicly visible as c/image/manifest.Schema2ManifestDescriptor.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Schema2ManifestDescriptor {
/// The following is an example of the contents of Digest types:  sha256:7173b809ca12ec5dee4506cd86be934c4596dd234ee82c0662eac04a8c2c71dc  This allows to abstract the digest behind this type and work only in those terms.
    #[serde(rename = "digest")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub digest: Option<String>,

    #[serde(rename = "mediaType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

    #[serde(rename = "platform")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<models::Schema2PlatformSpec>,

    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

    #[serde(rename = "urls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub urls: Option<Vec<String>>,

}


impl Schema2ManifestDescriptor {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Schema2ManifestDescriptor {
        Schema2ManifestDescriptor {
            digest: None,
            media_type: None,
            platform: None,
            size: None,
            urls: None,
        }
    }
}

/// Converts the Schema2ManifestDescriptor value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Schema2ManifestDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.digest.as_ref().map(|digest| {
                [
                    "digest".to_string(),
                    digest.to_string(),
                ].join(",")
            }),


            self.media_type.as_ref().map(|media_type| {
                [
                    "mediaType".to_string(),
                    media_type.to_string(),
                ].join(",")
            }),

            // Skipping platform in query parameter serialization


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.urls.as_ref().map(|urls| {
                [
                    "urls".to_string(),
                    urls.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Schema2ManifestDescriptor value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Schema2ManifestDescriptor {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub digest: Vec<String>,
            pub media_type: Vec<String>,
            pub platform: Vec<models::Schema2PlatformSpec>,
            pub size: Vec<i64>,
            pub urls: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Schema2ManifestDescriptor".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "digest" => intermediate_rep.digest.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mediaType" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "platform" => intermediate_rep.platform.push(<models::Schema2PlatformSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "urls" => return std::result::Result::Err("Parsing a container in this style is not supported in Schema2ManifestDescriptor".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Schema2ManifestDescriptor".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Schema2ManifestDescriptor {
            digest: intermediate_rep.digest.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            platform: intermediate_rep.platform.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            urls: intermediate_rep.urls.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Schema2ManifestDescriptor> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Schema2ManifestDescriptor>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Schema2ManifestDescriptor>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Schema2ManifestDescriptor - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Schema2ManifestDescriptor> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Schema2ManifestDescriptor as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Schema2ManifestDescriptor - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Schema2PlatformSpec describes the platform which a particular manifest is specialized for. This is publicly visible as c/image/manifest.Schema2PlatformSpec.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Schema2PlatformSpec {
    #[serde(rename = "architecture")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub architecture: Option<String>,

    #[serde(rename = "features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub features: Option<Vec<String>>,

    #[serde(rename = "os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

    #[serde(rename = "os.features")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_period_features: Option<Vec<String>>,

    #[serde(rename = "os.version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os_period_version: Option<String>,

    #[serde(rename = "variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub variant: Option<String>,

}


impl Schema2PlatformSpec {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Schema2PlatformSpec {
        Schema2PlatformSpec {
            architecture: None,
            features: None,
            os: None,
            os_period_features: None,
            os_period_version: None,
            variant: None,
        }
    }
}

/// Converts the Schema2PlatformSpec value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Schema2PlatformSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.architecture.as_ref().map(|architecture| {
                [
                    "architecture".to_string(),
                    architecture.to_string(),
                ].join(",")
            }),


            self.features.as_ref().map(|features| {
                [
                    "features".to_string(),
                    features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os.as_ref().map(|os| {
                [
                    "os".to_string(),
                    os.to_string(),
                ].join(",")
            }),


            self.os_period_features.as_ref().map(|os_period_features| {
                [
                    "os.features".to_string(),
                    os_period_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.os_period_version.as_ref().map(|os_period_version| {
                [
                    "os.version".to_string(),
                    os_period_version.to_string(),
                ].join(",")
            }),


            self.variant.as_ref().map(|variant| {
                [
                    "variant".to_string(),
                    variant.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Schema2PlatformSpec value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Schema2PlatformSpec {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub architecture: Vec<String>,
            pub features: Vec<Vec<String>>,
            pub os: Vec<String>,
            pub os_period_features: Vec<Vec<String>>,
            pub os_period_version: Vec<String>,
            pub variant: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Schema2PlatformSpec".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "architecture" => intermediate_rep.architecture.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "features" => return std::result::Result::Err("Parsing a container in this style is not supported in Schema2PlatformSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "os.features" => return std::result::Result::Err("Parsing a container in this style is not supported in Schema2PlatformSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "os.version" => intermediate_rep.os_period_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "variant" => intermediate_rep.variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Schema2PlatformSpec".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Schema2PlatformSpec {
            architecture: intermediate_rep.architecture.into_iter().next(),
            features: intermediate_rep.features.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            os_period_features: intermediate_rep.os_period_features.into_iter().next(),
            os_period_version: intermediate_rep.os_period_version.into_iter().next(),
            variant: intermediate_rep.variant.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Schema2PlatformSpec> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Schema2PlatformSpec>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Schema2PlatformSpec>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Schema2PlatformSpec - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Schema2PlatformSpec> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Schema2PlatformSpec as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Schema2PlatformSpec - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Scope defines the Scope of a Cluster Volume. This is how many nodes a Volume can be accessed simultaneously on.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Scope(String);

impl validator::Validate for Scope {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Scope {
    fn from(x: String) -> Self {
        Scope(x)
    }
}

impl std::fmt::Display for Scope {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for Scope {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Scope(x.to_string()))
    }
}

impl std::convert::From<Scope> for String {
    fn from(x: Scope) -> Self {
        x.0
    }
}

impl std::ops::Deref for Scope {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Scope {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ScpReport {
    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl ScpReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ScpReport {
        ScpReport {
            id: None,
        }
    }
}

/// Converts the ScpReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ScpReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ScpReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ScpReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ScpReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ScpReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ScpReport {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ScpReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ScpReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ScpReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ScpReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ScpReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ScpReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ScpReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Secret represents a Swarm Secret value that must be passed to the CSI storage plugin when operating on this Volume. It represents one key-value pair of possibly many.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Secret {
/// Key is the name of the key of the key-value pair passed to the plugin.
    #[serde(rename = "Key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

/// Secret is the swarm Secret object from which to read data. This can be a Secret name or ID. The Secret data is retrieved by Swarm and used as the value of the key-value pair passed to the plugin.
    #[serde(rename = "Secret")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<String>,

}


impl Secret {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Secret {
        Secret {
            key: None,
            secret: None,
        }
    }
}

/// Converts the Secret value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Secret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.key.as_ref().map(|key| {
                [
                    "Key".to_string(),
                    key.to_string(),
                ].join(",")
            }),


            self.secret.as_ref().map(|secret| {
                [
                    "Secret".to_string(),
                    secret.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Secret value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Secret {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub key: Vec<String>,
            pub secret: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Secret".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Secret" => intermediate_rep.secret.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Secret".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Secret {
            key: intermediate_rep.key.into_iter().next(),
            secret: intermediate_rep.secret.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Secret> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Secret>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Secret>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Secret - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Secret> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Secret as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Secret - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretCreate {
/// Base64-url-safe-encoded (RFC 4648) data to store as secret.
    #[serde(rename = "Data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<String>,

    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<models::SecretDriverSpec>,

/// Labels are labels on the secret
    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// User-defined name of the secret.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl SecretCreate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretCreate {
        SecretCreate {
            data: None,
            driver: None,
            labels: None,
            name: None,
        }
    }
}

/// Converts the SecretCreate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.data.as_ref().map(|data| {
                [
                    "Data".to_string(),
                    data.to_string(),
                ].join(",")
            }),

            // Skipping Driver in query parameter serialization

            // Skipping Labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretCreate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretCreate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<String>,
            pub driver: Vec<models::SecretDriverSpec>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretCreate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<models::SecretDriverSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in SecretCreate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretCreate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretCreate {
            data: intermediate_rep.data.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretCreate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretCreate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretCreate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretCreate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretCreate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretCreate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretCreate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretCreateLibpod201Response {
    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl SecretCreateLibpod201Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretCreateLibpod201Response {
        SecretCreateLibpod201Response {
            id: None,
        }
    }
}

/// Converts the SecretCreateLibpod201Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretCreateLibpod201Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretCreateLibpod201Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretCreateLibpod201Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretCreateLibpod201Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretCreateLibpod201Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretCreateLibpod201Response {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretCreateLibpod201Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretCreateLibpod201Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretCreateLibpod201Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretCreateLibpod201Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretCreateLibpod201Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretCreateLibpod201Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretCreateLibpod201Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretCreateReport {
    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl SecretCreateReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretCreateReport {
        SecretCreateReport {
            id: None,
        }
    }
}

/// Converts the SecretCreateReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretCreateReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretCreateReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretCreateReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretCreateReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretCreateReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretCreateReport {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretCreateReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretCreateReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretCreateReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretCreateReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretCreateReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretCreateReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretCreateReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretDeleteLibpod404Response {
/// API root cause formatted for automated parsing
    #[serde(rename = "cause")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cause: Option<String>,

/// human error message, formatted for a human to read
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

/// HTTP response code
    #[serde(rename = "response")]
    #[validate(
            range(min = 400),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response: Option<i64>,

}


impl SecretDeleteLibpod404Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretDeleteLibpod404Response {
        SecretDeleteLibpod404Response {
            cause: None,
            message: None,
            response: None,
        }
    }
}

/// Converts the SecretDeleteLibpod404Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretDeleteLibpod404Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cause.as_ref().map(|cause| {
                [
                    "cause".to_string(),
                    cause.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.response.as_ref().map(|response| {
                [
                    "response".to_string(),
                    response.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretDeleteLibpod404Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretDeleteLibpod404Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cause: Vec<String>,
            pub message: Vec<String>,
            pub response: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretDeleteLibpod404Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cause" => intermediate_rep.cause.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response" => intermediate_rep.response.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretDeleteLibpod404Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretDeleteLibpod404Response {
            cause: intermediate_rep.cause.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            response: intermediate_rep.response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretDeleteLibpod404Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretDeleteLibpod404Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretDeleteLibpod404Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretDeleteLibpod404Response - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretDeleteLibpod404Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretDeleteLibpod404Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretDeleteLibpod404Response - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretDriverSpec {
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

}


impl SecretDriverSpec {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretDriverSpec {
        SecretDriverSpec {
            name: None,
            options: None,
        }
    }
}

/// Converts the SecretDriverSpec value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretDriverSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretDriverSpec value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretDriverSpec {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretDriverSpec".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in SecretDriverSpec".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretDriverSpec".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretDriverSpec {
            name: intermediate_rep.name.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretDriverSpec> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretDriverSpec>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretDriverSpec>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretDriverSpec - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretDriverSpec> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretDriverSpec as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretDriverSpec - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretInfoReport {
    #[serde(rename = "CreatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "SecretData")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_data: Option<String>,

    #[serde(rename = "Spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spec: Option<models::SecretSpec>,

    #[serde(rename = "UpdatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}


impl SecretInfoReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretInfoReport {
        SecretInfoReport {
            created_at: None,
            id: None,
            secret_data: None,
            spec: None,
            updated_at: None,
        }
    }
}

/// Converts the SecretInfoReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretInfoReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CreatedAt in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.secret_data.as_ref().map(|secret_data| {
                [
                    "SecretData".to_string(),
                    secret_data.to_string(),
                ].join(",")
            }),

            // Skipping Spec in query parameter serialization

            // Skipping UpdatedAt in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretInfoReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretInfoReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub secret_data: Vec<String>,
            pub spec: Vec<models::SecretSpec>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretInfoReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CreatedAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SecretData" => intermediate_rep.secret_data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Spec" => intermediate_rep.spec.push(<models::SecretSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UpdatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretInfoReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretInfoReport {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            secret_data: intermediate_rep.secret_data.into_iter().next(),
            spec: intermediate_rep.spec.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretInfoReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretInfoReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretInfoReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretInfoReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretInfoReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretInfoReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretInfoReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretInfoReportCompat {
    #[serde(rename = "CreatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "SecretData")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_data: Option<String>,

    #[serde(rename = "Spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spec: Option<models::SecretSpec>,

    #[serde(rename = "UpdatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<models::SecretVersion>,

}


impl SecretInfoReportCompat {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretInfoReportCompat {
        SecretInfoReportCompat {
            created_at: None,
            id: None,
            secret_data: None,
            spec: None,
            updated_at: None,
            version: None,
        }
    }
}

/// Converts the SecretInfoReportCompat value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretInfoReportCompat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping CreatedAt in query parameter serialization


            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.secret_data.as_ref().map(|secret_data| {
                [
                    "SecretData".to_string(),
                    secret_data.to_string(),
                ].join(",")
            }),

            // Skipping Spec in query parameter serialization

            // Skipping UpdatedAt in query parameter serialization

            // Skipping Version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretInfoReportCompat value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretInfoReportCompat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub secret_data: Vec<String>,
            pub spec: Vec<models::SecretSpec>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub version: Vec<models::SecretVersion>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretInfoReportCompat".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "CreatedAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SecretData" => intermediate_rep.secret_data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Spec" => intermediate_rep.spec.push(<models::SecretSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UpdatedAt" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Version" => intermediate_rep.version.push(<models::SecretVersion as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretInfoReportCompat".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretInfoReportCompat {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            secret_data: intermediate_rep.secret_data.into_iter().next(),
            spec: intermediate_rep.spec.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretInfoReportCompat> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretInfoReportCompat>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretInfoReportCompat>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretInfoReportCompat - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretInfoReportCompat> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretInfoReportCompat as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretInfoReportCompat - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretRmReport {
    #[serde(rename = "Err")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub err: Option<String>,

    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl SecretRmReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretRmReport {
        SecretRmReport {
            err: None,
            id: None,
        }
    }
}

/// Converts the SecretRmReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretRmReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.err.as_ref().map(|err| {
                [
                    "Err".to_string(),
                    err.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretRmReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretRmReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub err: Vec<String>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretRmReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Err" => intermediate_rep.err.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretRmReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretRmReport {
            err: intermediate_rep.err.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretRmReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretRmReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretRmReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretRmReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretRmReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretRmReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretRmReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretSpec {
    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<models::SecretDriverSpec>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl SecretSpec {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretSpec {
        SecretSpec {
            driver: None,
            labels: None,
            name: None,
        }
    }
}

/// Converts the SecretSpec value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Driver in query parameter serialization

            // Skipping Labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretSpec value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretSpec {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver: Vec<models::SecretDriverSpec>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretSpec".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<models::SecretDriverSpec as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in SecretSpec".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretSpec".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretSpec {
            driver: intermediate_rep.driver.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretSpec> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretSpec>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretSpec>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretSpec - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretSpec> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretSpec as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretSpec - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecretVersion {
    #[serde(rename = "Index")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<i64>,

}


impl SecretVersion {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecretVersion {
        SecretVersion {
            index: None,
        }
    }
}

/// Converts the SecretVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecretVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.index.as_ref().map(|index| {
                [
                    "Index".to_string(),
                    index.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecretVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecretVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecretVersion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Index" => intermediate_rep.index.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecretVersion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecretVersion {
            index: intermediate_rep.index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecretVersion> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecretVersion>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecretVersion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecretVersion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecretVersion> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecretVersion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecretVersion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SecurityInfo describes the libpod host



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SecurityInfo {
    #[serde(rename = "apparmorEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub apparmor_enabled: Option<bool>,

    #[serde(rename = "capabilities")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub capabilities: Option<String>,

    #[serde(rename = "rootless")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootless: Option<bool>,

    #[serde(rename = "seccompEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seccomp_enabled: Option<bool>,

    #[serde(rename = "seccompProfilePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seccomp_profile_path: Option<String>,

    #[serde(rename = "selinuxEnabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub selinux_enabled: Option<bool>,

}


impl SecurityInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SecurityInfo {
        SecurityInfo {
            apparmor_enabled: None,
            capabilities: None,
            rootless: None,
            seccomp_enabled: None,
            seccomp_profile_path: None,
            selinux_enabled: None,
        }
    }
}

/// Converts the SecurityInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SecurityInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.apparmor_enabled.as_ref().map(|apparmor_enabled| {
                [
                    "apparmorEnabled".to_string(),
                    apparmor_enabled.to_string(),
                ].join(",")
            }),


            self.capabilities.as_ref().map(|capabilities| {
                [
                    "capabilities".to_string(),
                    capabilities.to_string(),
                ].join(",")
            }),


            self.rootless.as_ref().map(|rootless| {
                [
                    "rootless".to_string(),
                    rootless.to_string(),
                ].join(",")
            }),


            self.seccomp_enabled.as_ref().map(|seccomp_enabled| {
                [
                    "seccompEnabled".to_string(),
                    seccomp_enabled.to_string(),
                ].join(",")
            }),


            self.seccomp_profile_path.as_ref().map(|seccomp_profile_path| {
                [
                    "seccompProfilePath".to_string(),
                    seccomp_profile_path.to_string(),
                ].join(",")
            }),


            self.selinux_enabled.as_ref().map(|selinux_enabled| {
                [
                    "selinuxEnabled".to_string(),
                    selinux_enabled.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SecurityInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SecurityInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub apparmor_enabled: Vec<bool>,
            pub capabilities: Vec<String>,
            pub rootless: Vec<bool>,
            pub seccomp_enabled: Vec<bool>,
            pub seccomp_profile_path: Vec<String>,
            pub selinux_enabled: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SecurityInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "apparmorEnabled" => intermediate_rep.apparmor_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "capabilities" => intermediate_rep.capabilities.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootless" => intermediate_rep.rootless.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seccompEnabled" => intermediate_rep.seccomp_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seccompProfilePath" => intermediate_rep.seccomp_profile_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "selinuxEnabled" => intermediate_rep.selinux_enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SecurityInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SecurityInfo {
            apparmor_enabled: intermediate_rep.apparmor_enabled.into_iter().next(),
            capabilities: intermediate_rep.capabilities.into_iter().next(),
            rootless: intermediate_rep.rootless.into_iter().next(),
            seccomp_enabled: intermediate_rep.seccomp_enabled.into_iter().next(),
            seccomp_profile_path: intermediate_rep.seccomp_profile_path.into_iter().next(),
            selinux_enabled: intermediate_rep.selinux_enabled.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SecurityInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SecurityInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SecurityInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SecurityInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SecurityInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SecurityInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SecurityInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ServiceCreateResponse contains the information returned to a client on the creation of a new service.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceCreateResponse {
/// The ID of the created service.
    #[serde(rename = "ID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// Optional warning message.  FIXME(thaJeztah): this should have \"omitempty\" in the generated type.
    #[serde(rename = "Warnings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<Vec<String>>,

}


impl ServiceCreateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ServiceCreateResponse {
        ServiceCreateResponse {
            id: None,
            warnings: None,
        }
    }
}

/// Converts the ServiceCreateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ServiceCreateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "ID".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.warnings.as_ref().map(|warnings| {
                [
                    "Warnings".to_string(),
                    warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceCreateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceCreateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ServiceCreateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ID" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceCreateResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServiceCreateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceCreateResponse {
            id: intermediate_rep.id.into_iter().next(),
            warnings: intermediate_rep.warnings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceCreateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceCreateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ServiceCreateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ServiceCreateResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ServiceCreateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ServiceCreateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ServiceCreateResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ServiceInfo represents service parameters with the list of service's tasks



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceInfo {
    #[serde(rename = "LocalLBIndex")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub local_lb_index: Option<i64>,

    #[serde(rename = "Ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ports: Option<Vec<String>>,

    #[serde(rename = "Tasks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tasks: Option<Vec<models::Task>>,

    #[serde(rename = "VIP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vip: Option<String>,

}


impl ServiceInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ServiceInfo {
        ServiceInfo {
            local_lb_index: None,
            ports: None,
            tasks: None,
            vip: None,
        }
    }
}

/// Converts the ServiceInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ServiceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.local_lb_index.as_ref().map(|local_lb_index| {
                [
                    "LocalLBIndex".to_string(),
                    local_lb_index.to_string(),
                ].join(",")
            }),


            self.ports.as_ref().map(|ports| {
                [
                    "Ports".to_string(),
                    ports.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping Tasks in query parameter serialization


            self.vip.as_ref().map(|vip| {
                [
                    "VIP".to_string(),
                    vip.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub local_lb_index: Vec<i64>,
            pub ports: Vec<Vec<String>>,
            pub tasks: Vec<Vec<models::Task>>,
            pub vip: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ServiceInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "LocalLBIndex" => intermediate_rep.local_lb_index.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ports" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceInfo".to_string()),
                    "Tasks" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "VIP" => intermediate_rep.vip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServiceInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceInfo {
            local_lb_index: intermediate_rep.local_lb_index.into_iter().next(),
            ports: intermediate_rep.ports.into_iter().next(),
            tasks: intermediate_rep.tasks.into_iter().next(),
            vip: intermediate_rep.vip.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ServiceInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ServiceInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ServiceInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ServiceInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ServiceInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ServiceUpdateResponse service update response



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ServiceUpdateResponse {
/// Optional warning messages
    #[serde(rename = "Warnings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<Vec<String>>,

}


impl ServiceUpdateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ServiceUpdateResponse {
        ServiceUpdateResponse {
            warnings: None,
        }
    }
}

/// Converts the ServiceUpdateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ServiceUpdateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.warnings.as_ref().map(|warnings| {
                [
                    "Warnings".to_string(),
                    warnings.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ServiceUpdateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ServiceUpdateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub warnings: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ServiceUpdateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ServiceUpdateResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ServiceUpdateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ServiceUpdateResponse {
            warnings: intermediate_rep.warnings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ServiceUpdateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ServiceUpdateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ServiceUpdateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ServiceUpdateResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ServiceUpdateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ServiceUpdateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ServiceUpdateResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SharingMode defines the Sharing of a Cluster Volume. This is how Tasks using a Volume at the same time can use it.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SharingMode(String);

impl validator::Validate for SharingMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for SharingMode {
    fn from(x: String) -> Self {
        SharingMode(x)
    }
}

impl std::fmt::Display for SharingMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for SharingMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(SharingMode(x.to_string()))
    }
}

impl std::convert::From<SharingMode> for String {
    fn from(x: SharingMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for SharingMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for SharingMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// It implements the os.Signal interface.
#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Signal(i64);

impl validator::Validate for Signal {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<i64> for Signal {
    fn from(x: i64) -> Self {
        Signal(x)
    }
}

impl std::convert::From<Signal> for i64 {
    fn from(x: Signal) -> Self {
        x.0
    }
}

impl std::ops::Deref for Signal {
    type Target = i64;
    fn deref(&self) -> &i64 {
        &self.0
    }
}

impl std::ops::DerefMut for Signal {
    fn deref_mut(&mut self) -> &mut i64 {
        &mut self.0
    }
}



/// SlirpInfo describes the slirp executable that is being used



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SlirpInfo {
    #[serde(rename = "executable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub executable: Option<String>,

    #[serde(rename = "package")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<String>,

    #[serde(rename = "version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl SlirpInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SlirpInfo {
        SlirpInfo {
            executable: None,
            package: None,
            version: None,
        }
    }
}

/// Converts the SlirpInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SlirpInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.executable.as_ref().map(|executable| {
                [
                    "executable".to_string(),
                    executable.to_string(),
                ].join(",")
            }),


            self.package.as_ref().map(|package| {
                [
                    "package".to_string(),
                    package.to_string(),
                ].join(",")
            }),


            self.version.as_ref().map(|version| {
                [
                    "version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SlirpInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SlirpInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub executable: Vec<String>,
            pub package: Vec<String>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SlirpInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "executable" => intermediate_rep.executable.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "package" => intermediate_rep.package.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SlirpInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SlirpInfo {
            executable: intermediate_rep.executable.into_iter().next(),
            package: intermediate_rep.package.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SlirpInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SlirpInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SlirpInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SlirpInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SlirpInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SlirpInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SlirpInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SpecGenerator creates an OCI spec and Libpod configuration options to create a container based on the given configuration.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SpecGenerator {
/// Map of networks names or ids that the container should join. You can request additional settings for each network, you can set network aliases, static ips, static mac address  and the network interface name for this container on the specific network. If the map is empty and the bridge network mode is set the container will be joined to the default network. Optional.
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<std::collections::HashMap<String, models::PerNetworkOptions>>,

/// Annotations are key-value options passed into the container runtime that can be used to trigger special behavior. Optional.
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<std::collections::HashMap<String, String>>,

/// ApparmorProfile is the name of the Apparmor profile the container will use. Optional.
    #[serde(rename = "apparmor_profile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub apparmor_profile: Option<String>,

/// BaseHostsFile is the path to a hosts file, the entries from this file are added to the containers hosts file. As special value \"image\" is allowed which uses the /etc/hosts file from within the image and \"none\" which uses no base file at all. If it is empty we should default to the base_hosts_file configuration in containers.conf. Optional.
    #[serde(rename = "base_hosts_file")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_hosts_file: Option<String>,

/// CapAdd are capabilities which will be added to the container. Conflicts with Privileged. Optional.
    #[serde(rename = "cap_add")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_add: Option<Vec<String>>,

/// CapDrop are capabilities which will be removed from the container. Conflicts with Privileged. Optional.
    #[serde(rename = "cap_drop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cap_drop: Option<Vec<String>>,

/// CgroupParent is the container's Cgroup parent. If not set, the default for the current cgroup driver will be used. Optional.
    #[serde(rename = "cgroup_parent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

    #[serde(rename = "cgroupns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroupns: Option<models::Namespace>,

/// CgroupsMode sets a policy for how cgroups will be created for the container, including the ability to disable creation entirely. Optional.
    #[serde(rename = "cgroups_mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroups_mode: Option<String>,

/// ChrootDirs is an additional set of directories that need to be treated as root directories. Standard bind mounts will be mounted into paths relative to these directories. Optional.
    #[serde(rename = "chroot_directories")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chroot_directories: Option<Vec<String>>,

/// CNINetworks is a list of CNI networks to join the container to. If this list is empty, the default CNI network will be joined instead. If at least one entry is present, we will not join the default network (unless it is part of this list). Only available if NetNS is set to bridge. Optional. Deprecated: as of podman 4.0 use \"Networks\" instead.
    #[serde(rename = "cni_networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cni_networks: Option<Vec<String>>,

/// Command is the container's command. If not given and Image is specified, this will be populated by the image's configuration. Optional.
    #[serde(rename = "command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<Vec<String>>,

/// ConmonPidFile is a path at which a PID file for Conmon will be placed. If not given, a default location will be used. Optional.
    #[serde(rename = "conmon_pid_file")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conmon_pid_file: Option<String>,

/// ContainerCreateCommand is the command that was used to create this container. This will be shown in the output of Inspect() on the container, and may also be used by some tools that wish to recreate the container (e.g. `podman generate systemd --new`). Optional.
    #[serde(rename = "containerCreateCommand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_create_command: Option<Vec<String>>,

/// Create the working directory if it doesn't exist. If unset, it doesn't create it. Optional.
    #[serde(rename = "create_working_dir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_working_dir: Option<bool>,

/// DependencyContainers is an array of containers this container depends on. Dependency containers must be started before this container. Dependencies can be specified by name or full/partial ID. Optional.
    #[serde(rename = "dependencyContainers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_containers: Option<Vec<String>>,

/// DeviceCgroupRule are device cgroup rules that allow containers to use additional types of devices.
    #[serde(rename = "device_cgroup_rule")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_cgroup_rule: Option<Vec<models::LinuxDeviceCgroup>>,

/// Devices are devices that will be added to the container. Optional.
    #[serde(rename = "devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::LinuxDevice>>,

/// DevicesFrom specifies that this container will mount the device(s) from other container(s). Optional.
    #[serde(rename = "devices_from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices_from: Option<Vec<String>>,

/// DNSOptions is a set of DNS options that will be used in the container's resolv.conf, replacing the host's DNS options which are used by default. Conflicts with UseImageResolvConf. Optional.
    #[serde(rename = "dns_option")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_option: Option<Vec<String>>,

/// DNSSearch is a set of DNS search domains that will be used in the container's resolv.conf, replacing the host's DNS search domains which are used by default. Conflicts with UseImageResolvConf. Optional.
    #[serde(rename = "dns_search")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_search: Option<Vec<String>>,

/// DNSServers is a set of DNS servers that will be used in the container's resolv.conf, replacing the host's DNS Servers which are used by default. Conflicts with UseImageResolvConf. Optional.
    #[serde(rename = "dns_server")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_server: Option<Vec<String>>,

/// Entrypoint is the container's entrypoint. If not given and Image is specified, this will be populated by the image's configuration. Optional.
    #[serde(rename = "entrypoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entrypoint: Option<Vec<String>>,

/// Env is a set of environment variables that will be set in the container. Optional.
    #[serde(rename = "env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env: Option<std::collections::HashMap<String, String>>,

/// EnvHost indicates that the host environment should be added to container Optional.
    #[serde(rename = "env_host")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub env_host: Option<bool>,

/// EnvMerge takes the specified environment variables from image and preprocess them before injecting them into the container. Optional.
    #[serde(rename = "envmerge")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub envmerge: Option<Vec<String>>,

/// Expose is a number of ports that will be forwarded to the container if PublishExposedPorts is set. Expose is a map of uint16 (port number) to a string representing protocol i.e map[uint16]string. Allowed protocols are \"tcp\", \"udp\", and \"sctp\", or some combination of the three separated by commas. If protocol is set to \"\" we will assume TCP. Only available if NetNS is set to Bridge or Slirp, and PublishExposedPorts is set. Optional.
    #[serde(rename = "expose")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expose: Option<crate::types::Object>,

/// GroupEntry specifies an arbitrary string to append to the container's /etc/group file. Optional.
    #[serde(rename = "group_entry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_entry: Option<String>,

/// Groups are a list of supplemental groups the container's user will be granted access to. Optional.
    #[serde(rename = "groups")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub groups: Option<Vec<String>>,

/// HealthCheckOnFailureAction defines how Podman reacts when a container's health status turns unhealthy.
    #[serde(rename = "health_check_on_failure_action")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub health_check_on_failure_action: Option<i64>,

    #[serde(rename = "healthconfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healthconfig: Option<models::Schema2HealthConfig>,

/// HostDeviceList is used to recreate the mounted device on inherited containers
    #[serde(rename = "host_device_list")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub host_device_list: Option<Vec<models::LinuxDevice>>,

/// HostAdd is a set of hosts which will be added to the container's etc/hosts file. Conflicts with UseImageHosts. Optional.
    #[serde(rename = "hostadd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostadd: Option<Vec<String>>,

/// Hostname is the container's hostname. If not set, the hostname will not be modified (if UtsNS is not private) or will be set to the container ID (if UtsNS is private). Conflicts with UtsNS if UtsNS is not set to private. Optional.
    #[serde(rename = "hostname")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostname: Option<String>,

/// HostUsers is a list of host usernames or UIDs to add to the container etc/passwd file
    #[serde(rename = "hostusers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hostusers: Option<Vec<String>>,

/// EnvHTTPProxy indicates that the http host proxy environment variables should be added to container Optional.
    #[serde(rename = "httpproxy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub httpproxy: Option<bool>,

    #[serde(rename = "idmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub idmappings: Option<models::IdMappingOptions>,

/// Image is the image the container will be based on. The image will be used as the container's root filesystem, and its environment vars, volumes, and other configuration will be applied to the container. Conflicts with Rootfs. At least one of Image or Rootfs must be specified.
    #[serde(rename = "image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

/// ImageArch is the user-specified image architecture. Used to select a different variant from a manifest list. Optional.
    #[serde(rename = "image_arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_arch: Option<String>,

/// ImageOS is the user-specified OS of the image. Used to select a different variant from a manifest list. Optional.
    #[serde(rename = "image_os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_os: Option<String>,

/// ImageVariant is the user-specified image variant. Used to select a different variant from a manifest list. Optional.
    #[serde(rename = "image_variant")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_variant: Option<String>,

/// ImageVolumeMode indicates how image volumes will be created. Supported modes are \"ignore\" (do not create), \"tmpfs\" (create as tmpfs), and \"anonymous\" (create as anonymous volumes). The default if unset is anonymous. Optional.
    #[serde(rename = "image_volume_mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_volume_mode: Option<String>,

/// Image volumes bind-mount a container-image mount into the container. Optional.
    #[serde(rename = "image_volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_volumes: Option<Vec<models::ImageVolume>>,

/// Init specifies that an init binary will be mounted into the container, and will be used as PID1. Optional.
    #[serde(rename = "init")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init: Option<bool>,

/// InitContainerType describes if this container is an init container and if so, what type: always or once. Optional.
    #[serde(rename = "init_container_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init_container_type: Option<String>,

/// InitPath specifies the path to the init binary that will be added if Init is specified above. If not specified, the default set in the Libpod config will be used. Ignored if Init above is not set. Optional.
    #[serde(rename = "init_path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub init_path: Option<String>,

    #[serde(rename = "intelRdt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub intel_rdt: Option<models::LinuxIntelRdt>,

    #[serde(rename = "ipcns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ipcns: Option<models::Namespace>,

/// LabelNested indicates whether or not the container is allowed to run fully nested containers including SELinux labelling. Optional.
    #[serde(rename = "label_nested")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub label_nested: Option<bool>,

/// Labels are key-value pairs that are used to add metadata to containers. Optional.
    #[serde(rename = "labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "log_configuration")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_configuration: Option<models::LogConfigLibpod>,

/// Passwd is a container run option that determines if we are validating users/groups before running the container
    #[serde(rename = "manage_password")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub manage_password: Option<bool>,

/// Mask is the path we want to mask in the container. This masks the paths given in addition to the default list. Optional
    #[serde(rename = "mask")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mask: Option<Vec<String>>,

/// Mounts are mounts that will be added to the container. These will supersede Image Volumes and VolumesFrom volumes where there are conflicts. Optional.
    #[serde(rename = "mounts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mounts: Option<Vec<models::Mount>>,

/// Name is the name the container will be given. If no name is provided, one will be randomly generated. Optional.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "netns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub netns: Option<models::Namespace>,

/// NetworkOptions are additional options for each network Optional.
    #[serde(rename = "network_options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_options: Option<std::collections::HashMap<String, Vec<String>>>,

/// NoNewPrivileges is whether the container will set the no new privileges flag on create, which disables gaining additional privileges (e.g. via setuid) in the container. Optional.
    #[serde(rename = "no_new_privileges")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_new_privileges: Option<bool>,

/// OCIRuntime is the name of the OCI runtime that will be used to create the container. If not specified, the default will be used. Optional.
    #[serde(rename = "oci_runtime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oci_runtime: Option<String>,

/// OOMScoreAdj adjusts the score used by the OOM killer to determine processes to kill for the container's process. Optional.
    #[serde(rename = "oom_score_adj")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_score_adj: Option<i64>,

/// Overlay volumes are named volumes that will be added to the container. Optional.
    #[serde(rename = "overlay_volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub overlay_volumes: Option<Vec<models::OverlayVolume>>,

/// PasswdEntry specifies an arbitrary string to append to the container's /etc/passwd file. Optional.
    #[serde(rename = "passwd_entry")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub passwd_entry: Option<String>,

    #[serde(rename = "personality")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub personality: Option<models::LinuxPersonality>,

    #[serde(rename = "pidns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pidns: Option<models::Namespace>,

/// Pod is the ID of the pod the container will join. Optional.
    #[serde(rename = "pod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod: Option<String>,

/// PortBindings is a set of ports to map into the container. Only available if NetNS is set to bridge, slirp, or pasta. Optional.
    #[serde(rename = "portmappings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub portmappings: Option<Vec<models::PortMapping>>,

/// Privileged is whether the container is privileged. Privileged does the following: Adds all devices on the system to the container. Adds all capabilities to the container. Disables Seccomp, SELinux, and Apparmor confinement. (Though SELinux can be manually re-enabled). TODO: this conflicts with things. TODO: this does more. Optional.
    #[serde(rename = "privileged")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privileged: Option<bool>,

/// ProcOpts are the options used for the proc mount.
    #[serde(rename = "procfs_opts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub procfs_opts: Option<Vec<String>>,

/// PublishExposedPorts will publish ports specified in the image to random unused ports (guaranteed to be above 1024) on the host. This is based on ports set in Expose below, and any ports specified by the Image (if one is given). Only available if NetNS is set to Bridge or Slirp. Optional.
    #[serde(rename = "publish_image_ports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_image_ports: Option<bool>,

/// Rlimits are POSIX rlimits to apply to the container. Optional.
    #[serde(rename = "r_limits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_limits: Option<Vec<models::PosixRlimit>>,

/// RawImageName is the user-specified and unprocessed input referring to a local or a remote image. Optional, but strongly encouraged to be set if Image is set.
    #[serde(rename = "raw_image_name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_image_name: Option<String>,

/// ReadOnlyFilesystem indicates that everything will be mounted as read-only. Optional.
    #[serde(rename = "read_only_filesystem")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only_filesystem: Option<bool>,

/// ReadWriteTmpfs indicates that when running with a ReadOnlyFilesystem mount temporary file systems. Optional.
    #[serde(rename = "read_write_tmpfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_write_tmpfs: Option<bool>,

/// Remove indicates if the container should be removed once it has been started and exits. Optional.
    #[serde(rename = "remove")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub remove: Option<bool>,

    #[serde(rename = "resource_limits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource_limits: Option<models::LinuxResources>,

/// RestartPolicy is the container's restart policy - an action which will be taken when the container exits. If not given, the default policy, which does nothing, will be used. Optional.
    #[serde(rename = "restart_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<String>,

/// RestartRetries is the number of attempts that will be made to restart the container. Only available when RestartPolicy is set to \"on-failure\". Optional.
    #[serde(rename = "restart_tries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_tries: Option<i32>,

/// Rootfs is the path to a directory that will be used as the container's root filesystem. No modification will be made to the directory, it will be directly mounted into the container as root. Conflicts with Image. At least one of Image or Rootfs must be specified.
    #[serde(rename = "rootfs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs: Option<String>,

/// RootfsMapping specifies if there are UID/GID mappings to apply to the rootfs. Optional.
    #[serde(rename = "rootfs_mapping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs_mapping: Option<String>,

/// RootfsOverlay tells if rootfs is actually an overlay on top of base path. Optional.
    #[serde(rename = "rootfs_overlay")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs_overlay: Option<bool>,

/// RootfsPropagation is the rootfs propagation mode for the container. If not set, the default of rslave will be used. Optional.
    #[serde(rename = "rootfs_propagation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rootfs_propagation: Option<String>,

/// Determine how to handle the NOTIFY_SOCKET - do we participate or pass it through \"container\" - let the OCI runtime deal with it, advertise conmon's MAINPID \"conmon-only\" - advertise conmon's MAINPID, send READY when started, don't pass to OCI \"ignore\" - unset NOTIFY_SOCKET Optional.
    #[serde(rename = "sdnotifyMode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sdnotify_mode: Option<String>,

/// SeccompPolicy determines which seccomp profile gets applied the container. valid values: empty,default,image
    #[serde(rename = "seccomp_policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seccomp_policy: Option<String>,

/// SeccompProfilePath is the path to a JSON file containing the container's Seccomp profile. If not specified, no Seccomp profile will be used. Optional.
    #[serde(rename = "seccomp_profile_path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seccomp_profile_path: Option<String>,

/// EnvSecrets are secrets that will be set as environment variables Optional.
    #[serde(rename = "secret_env")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_env: Option<std::collections::HashMap<String, String>>,

/// Secrets are the secrets that will be added to the container Optional.
    #[serde(rename = "secrets")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<models::Secret>>,

/// SelinuxProcessLabel is the process label the container will use. If SELinux is enabled and this is not specified, a label will be automatically generated if not specified. Optional.
    #[serde(rename = "selinux_opts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub selinux_opts: Option<Vec<String>>,

/// ShmSize is the size of the tmpfs to mount in at /dev/shm, in bytes. Conflicts with ShmSize if IpcNS is not private. Optional.
    #[serde(rename = "shm_size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size: Option<i64>,

/// ShmSizeSystemd is the size of systemd-specific tmpfs mounts specifically /run, /run/lock, /var/log/journal and /tmp. Optional
    #[serde(rename = "shm_size_systemd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shm_size_systemd: Option<i64>,

    #[serde(rename = "startupHealthConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub startup_health_config: Option<models::StartupHealthCheck>,

/// Stdin is whether the container will keep its STDIN open. Optional.
    #[serde(rename = "stdin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stdin: Option<bool>,

/// It implements the os.Signal interface.
    #[serde(rename = "stop_signal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_signal: Option<i64>,

/// StopTimeout is a timeout between the container's stop signal being sent and SIGKILL being sent. If not provided, the default will be used. If 0 is used, stop signal will not be sent, and SIGKILL will be sent instead. Optional.
    #[serde(rename = "stop_timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_timeout: Option<i32>,

/// StorageOpts is the container's storage options Optional.
    #[serde(rename = "storage_opts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_opts: Option<std::collections::HashMap<String, String>>,

/// Sysctl sets kernel parameters for the container
    #[serde(rename = "sysctl")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sysctl: Option<std::collections::HashMap<String, String>>,

/// Systemd is whether the container will be started in systemd mode. Valid options are \"true\", \"false\", and \"always\". \"true\" enables this mode only if the binary run in the container is sbin/init or systemd. \"always\" unconditionally enables systemd mode. \"false\" unconditionally disables systemd mode. If enabled, mounts and stop signal will be modified. If set to \"always\" or set to \"true\" and conditionally triggered, conflicts with StopSignal. If not specified, \"false\" will be assumed. Optional.
    #[serde(rename = "systemd")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub systemd: Option<String>,

/// Terminal is whether the container will create a PTY. Optional.
    #[serde(rename = "terminal")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub terminal: Option<bool>,

/// IO read rate limit per cgroup per device, bytes per second
    #[serde(rename = "throttleReadBpsDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_read_bps_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

/// IO read rate limit per cgroup per device, IO per second
    #[serde(rename = "throttleReadIOPSDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_read_iops_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

/// IO write rate limit per cgroup per device, bytes per second
    #[serde(rename = "throttleWriteBpsDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_write_bps_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

/// IO write rate limit per cgroup per device, IO per second
    #[serde(rename = "throttleWriteIOPSDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttle_write_iops_device: Option<std::collections::HashMap<String, models::LinuxThrottleDevice>>,

/// Timeout is a maximum time in seconds the container will run before main process is sent SIGKILL. If 0 is used, signal will not be sent. Container can run indefinitely if they do not stop after the default termination signal. Optional.
    #[serde(rename = "timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i32>,

/// Timezone is the timezone inside the container. Local means it has the same timezone as the host machine Optional.
    #[serde(rename = "timezone")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timezone: Option<String>,

/// Umask is the umask the init process of the container will be run with.
    #[serde(rename = "umask")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub umask: Option<String>,

/// CgroupConf are key-value options passed into the container runtime that are used to configure cgroup v2. Optional.
    #[serde(rename = "unified")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unified: Option<std::collections::HashMap<String, String>>,

/// Unmask a path in the container. Some paths are masked by default, preventing them from being accessed within the container; this undoes that masking. If ALL is passed, all paths will be unmasked. Optional.
    #[serde(rename = "unmask")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unmask: Option<Vec<String>>,

/// UnsetEnv unsets the specified default environment variables from the image or from buildin or containers.conf Optional.
    #[serde(rename = "unsetenv")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unsetenv: Option<Vec<String>>,

/// UnsetEnvAll unsetall default environment variables from the image or from buildin or containers.conf UnsetEnvAll unsets all default environment variables from the image or from buildin Optional.
    #[serde(rename = "unsetenvall")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unsetenvall: Option<bool>,

/// UseImageHosts indicates that /etc/hosts should not be managed by Podman, and instead sourced from the image. Conflicts with HostAdd. Optional.
    #[serde(rename = "use_image_hosts")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_image_hosts: Option<bool>,

/// UseImageResolvConf indicates that resolv.conf should not be managed by Podman, but instead sourced from the image. Conflicts with DNSServer, DNSSearch, DNSOption. Optional.
    #[serde(rename = "use_image_resolve_conf")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_image_resolve_conf: Option<bool>,

/// User is the user the container will be run as. Can be given as a UID or a username; if a username, it will be resolved within the container, using the container's /etc/passwd. If unset, the container will be run as root. Optional.
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

    #[serde(rename = "userns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub userns: Option<models::Namespace>,

    #[serde(rename = "utsns")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub utsns: Option<models::Namespace>,

/// Volatile specifies whether the container storage can be optimized at the cost of not syncing all the dirty files in memory. Optional.
    #[serde(rename = "volatile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volatile: Option<bool>,

/// Volumes are named volumes that will be added to the container. These will supersede Image Volumes and VolumesFrom volumes where there are conflicts. Optional.
    #[serde(rename = "volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<Vec<models::NamedVolume>>,

/// VolumesFrom is a set of containers whose volumes will be added to this container. The name or ID of the container must be provided, and may optionally be followed by a : and then one or more comma-separated options. Valid options are 'ro', 'rw', and 'z'. Options will be used for all volumes sourced from the container. Optional.
    #[serde(rename = "volumes_from")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_from: Option<Vec<String>>,

/// Weight per cgroup per device, can override BlkioWeight
    #[serde(rename = "weightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_device: Option<std::collections::HashMap<String, models::LinuxWeightDevice>>,

/// WorkDir is the container's working directory. If unset, the default, /, will be used. Optional.
    #[serde(rename = "work_dir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub work_dir: Option<String>,

}


impl SpecGenerator {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SpecGenerator {
        SpecGenerator {
            networks: None,
            annotations: None,
            apparmor_profile: None,
            base_hosts_file: None,
            cap_add: None,
            cap_drop: None,
            cgroup_parent: None,
            cgroupns: None,
            cgroups_mode: None,
            chroot_directories: None,
            cni_networks: None,
            command: None,
            conmon_pid_file: None,
            container_create_command: None,
            create_working_dir: None,
            dependency_containers: None,
            device_cgroup_rule: None,
            devices: None,
            devices_from: None,
            dns_option: None,
            dns_search: None,
            dns_server: None,
            entrypoint: None,
            env: None,
            env_host: None,
            envmerge: None,
            expose: None,
            group_entry: None,
            groups: None,
            health_check_on_failure_action: None,
            healthconfig: None,
            host_device_list: None,
            hostadd: None,
            hostname: None,
            hostusers: None,
            httpproxy: None,
            idmappings: None,
            image: None,
            image_arch: None,
            image_os: None,
            image_variant: None,
            image_volume_mode: None,
            image_volumes: None,
            init: None,
            init_container_type: None,
            init_path: None,
            intel_rdt: None,
            ipcns: None,
            label_nested: None,
            labels: None,
            log_configuration: None,
            manage_password: None,
            mask: None,
            mounts: None,
            name: None,
            netns: None,
            network_options: None,
            no_new_privileges: None,
            oci_runtime: None,
            oom_score_adj: None,
            overlay_volumes: None,
            passwd_entry: None,
            personality: None,
            pidns: None,
            pod: None,
            portmappings: None,
            privileged: None,
            procfs_opts: None,
            publish_image_ports: None,
            r_limits: None,
            raw_image_name: None,
            read_only_filesystem: None,
            read_write_tmpfs: None,
            remove: None,
            resource_limits: None,
            restart_policy: None,
            restart_tries: None,
            rootfs: None,
            rootfs_mapping: None,
            rootfs_overlay: None,
            rootfs_propagation: None,
            sdnotify_mode: None,
            seccomp_policy: None,
            seccomp_profile_path: None,
            secret_env: None,
            secrets: None,
            selinux_opts: None,
            shm_size: None,
            shm_size_systemd: None,
            startup_health_config: None,
            stdin: None,
            stop_signal: None,
            stop_timeout: None,
            storage_opts: None,
            sysctl: None,
            systemd: None,
            terminal: None,
            throttle_read_bps_device: None,
            throttle_read_iops_device: None,
            throttle_write_bps_device: None,
            throttle_write_iops_device: None,
            timeout: None,
            timezone: None,
            umask: None,
            unified: None,
            unmask: None,
            unsetenv: None,
            unsetenvall: None,
            use_image_hosts: None,
            use_image_resolve_conf: None,
            user: None,
            userns: None,
            utsns: None,
            volatile: None,
            volumes: None,
            volumes_from: None,
            weight_device: None,
            work_dir: None,
        }
    }
}

/// Converts the SpecGenerator value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SpecGenerator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Networks in query parameter serialization
            // Skipping Networks in query parameter serialization

            // Skipping annotations in query parameter serialization


            self.apparmor_profile.as_ref().map(|apparmor_profile| {
                [
                    "apparmor_profile".to_string(),
                    apparmor_profile.to_string(),
                ].join(",")
            }),


            self.base_hosts_file.as_ref().map(|base_hosts_file| {
                [
                    "base_hosts_file".to_string(),
                    base_hosts_file.to_string(),
                ].join(",")
            }),


            self.cap_add.as_ref().map(|cap_add| {
                [
                    "cap_add".to_string(),
                    cap_add.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cap_drop.as_ref().map(|cap_drop| {
                [
                    "cap_drop".to_string(),
                    cap_drop.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "cgroup_parent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),

            // Skipping cgroupns in query parameter serialization


            self.cgroups_mode.as_ref().map(|cgroups_mode| {
                [
                    "cgroups_mode".to_string(),
                    cgroups_mode.to_string(),
                ].join(",")
            }),


            self.chroot_directories.as_ref().map(|chroot_directories| {
                [
                    "chroot_directories".to_string(),
                    chroot_directories.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.cni_networks.as_ref().map(|cni_networks| {
                [
                    "cni_networks".to_string(),
                    cni_networks.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.command.as_ref().map(|command| {
                [
                    "command".to_string(),
                    command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.conmon_pid_file.as_ref().map(|conmon_pid_file| {
                [
                    "conmon_pid_file".to_string(),
                    conmon_pid_file.to_string(),
                ].join(",")
            }),


            self.container_create_command.as_ref().map(|container_create_command| {
                [
                    "containerCreateCommand".to_string(),
                    container_create_command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.create_working_dir.as_ref().map(|create_working_dir| {
                [
                    "create_working_dir".to_string(),
                    create_working_dir.to_string(),
                ].join(",")
            }),


            self.dependency_containers.as_ref().map(|dependency_containers| {
                [
                    "dependencyContainers".to_string(),
                    dependency_containers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping device_cgroup_rule in query parameter serialization

            // Skipping devices in query parameter serialization


            self.devices_from.as_ref().map(|devices_from| {
                [
                    "devices_from".to_string(),
                    devices_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_option.as_ref().map(|dns_option| {
                [
                    "dns_option".to_string(),
                    dns_option.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_search.as_ref().map(|dns_search| {
                [
                    "dns_search".to_string(),
                    dns_search.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.dns_server.as_ref().map(|dns_server| {
                [
                    "dns_server".to_string(),
                    dns_server.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.entrypoint.as_ref().map(|entrypoint| {
                [
                    "entrypoint".to_string(),
                    entrypoint.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping env in query parameter serialization


            self.env_host.as_ref().map(|env_host| {
                [
                    "env_host".to_string(),
                    env_host.to_string(),
                ].join(",")
            }),


            self.envmerge.as_ref().map(|envmerge| {
                [
                    "envmerge".to_string(),
                    envmerge.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping expose in query parameter serialization


            self.group_entry.as_ref().map(|group_entry| {
                [
                    "group_entry".to_string(),
                    group_entry.to_string(),
                ].join(",")
            }),


            self.groups.as_ref().map(|groups| {
                [
                    "groups".to_string(),
                    groups.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.health_check_on_failure_action.as_ref().map(|health_check_on_failure_action| {
                [
                    "health_check_on_failure_action".to_string(),
                    health_check_on_failure_action.to_string(),
                ].join(",")
            }),

            // Skipping healthconfig in query parameter serialization

            // Skipping host_device_list in query parameter serialization


            self.hostadd.as_ref().map(|hostadd| {
                [
                    "hostadd".to_string(),
                    hostadd.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.hostname.as_ref().map(|hostname| {
                [
                    "hostname".to_string(),
                    hostname.to_string(),
                ].join(",")
            }),


            self.hostusers.as_ref().map(|hostusers| {
                [
                    "hostusers".to_string(),
                    hostusers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.httpproxy.as_ref().map(|httpproxy| {
                [
                    "httpproxy".to_string(),
                    httpproxy.to_string(),
                ].join(",")
            }),

            // Skipping idmappings in query parameter serialization


            self.image.as_ref().map(|image| {
                [
                    "image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.image_arch.as_ref().map(|image_arch| {
                [
                    "image_arch".to_string(),
                    image_arch.to_string(),
                ].join(",")
            }),


            self.image_os.as_ref().map(|image_os| {
                [
                    "image_os".to_string(),
                    image_os.to_string(),
                ].join(",")
            }),


            self.image_variant.as_ref().map(|image_variant| {
                [
                    "image_variant".to_string(),
                    image_variant.to_string(),
                ].join(",")
            }),


            self.image_volume_mode.as_ref().map(|image_volume_mode| {
                [
                    "image_volume_mode".to_string(),
                    image_volume_mode.to_string(),
                ].join(",")
            }),

            // Skipping image_volumes in query parameter serialization


            self.init.as_ref().map(|init| {
                [
                    "init".to_string(),
                    init.to_string(),
                ].join(",")
            }),


            self.init_container_type.as_ref().map(|init_container_type| {
                [
                    "init_container_type".to_string(),
                    init_container_type.to_string(),
                ].join(",")
            }),


            self.init_path.as_ref().map(|init_path| {
                [
                    "init_path".to_string(),
                    init_path.to_string(),
                ].join(",")
            }),

            // Skipping intelRdt in query parameter serialization

            // Skipping ipcns in query parameter serialization


            self.label_nested.as_ref().map(|label_nested| {
                [
                    "label_nested".to_string(),
                    label_nested.to_string(),
                ].join(",")
            }),

            // Skipping labels in query parameter serialization

            // Skipping log_configuration in query parameter serialization


            self.manage_password.as_ref().map(|manage_password| {
                [
                    "manage_password".to_string(),
                    manage_password.to_string(),
                ].join(",")
            }),


            self.mask.as_ref().map(|mask| {
                [
                    "mask".to_string(),
                    mask.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping mounts in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping netns in query parameter serialization

            // Skipping network_options in query parameter serialization
            // Skipping network_options in query parameter serialization


            self.no_new_privileges.as_ref().map(|no_new_privileges| {
                [
                    "no_new_privileges".to_string(),
                    no_new_privileges.to_string(),
                ].join(",")
            }),


            self.oci_runtime.as_ref().map(|oci_runtime| {
                [
                    "oci_runtime".to_string(),
                    oci_runtime.to_string(),
                ].join(",")
            }),


            self.oom_score_adj.as_ref().map(|oom_score_adj| {
                [
                    "oom_score_adj".to_string(),
                    oom_score_adj.to_string(),
                ].join(",")
            }),

            // Skipping overlay_volumes in query parameter serialization


            self.passwd_entry.as_ref().map(|passwd_entry| {
                [
                    "passwd_entry".to_string(),
                    passwd_entry.to_string(),
                ].join(",")
            }),

            // Skipping personality in query parameter serialization

            // Skipping pidns in query parameter serialization


            self.pod.as_ref().map(|pod| {
                [
                    "pod".to_string(),
                    pod.to_string(),
                ].join(",")
            }),

            // Skipping portmappings in query parameter serialization


            self.privileged.as_ref().map(|privileged| {
                [
                    "privileged".to_string(),
                    privileged.to_string(),
                ].join(",")
            }),


            self.procfs_opts.as_ref().map(|procfs_opts| {
                [
                    "procfs_opts".to_string(),
                    procfs_opts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.publish_image_ports.as_ref().map(|publish_image_ports| {
                [
                    "publish_image_ports".to_string(),
                    publish_image_ports.to_string(),
                ].join(",")
            }),

            // Skipping r_limits in query parameter serialization


            self.raw_image_name.as_ref().map(|raw_image_name| {
                [
                    "raw_image_name".to_string(),
                    raw_image_name.to_string(),
                ].join(",")
            }),


            self.read_only_filesystem.as_ref().map(|read_only_filesystem| {
                [
                    "read_only_filesystem".to_string(),
                    read_only_filesystem.to_string(),
                ].join(",")
            }),


            self.read_write_tmpfs.as_ref().map(|read_write_tmpfs| {
                [
                    "read_write_tmpfs".to_string(),
                    read_write_tmpfs.to_string(),
                ].join(",")
            }),


            self.remove.as_ref().map(|remove| {
                [
                    "remove".to_string(),
                    remove.to_string(),
                ].join(",")
            }),

            // Skipping resource_limits in query parameter serialization


            self.restart_policy.as_ref().map(|restart_policy| {
                [
                    "restart_policy".to_string(),
                    restart_policy.to_string(),
                ].join(",")
            }),


            self.restart_tries.as_ref().map(|restart_tries| {
                [
                    "restart_tries".to_string(),
                    restart_tries.to_string(),
                ].join(",")
            }),


            self.rootfs.as_ref().map(|rootfs| {
                [
                    "rootfs".to_string(),
                    rootfs.to_string(),
                ].join(",")
            }),


            self.rootfs_mapping.as_ref().map(|rootfs_mapping| {
                [
                    "rootfs_mapping".to_string(),
                    rootfs_mapping.to_string(),
                ].join(",")
            }),


            self.rootfs_overlay.as_ref().map(|rootfs_overlay| {
                [
                    "rootfs_overlay".to_string(),
                    rootfs_overlay.to_string(),
                ].join(",")
            }),


            self.rootfs_propagation.as_ref().map(|rootfs_propagation| {
                [
                    "rootfs_propagation".to_string(),
                    rootfs_propagation.to_string(),
                ].join(",")
            }),


            self.sdnotify_mode.as_ref().map(|sdnotify_mode| {
                [
                    "sdnotifyMode".to_string(),
                    sdnotify_mode.to_string(),
                ].join(",")
            }),


            self.seccomp_policy.as_ref().map(|seccomp_policy| {
                [
                    "seccomp_policy".to_string(),
                    seccomp_policy.to_string(),
                ].join(",")
            }),


            self.seccomp_profile_path.as_ref().map(|seccomp_profile_path| {
                [
                    "seccomp_profile_path".to_string(),
                    seccomp_profile_path.to_string(),
                ].join(",")
            }),

            // Skipping secret_env in query parameter serialization

            // Skipping secrets in query parameter serialization


            self.selinux_opts.as_ref().map(|selinux_opts| {
                [
                    "selinux_opts".to_string(),
                    selinux_opts.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.shm_size.as_ref().map(|shm_size| {
                [
                    "shm_size".to_string(),
                    shm_size.to_string(),
                ].join(",")
            }),


            self.shm_size_systemd.as_ref().map(|shm_size_systemd| {
                [
                    "shm_size_systemd".to_string(),
                    shm_size_systemd.to_string(),
                ].join(",")
            }),

            // Skipping startupHealthConfig in query parameter serialization


            self.stdin.as_ref().map(|stdin| {
                [
                    "stdin".to_string(),
                    stdin.to_string(),
                ].join(",")
            }),


            self.stop_signal.as_ref().map(|stop_signal| {
                [
                    "stop_signal".to_string(),
                    stop_signal.to_string(),
                ].join(",")
            }),


            self.stop_timeout.as_ref().map(|stop_timeout| {
                [
                    "stop_timeout".to_string(),
                    stop_timeout.to_string(),
                ].join(",")
            }),

            // Skipping storage_opts in query parameter serialization

            // Skipping sysctl in query parameter serialization


            self.systemd.as_ref().map(|systemd| {
                [
                    "systemd".to_string(),
                    systemd.to_string(),
                ].join(",")
            }),


            self.terminal.as_ref().map(|terminal| {
                [
                    "terminal".to_string(),
                    terminal.to_string(),
                ].join(",")
            }),

            // Skipping throttleReadBpsDevice in query parameter serialization
            // Skipping throttleReadBpsDevice in query parameter serialization

            // Skipping throttleReadIOPSDevice in query parameter serialization
            // Skipping throttleReadIOPSDevice in query parameter serialization

            // Skipping throttleWriteBpsDevice in query parameter serialization
            // Skipping throttleWriteBpsDevice in query parameter serialization

            // Skipping throttleWriteIOPSDevice in query parameter serialization
            // Skipping throttleWriteIOPSDevice in query parameter serialization


            self.timeout.as_ref().map(|timeout| {
                [
                    "timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),


            self.timezone.as_ref().map(|timezone| {
                [
                    "timezone".to_string(),
                    timezone.to_string(),
                ].join(",")
            }),


            self.umask.as_ref().map(|umask| {
                [
                    "umask".to_string(),
                    umask.to_string(),
                ].join(",")
            }),

            // Skipping unified in query parameter serialization


            self.unmask.as_ref().map(|unmask| {
                [
                    "unmask".to_string(),
                    unmask.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.unsetenv.as_ref().map(|unsetenv| {
                [
                    "unsetenv".to_string(),
                    unsetenv.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.unsetenvall.as_ref().map(|unsetenvall| {
                [
                    "unsetenvall".to_string(),
                    unsetenvall.to_string(),
                ].join(",")
            }),


            self.use_image_hosts.as_ref().map(|use_image_hosts| {
                [
                    "use_image_hosts".to_string(),
                    use_image_hosts.to_string(),
                ].join(",")
            }),


            self.use_image_resolve_conf.as_ref().map(|use_image_resolve_conf| {
                [
                    "use_image_resolve_conf".to_string(),
                    use_image_resolve_conf.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping userns in query parameter serialization

            // Skipping utsns in query parameter serialization


            self.volatile.as_ref().map(|volatile| {
                [
                    "volatile".to_string(),
                    volatile.to_string(),
                ].join(",")
            }),

            // Skipping volumes in query parameter serialization


            self.volumes_from.as_ref().map(|volumes_from| {
                [
                    "volumes_from".to_string(),
                    volumes_from.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping weightDevice in query parameter serialization
            // Skipping weightDevice in query parameter serialization


            self.work_dir.as_ref().map(|work_dir| {
                [
                    "work_dir".to_string(),
                    work_dir.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SpecGenerator value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SpecGenerator {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub networks: Vec<std::collections::HashMap<String, models::PerNetworkOptions>>,
            pub annotations: Vec<std::collections::HashMap<String, String>>,
            pub apparmor_profile: Vec<String>,
            pub base_hosts_file: Vec<String>,
            pub cap_add: Vec<Vec<String>>,
            pub cap_drop: Vec<Vec<String>>,
            pub cgroup_parent: Vec<String>,
            pub cgroupns: Vec<models::Namespace>,
            pub cgroups_mode: Vec<String>,
            pub chroot_directories: Vec<Vec<String>>,
            pub cni_networks: Vec<Vec<String>>,
            pub command: Vec<Vec<String>>,
            pub conmon_pid_file: Vec<String>,
            pub container_create_command: Vec<Vec<String>>,
            pub create_working_dir: Vec<bool>,
            pub dependency_containers: Vec<Vec<String>>,
            pub device_cgroup_rule: Vec<Vec<models::LinuxDeviceCgroup>>,
            pub devices: Vec<Vec<models::LinuxDevice>>,
            pub devices_from: Vec<Vec<String>>,
            pub dns_option: Vec<Vec<String>>,
            pub dns_search: Vec<Vec<String>>,
            pub dns_server: Vec<Vec<String>>,
            pub entrypoint: Vec<Vec<String>>,
            pub env: Vec<std::collections::HashMap<String, String>>,
            pub env_host: Vec<bool>,
            pub envmerge: Vec<Vec<String>>,
            pub expose: Vec<crate::types::Object>,
            pub group_entry: Vec<String>,
            pub groups: Vec<Vec<String>>,
            pub health_check_on_failure_action: Vec<i64>,
            pub healthconfig: Vec<models::Schema2HealthConfig>,
            pub host_device_list: Vec<Vec<models::LinuxDevice>>,
            pub hostadd: Vec<Vec<String>>,
            pub hostname: Vec<String>,
            pub hostusers: Vec<Vec<String>>,
            pub httpproxy: Vec<bool>,
            pub idmappings: Vec<models::IdMappingOptions>,
            pub image: Vec<String>,
            pub image_arch: Vec<String>,
            pub image_os: Vec<String>,
            pub image_variant: Vec<String>,
            pub image_volume_mode: Vec<String>,
            pub image_volumes: Vec<Vec<models::ImageVolume>>,
            pub init: Vec<bool>,
            pub init_container_type: Vec<String>,
            pub init_path: Vec<String>,
            pub intel_rdt: Vec<models::LinuxIntelRdt>,
            pub ipcns: Vec<models::Namespace>,
            pub label_nested: Vec<bool>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub log_configuration: Vec<models::LogConfigLibpod>,
            pub manage_password: Vec<bool>,
            pub mask: Vec<Vec<String>>,
            pub mounts: Vec<Vec<models::Mount>>,
            pub name: Vec<String>,
            pub netns: Vec<models::Namespace>,
            pub network_options: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub no_new_privileges: Vec<bool>,
            pub oci_runtime: Vec<String>,
            pub oom_score_adj: Vec<i64>,
            pub overlay_volumes: Vec<Vec<models::OverlayVolume>>,
            pub passwd_entry: Vec<String>,
            pub personality: Vec<models::LinuxPersonality>,
            pub pidns: Vec<models::Namespace>,
            pub pod: Vec<String>,
            pub portmappings: Vec<Vec<models::PortMapping>>,
            pub privileged: Vec<bool>,
            pub procfs_opts: Vec<Vec<String>>,
            pub publish_image_ports: Vec<bool>,
            pub r_limits: Vec<Vec<models::PosixRlimit>>,
            pub raw_image_name: Vec<String>,
            pub read_only_filesystem: Vec<bool>,
            pub read_write_tmpfs: Vec<bool>,
            pub remove: Vec<bool>,
            pub resource_limits: Vec<models::LinuxResources>,
            pub restart_policy: Vec<String>,
            pub restart_tries: Vec<i32>,
            pub rootfs: Vec<String>,
            pub rootfs_mapping: Vec<String>,
            pub rootfs_overlay: Vec<bool>,
            pub rootfs_propagation: Vec<String>,
            pub sdnotify_mode: Vec<String>,
            pub seccomp_policy: Vec<String>,
            pub seccomp_profile_path: Vec<String>,
            pub secret_env: Vec<std::collections::HashMap<String, String>>,
            pub secrets: Vec<Vec<models::Secret>>,
            pub selinux_opts: Vec<Vec<String>>,
            pub shm_size: Vec<i64>,
            pub shm_size_systemd: Vec<i64>,
            pub startup_health_config: Vec<models::StartupHealthCheck>,
            pub stdin: Vec<bool>,
            pub stop_signal: Vec<i64>,
            pub stop_timeout: Vec<i32>,
            pub storage_opts: Vec<std::collections::HashMap<String, String>>,
            pub sysctl: Vec<std::collections::HashMap<String, String>>,
            pub systemd: Vec<String>,
            pub terminal: Vec<bool>,
            pub throttle_read_bps_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub throttle_read_iops_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub throttle_write_bps_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub throttle_write_iops_device: Vec<std::collections::HashMap<String, models::LinuxThrottleDevice>>,
            pub timeout: Vec<i32>,
            pub timezone: Vec<String>,
            pub umask: Vec<String>,
            pub unified: Vec<std::collections::HashMap<String, String>>,
            pub unmask: Vec<Vec<String>>,
            pub unsetenv: Vec<Vec<String>>,
            pub unsetenvall: Vec<bool>,
            pub use_image_hosts: Vec<bool>,
            pub use_image_resolve_conf: Vec<bool>,
            pub user: Vec<String>,
            pub userns: Vec<models::Namespace>,
            pub utsns: Vec<models::Namespace>,
            pub volatile: Vec<bool>,
            pub volumes: Vec<Vec<models::NamedVolume>>,
            pub volumes_from: Vec<Vec<String>>,
            pub weight_device: Vec<std::collections::HashMap<String, models::LinuxWeightDevice>>,
            pub work_dir: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SpecGenerator".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "apparmor_profile" => intermediate_rep.apparmor_profile.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "base_hosts_file" => intermediate_rep.base_hosts_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "cap_add" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "cap_drop" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "cgroup_parent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cgroupns" => intermediate_rep.cgroupns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cgroups_mode" => intermediate_rep.cgroups_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "chroot_directories" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "cni_networks" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "command" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "conmon_pid_file" => intermediate_rep.conmon_pid_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "containerCreateCommand" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "create_working_dir" => intermediate_rep.create_working_dir.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "dependencyContainers" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "device_cgroup_rule" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "devices" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "devices_from" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "dns_option" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "dns_search" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "dns_server" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "entrypoint" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "env" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "env_host" => intermediate_rep.env_host.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "envmerge" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "expose" => intermediate_rep.expose.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "group_entry" => intermediate_rep.group_entry.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "groups" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "health_check_on_failure_action" => intermediate_rep.health_check_on_failure_action.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "healthconfig" => intermediate_rep.healthconfig.push(<models::Schema2HealthConfig as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "host_device_list" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "hostadd" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hostname" => intermediate_rep.hostname.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hostusers" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "httpproxy" => intermediate_rep.httpproxy.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "idmappings" => intermediate_rep.idmappings.push(<models::IdMappingOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_arch" => intermediate_rep.image_arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_os" => intermediate_rep.image_os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_variant" => intermediate_rep.image_variant.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_volume_mode" => intermediate_rep.image_volume_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "image_volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "init" => intermediate_rep.init.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "init_container_type" => intermediate_rep.init_container_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "init_path" => intermediate_rep.init_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "intelRdt" => intermediate_rep.intel_rdt.push(<models::LinuxIntelRdt as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ipcns" => intermediate_rep.ipcns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "label_nested" => intermediate_rep.label_nested.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "labels" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "log_configuration" => intermediate_rep.log_configuration.push(<models::LogConfigLibpod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "manage_password" => intermediate_rep.manage_password.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "mask" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "mounts" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "netns" => intermediate_rep.netns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "network_options" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "no_new_privileges" => intermediate_rep.no_new_privileges.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oci_runtime" => intermediate_rep.oci_runtime.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "oom_score_adj" => intermediate_rep.oom_score_adj.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "overlay_volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "passwd_entry" => intermediate_rep.passwd_entry.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "personality" => intermediate_rep.personality.push(<models::LinuxPersonality as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pidns" => intermediate_rep.pidns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pod" => intermediate_rep.pod.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "portmappings" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "privileged" => intermediate_rep.privileged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "procfs_opts" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "publish_image_ports" => intermediate_rep.publish_image_ports.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "r_limits" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "raw_image_name" => intermediate_rep.raw_image_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "read_only_filesystem" => intermediate_rep.read_only_filesystem.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "read_write_tmpfs" => intermediate_rep.read_write_tmpfs.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "remove" => intermediate_rep.remove.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "resource_limits" => intermediate_rep.resource_limits.push(<models::LinuxResources as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "restart_policy" => intermediate_rep.restart_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "restart_tries" => intermediate_rep.restart_tries.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs" => intermediate_rep.rootfs.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs_mapping" => intermediate_rep.rootfs_mapping.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs_overlay" => intermediate_rep.rootfs_overlay.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rootfs_propagation" => intermediate_rep.rootfs_propagation.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sdnotifyMode" => intermediate_rep.sdnotify_mode.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seccomp_policy" => intermediate_rep.seccomp_policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seccomp_profile_path" => intermediate_rep.seccomp_profile_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "secret_env" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "secrets" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "selinux_opts" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "shm_size" => intermediate_rep.shm_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shm_size_systemd" => intermediate_rep.shm_size_systemd.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "startupHealthConfig" => intermediate_rep.startup_health_config.push(<models::StartupHealthCheck as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stdin" => intermediate_rep.stdin.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stop_signal" => intermediate_rep.stop_signal.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stop_timeout" => intermediate_rep.stop_timeout.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "storage_opts" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "sysctl" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "systemd" => intermediate_rep.systemd.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "terminal" => intermediate_rep.terminal.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "throttleReadBpsDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "throttleReadIOPSDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "throttleWriteBpsDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "throttleWriteIOPSDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "timeout" => intermediate_rep.timeout.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "timezone" => intermediate_rep.timezone.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "umask" => intermediate_rep.umask.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "unified" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "unmask" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "unsetenv" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "unsetenvall" => intermediate_rep.unsetenvall.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "use_image_hosts" => intermediate_rep.use_image_hosts.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "use_image_resolve_conf" => intermediate_rep.use_image_resolve_conf.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "userns" => intermediate_rep.userns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "utsns" => intermediate_rep.utsns.push(<models::Namespace as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volatile" => intermediate_rep.volatile.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "volumes_from" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    "weightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in SpecGenerator".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "work_dir" => intermediate_rep.work_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SpecGenerator".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SpecGenerator {
            networks: intermediate_rep.networks.into_iter().next(),
            annotations: intermediate_rep.annotations.into_iter().next(),
            apparmor_profile: intermediate_rep.apparmor_profile.into_iter().next(),
            base_hosts_file: intermediate_rep.base_hosts_file.into_iter().next(),
            cap_add: intermediate_rep.cap_add.into_iter().next(),
            cap_drop: intermediate_rep.cap_drop.into_iter().next(),
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cgroupns: intermediate_rep.cgroupns.into_iter().next(),
            cgroups_mode: intermediate_rep.cgroups_mode.into_iter().next(),
            chroot_directories: intermediate_rep.chroot_directories.into_iter().next(),
            cni_networks: intermediate_rep.cni_networks.into_iter().next(),
            command: intermediate_rep.command.into_iter().next(),
            conmon_pid_file: intermediate_rep.conmon_pid_file.into_iter().next(),
            container_create_command: intermediate_rep.container_create_command.into_iter().next(),
            create_working_dir: intermediate_rep.create_working_dir.into_iter().next(),
            dependency_containers: intermediate_rep.dependency_containers.into_iter().next(),
            device_cgroup_rule: intermediate_rep.device_cgroup_rule.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            devices_from: intermediate_rep.devices_from.into_iter().next(),
            dns_option: intermediate_rep.dns_option.into_iter().next(),
            dns_search: intermediate_rep.dns_search.into_iter().next(),
            dns_server: intermediate_rep.dns_server.into_iter().next(),
            entrypoint: intermediate_rep.entrypoint.into_iter().next(),
            env: intermediate_rep.env.into_iter().next(),
            env_host: intermediate_rep.env_host.into_iter().next(),
            envmerge: intermediate_rep.envmerge.into_iter().next(),
            expose: intermediate_rep.expose.into_iter().next(),
            group_entry: intermediate_rep.group_entry.into_iter().next(),
            groups: intermediate_rep.groups.into_iter().next(),
            health_check_on_failure_action: intermediate_rep.health_check_on_failure_action.into_iter().next(),
            healthconfig: intermediate_rep.healthconfig.into_iter().next(),
            host_device_list: intermediate_rep.host_device_list.into_iter().next(),
            hostadd: intermediate_rep.hostadd.into_iter().next(),
            hostname: intermediate_rep.hostname.into_iter().next(),
            hostusers: intermediate_rep.hostusers.into_iter().next(),
            httpproxy: intermediate_rep.httpproxy.into_iter().next(),
            idmappings: intermediate_rep.idmappings.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            image_arch: intermediate_rep.image_arch.into_iter().next(),
            image_os: intermediate_rep.image_os.into_iter().next(),
            image_variant: intermediate_rep.image_variant.into_iter().next(),
            image_volume_mode: intermediate_rep.image_volume_mode.into_iter().next(),
            image_volumes: intermediate_rep.image_volumes.into_iter().next(),
            init: intermediate_rep.init.into_iter().next(),
            init_container_type: intermediate_rep.init_container_type.into_iter().next(),
            init_path: intermediate_rep.init_path.into_iter().next(),
            intel_rdt: intermediate_rep.intel_rdt.into_iter().next(),
            ipcns: intermediate_rep.ipcns.into_iter().next(),
            label_nested: intermediate_rep.label_nested.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            log_configuration: intermediate_rep.log_configuration.into_iter().next(),
            manage_password: intermediate_rep.manage_password.into_iter().next(),
            mask: intermediate_rep.mask.into_iter().next(),
            mounts: intermediate_rep.mounts.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            netns: intermediate_rep.netns.into_iter().next(),
            network_options: intermediate_rep.network_options.into_iter().next(),
            no_new_privileges: intermediate_rep.no_new_privileges.into_iter().next(),
            oci_runtime: intermediate_rep.oci_runtime.into_iter().next(),
            oom_score_adj: intermediate_rep.oom_score_adj.into_iter().next(),
            overlay_volumes: intermediate_rep.overlay_volumes.into_iter().next(),
            passwd_entry: intermediate_rep.passwd_entry.into_iter().next(),
            personality: intermediate_rep.personality.into_iter().next(),
            pidns: intermediate_rep.pidns.into_iter().next(),
            pod: intermediate_rep.pod.into_iter().next(),
            portmappings: intermediate_rep.portmappings.into_iter().next(),
            privileged: intermediate_rep.privileged.into_iter().next(),
            procfs_opts: intermediate_rep.procfs_opts.into_iter().next(),
            publish_image_ports: intermediate_rep.publish_image_ports.into_iter().next(),
            r_limits: intermediate_rep.r_limits.into_iter().next(),
            raw_image_name: intermediate_rep.raw_image_name.into_iter().next(),
            read_only_filesystem: intermediate_rep.read_only_filesystem.into_iter().next(),
            read_write_tmpfs: intermediate_rep.read_write_tmpfs.into_iter().next(),
            remove: intermediate_rep.remove.into_iter().next(),
            resource_limits: intermediate_rep.resource_limits.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            restart_tries: intermediate_rep.restart_tries.into_iter().next(),
            rootfs: intermediate_rep.rootfs.into_iter().next(),
            rootfs_mapping: intermediate_rep.rootfs_mapping.into_iter().next(),
            rootfs_overlay: intermediate_rep.rootfs_overlay.into_iter().next(),
            rootfs_propagation: intermediate_rep.rootfs_propagation.into_iter().next(),
            sdnotify_mode: intermediate_rep.sdnotify_mode.into_iter().next(),
            seccomp_policy: intermediate_rep.seccomp_policy.into_iter().next(),
            seccomp_profile_path: intermediate_rep.seccomp_profile_path.into_iter().next(),
            secret_env: intermediate_rep.secret_env.into_iter().next(),
            secrets: intermediate_rep.secrets.into_iter().next(),
            selinux_opts: intermediate_rep.selinux_opts.into_iter().next(),
            shm_size: intermediate_rep.shm_size.into_iter().next(),
            shm_size_systemd: intermediate_rep.shm_size_systemd.into_iter().next(),
            startup_health_config: intermediate_rep.startup_health_config.into_iter().next(),
            stdin: intermediate_rep.stdin.into_iter().next(),
            stop_signal: intermediate_rep.stop_signal.into_iter().next(),
            stop_timeout: intermediate_rep.stop_timeout.into_iter().next(),
            storage_opts: intermediate_rep.storage_opts.into_iter().next(),
            sysctl: intermediate_rep.sysctl.into_iter().next(),
            systemd: intermediate_rep.systemd.into_iter().next(),
            terminal: intermediate_rep.terminal.into_iter().next(),
            throttle_read_bps_device: intermediate_rep.throttle_read_bps_device.into_iter().next(),
            throttle_read_iops_device: intermediate_rep.throttle_read_iops_device.into_iter().next(),
            throttle_write_bps_device: intermediate_rep.throttle_write_bps_device.into_iter().next(),
            throttle_write_iops_device: intermediate_rep.throttle_write_iops_device.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
            timezone: intermediate_rep.timezone.into_iter().next(),
            umask: intermediate_rep.umask.into_iter().next(),
            unified: intermediate_rep.unified.into_iter().next(),
            unmask: intermediate_rep.unmask.into_iter().next(),
            unsetenv: intermediate_rep.unsetenv.into_iter().next(),
            unsetenvall: intermediate_rep.unsetenvall.into_iter().next(),
            use_image_hosts: intermediate_rep.use_image_hosts.into_iter().next(),
            use_image_resolve_conf: intermediate_rep.use_image_resolve_conf.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            userns: intermediate_rep.userns.into_iter().next(),
            utsns: intermediate_rep.utsns.into_iter().next(),
            volatile: intermediate_rep.volatile.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
            volumes_from: intermediate_rep.volumes_from.into_iter().next(),
            weight_device: intermediate_rep.weight_device.into_iter().next(),
            work_dir: intermediate_rep.work_dir.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SpecGenerator> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SpecGenerator>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SpecGenerator>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SpecGenerator - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SpecGenerator> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SpecGenerator as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SpecGenerator - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StartupHealthCheck {
/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "Interval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub interval: Option<i64>,

/// Retries is the number of consecutive failures needed to consider a container as unhealthy. Zero means inherit.
    #[serde(rename = "Retries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retries: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "StartInterval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_interval: Option<i64>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "StartPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_period: Option<i64>,

/// Successes are the number of successes required to mark the startup HC as passed. If set to 0, a single success will mark the HC as passed.
    #[serde(rename = "Successes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub successes: Option<i64>,

/// Test is the test to perform to check that the container is healthy. An empty slice means to inherit the default. The options are: {} : inherit healthcheck {\"NONE\"} : disable healthcheck {\"CMD\", args...} : exec arguments directly {\"CMD-SHELL\", command} : run command with system's default shell
    #[serde(rename = "Test")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub test: Option<Vec<String>>,

/// A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
    #[serde(rename = "Timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i64>,

}


impl StartupHealthCheck {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> StartupHealthCheck {
        StartupHealthCheck {
            interval: None,
            retries: None,
            start_interval: None,
            start_period: None,
            successes: None,
            test: None,
            timeout: None,
        }
    }
}

/// Converts the StartupHealthCheck value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StartupHealthCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.interval.as_ref().map(|interval| {
                [
                    "Interval".to_string(),
                    interval.to_string(),
                ].join(",")
            }),


            self.retries.as_ref().map(|retries| {
                [
                    "Retries".to_string(),
                    retries.to_string(),
                ].join(",")
            }),


            self.start_interval.as_ref().map(|start_interval| {
                [
                    "StartInterval".to_string(),
                    start_interval.to_string(),
                ].join(",")
            }),


            self.start_period.as_ref().map(|start_period| {
                [
                    "StartPeriod".to_string(),
                    start_period.to_string(),
                ].join(",")
            }),


            self.successes.as_ref().map(|successes| {
                [
                    "Successes".to_string(),
                    successes.to_string(),
                ].join(",")
            }),


            self.test.as_ref().map(|test| {
                [
                    "Test".to_string(),
                    test.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "Timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StartupHealthCheck value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StartupHealthCheck {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub interval: Vec<i64>,
            pub retries: Vec<i64>,
            pub start_interval: Vec<i64>,
            pub start_period: Vec<i64>,
            pub successes: Vec<i64>,
            pub test: Vec<Vec<String>>,
            pub timeout: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StartupHealthCheck".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Interval" => intermediate_rep.interval.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Retries" => intermediate_rep.retries.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartInterval" => intermediate_rep.start_interval.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StartPeriod" => intermediate_rep.start_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Successes" => intermediate_rep.successes.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Test" => return std::result::Result::Err("Parsing a container in this style is not supported in StartupHealthCheck".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Timeout" => intermediate_rep.timeout.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StartupHealthCheck".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StartupHealthCheck {
            interval: intermediate_rep.interval.into_iter().next(),
            retries: intermediate_rep.retries.into_iter().next(),
            start_interval: intermediate_rep.start_interval.into_iter().next(),
            start_period: intermediate_rep.start_period.into_iter().next(),
            successes: intermediate_rep.successes.into_iter().next(),
            test: intermediate_rep.test.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StartupHealthCheck> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StartupHealthCheck>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StartupHealthCheck>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for StartupHealthCheck - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StartupHealthCheck> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StartupHealthCheck as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into StartupHealthCheck - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// StoreInfo describes the container storage and its attributes



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StoreInfo {
    #[serde(rename = "configFile")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub config_file: Option<String>,

    #[serde(rename = "containerStore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_store: Option<models::ContainerStore>,

    #[serde(rename = "graphDriverName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_driver_name: Option<String>,

    #[serde(rename = "graphOptions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_options: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "graphRoot")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_root: Option<String>,

/// GraphRootAllocated is how much space the graphroot has in bytes
    #[serde(rename = "graphRootAllocated")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_root_allocated: Option<i32>,

/// GraphRootUsed is how much of graphroot is used in bytes
    #[serde(rename = "graphRootUsed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_root_used: Option<i32>,

    #[serde(rename = "graphStatus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub graph_status: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "imageCopyTmpDir")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_copy_tmp_dir: Option<String>,

    #[serde(rename = "imageStore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_store: Option<models::ImageStore>,

    #[serde(rename = "runRoot")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_root: Option<String>,

    #[serde(rename = "transientStore")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transient_store: Option<bool>,

    #[serde(rename = "volumePath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_path: Option<String>,

}


impl StoreInfo {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> StoreInfo {
        StoreInfo {
            config_file: None,
            container_store: None,
            graph_driver_name: None,
            graph_options: None,
            graph_root: None,
            graph_root_allocated: None,
            graph_root_used: None,
            graph_status: None,
            image_copy_tmp_dir: None,
            image_store: None,
            run_root: None,
            transient_store: None,
            volume_path: None,
        }
    }
}

/// Converts the StoreInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StoreInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.config_file.as_ref().map(|config_file| {
                [
                    "configFile".to_string(),
                    config_file.to_string(),
                ].join(",")
            }),

            // Skipping containerStore in query parameter serialization


            self.graph_driver_name.as_ref().map(|graph_driver_name| {
                [
                    "graphDriverName".to_string(),
                    graph_driver_name.to_string(),
                ].join(",")
            }),

            // Skipping graphOptions in query parameter serialization
            // Skipping graphOptions in query parameter serialization


            self.graph_root.as_ref().map(|graph_root| {
                [
                    "graphRoot".to_string(),
                    graph_root.to_string(),
                ].join(",")
            }),


            self.graph_root_allocated.as_ref().map(|graph_root_allocated| {
                [
                    "graphRootAllocated".to_string(),
                    graph_root_allocated.to_string(),
                ].join(",")
            }),


            self.graph_root_used.as_ref().map(|graph_root_used| {
                [
                    "graphRootUsed".to_string(),
                    graph_root_used.to_string(),
                ].join(",")
            }),

            // Skipping graphStatus in query parameter serialization


            self.image_copy_tmp_dir.as_ref().map(|image_copy_tmp_dir| {
                [
                    "imageCopyTmpDir".to_string(),
                    image_copy_tmp_dir.to_string(),
                ].join(",")
            }),

            // Skipping imageStore in query parameter serialization


            self.run_root.as_ref().map(|run_root| {
                [
                    "runRoot".to_string(),
                    run_root.to_string(),
                ].join(",")
            }),


            self.transient_store.as_ref().map(|transient_store| {
                [
                    "transientStore".to_string(),
                    transient_store.to_string(),
                ].join(",")
            }),


            self.volume_path.as_ref().map(|volume_path| {
                [
                    "volumePath".to_string(),
                    volume_path.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StoreInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StoreInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub config_file: Vec<String>,
            pub container_store: Vec<models::ContainerStore>,
            pub graph_driver_name: Vec<String>,
            pub graph_options: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub graph_root: Vec<String>,
            pub graph_root_allocated: Vec<i32>,
            pub graph_root_used: Vec<i32>,
            pub graph_status: Vec<std::collections::HashMap<String, String>>,
            pub image_copy_tmp_dir: Vec<String>,
            pub image_store: Vec<models::ImageStore>,
            pub run_root: Vec<String>,
            pub transient_store: Vec<bool>,
            pub volume_path: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StoreInfo".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "configFile" => intermediate_rep.config_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "containerStore" => intermediate_rep.container_store.push(<models::ContainerStore as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "graphDriverName" => intermediate_rep.graph_driver_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "graphOptions" => return std::result::Result::Err("Parsing a container in this style is not supported in StoreInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "graphRoot" => intermediate_rep.graph_root.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "graphRootAllocated" => intermediate_rep.graph_root_allocated.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "graphRootUsed" => intermediate_rep.graph_root_used.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "graphStatus" => return std::result::Result::Err("Parsing a container in this style is not supported in StoreInfo".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "imageCopyTmpDir" => intermediate_rep.image_copy_tmp_dir.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "imageStore" => intermediate_rep.image_store.push(<models::ImageStore as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "runRoot" => intermediate_rep.run_root.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transientStore" => intermediate_rep.transient_store.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "volumePath" => intermediate_rep.volume_path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StoreInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StoreInfo {
            config_file: intermediate_rep.config_file.into_iter().next(),
            container_store: intermediate_rep.container_store.into_iter().next(),
            graph_driver_name: intermediate_rep.graph_driver_name.into_iter().next(),
            graph_options: intermediate_rep.graph_options.into_iter().next(),
            graph_root: intermediate_rep.graph_root.into_iter().next(),
            graph_root_allocated: intermediate_rep.graph_root_allocated.into_iter().next(),
            graph_root_used: intermediate_rep.graph_root_used.into_iter().next(),
            graph_status: intermediate_rep.graph_status.into_iter().next(),
            image_copy_tmp_dir: intermediate_rep.image_copy_tmp_dir.into_iter().next(),
            image_store: intermediate_rep.image_store.into_iter().next(),
            run_root: intermediate_rep.run_root.into_iter().next(),
            transient_store: intermediate_rep.transient_store.into_iter().next(),
            volume_path: intermediate_rep.volume_path.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StoreInfo> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StoreInfo>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StoreInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for StoreInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StoreInfo> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StoreInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into StoreInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Subnet {
/// Gateway IP for this Network.
    #[serde(rename = "gateway")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gateway: Option<String>,

    #[serde(rename = "lease_range")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lease_range: Option<models::LeaseRange>,

/// Subnet for this Network in CIDR form.
    #[serde(rename = "subnet")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subnet: Option<String>,

}


impl Subnet {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Subnet {
        Subnet {
            gateway: None,
            lease_range: None,
            subnet: None,
        }
    }
}

/// Converts the Subnet value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Subnet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.gateway.as_ref().map(|gateway| {
                [
                    "gateway".to_string(),
                    gateway.to_string(),
                ].join(",")
            }),

            // Skipping lease_range in query parameter serialization


            self.subnet.as_ref().map(|subnet| {
                [
                    "subnet".to_string(),
                    subnet.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Subnet value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Subnet {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gateway: Vec<String>,
            pub lease_range: Vec<models::LeaseRange>,
            pub subnet: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Subnet".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "gateway" => intermediate_rep.gateway.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lease_range" => intermediate_rep.lease_range.push(<models::LeaseRange as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "subnet" => intermediate_rep.subnet.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Subnet".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Subnet {
            gateway: intermediate_rep.gateway.into_iter().next(),
            lease_range: intermediate_rep.lease_range.into_iter().next(),
            subnet: intermediate_rep.subnet.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Subnet> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Subnet>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Subnet>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Subnet - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Subnet> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Subnet as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Subnet - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Summary summary



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Summary {
/// Number of containers using this image. Includes both stopped and running containers.  This size is not calculated by default, and depends on which API endpoint is used. `-1` indicates that the value has not been set / calculated.
    #[serde(rename = "Containers")]
    pub containers: i64,

/// Date and time at which the image was created as a Unix timestamp (number of seconds sinds EPOCH).
    #[serde(rename = "Created")]
    pub created: i64,

/// ID is the content-addressable ID of an image.  This identifier is a content-addressable digest calculated from the image's configuration (which includes the digests of layers used by the image).  Note that this digest differs from the `RepoDigests` below, which holds digests of image manifests that reference the image.
    #[serde(rename = "Id")]
    pub id: String,

/// User-defined key/value metadata.
    #[serde(rename = "Labels")]
    pub labels: std::collections::HashMap<String, String>,

/// ID of the parent image.  Depending on how the image was created, this field may be empty and is only set for images that were built/created locally. This field is empty if the image was pulled from an image registry.
    #[serde(rename = "ParentId")]
    pub parent_id: String,

/// List of content-addressable digests of locally available image manifests that the image is referenced from. Multiple manifests can refer to the same image.  These digests are usually only available if the image was either pulled from a registry, or if the image was pushed to a registry, which is when the manifest is generated and its digest calculated.
    #[serde(rename = "RepoDigests")]
    pub repo_digests: Vec<String>,

/// List of image names/tags in the local image cache that reference this image.  Multiple image tags can refer to the same image, and this list may be empty if no tags reference the image, in which case the image is \"untagged\", in which case it can still be referenced by its ID.
    #[serde(rename = "RepoTags")]
    pub repo_tags: Vec<String>,

/// Total size of image layers that are shared between this image and other images.  This size is not calculated by default. `-1` indicates that the value has not been set / calculated.
    #[serde(rename = "SharedSize")]
    pub shared_size: i64,

/// Total size of the image including all layers it is composed of.
    #[serde(rename = "Size")]
    pub size: i64,

/// Total size of the image including all layers it is composed of.  Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
    #[serde(rename = "VirtualSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub virtual_size: Option<i64>,

}


impl Summary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(containers: i64, created: i64, id: String, labels: std::collections::HashMap<String, String>, parent_id: String, repo_digests: Vec<String>, repo_tags: Vec<String>, shared_size: i64, size: i64, ) -> Summary {
        Summary {
            containers,
            created,
            id,
            labels,
            parent_id,
            repo_digests,
            repo_tags,
            shared_size,
            size,
            virtual_size: None,
        }
    }
}

/// Converts the Summary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Summary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Containers".to_string()),
            Some(self.containers.to_string()),


            Some("Created".to_string()),
            Some(self.created.to_string()),


            Some("Id".to_string()),
            Some(self.id.to_string()),

            // Skipping Labels in query parameter serialization


            Some("ParentId".to_string()),
            Some(self.parent_id.to_string()),


            Some("RepoDigests".to_string()),
            Some(self.repo_digests.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("RepoTags".to_string()),
            Some(self.repo_tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("SharedSize".to_string()),
            Some(self.shared_size.to_string()),


            Some("Size".to_string()),
            Some(self.size.to_string()),


            self.virtual_size.as_ref().map(|virtual_size| {
                [
                    "VirtualSize".to_string(),
                    virtual_size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Summary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Summary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub containers: Vec<i64>,
            pub created: Vec<i64>,
            pub id: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub parent_id: Vec<String>,
            pub repo_digests: Vec<Vec<String>>,
            pub repo_tags: Vec<Vec<String>>,
            pub shared_size: Vec<i64>,
            pub size: Vec<i64>,
            pub virtual_size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Summary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Containers" => intermediate_rep.containers.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in Summary".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ParentId" => intermediate_rep.parent_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "RepoDigests" => return std::result::Result::Err("Parsing a container in this style is not supported in Summary".to_string()),
                    "RepoTags" => return std::result::Result::Err("Parsing a container in this style is not supported in Summary".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "SharedSize" => intermediate_rep.shared_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VirtualSize" => intermediate_rep.virtual_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Summary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Summary {
            containers: intermediate_rep.containers.into_iter().next().ok_or_else(|| "Containers missing in Summary".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "Created missing in Summary".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "Id missing in Summary".to_string())?,
            labels: intermediate_rep.labels.into_iter().next().ok_or_else(|| "Labels missing in Summary".to_string())?,
            parent_id: intermediate_rep.parent_id.into_iter().next().ok_or_else(|| "ParentId missing in Summary".to_string())?,
            repo_digests: intermediate_rep.repo_digests.into_iter().next().ok_or_else(|| "RepoDigests missing in Summary".to_string())?,
            repo_tags: intermediate_rep.repo_tags.into_iter().next().ok_or_else(|| "RepoTags missing in Summary".to_string())?,
            shared_size: intermediate_rep.shared_size.into_iter().next().ok_or_else(|| "SharedSize missing in Summary".to_string())?,
            size: intermediate_rep.size.into_iter().next().ok_or_else(|| "Size missing in Summary".to_string())?,
            virtual_size: intermediate_rep.virtual_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Summary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Summary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Summary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Summary - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Summary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Summary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Summary - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SummaryNetworkSettings provides a summary of container's networks in /containers/json



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SummaryNetworkSettings {
    #[serde(rename = "Networks")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub networks: Option<std::collections::HashMap<String, models::EndpointSettings>>,

}


impl SummaryNetworkSettings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SummaryNetworkSettings {
        SummaryNetworkSettings {
            networks: None,
        }
    }
}

/// Converts the SummaryNetworkSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SummaryNetworkSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Networks in query parameter serialization
            // Skipping Networks in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SummaryNetworkSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SummaryNetworkSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub networks: Vec<std::collections::HashMap<String, models::EndpointSettings>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SummaryNetworkSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Networks" => return std::result::Result::Err("Parsing a container in this style is not supported in SummaryNetworkSettings".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SummaryNetworkSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SummaryNetworkSettings {
            networks: intermediate_rep.networks.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SummaryNetworkSettings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SummaryNetworkSettings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SummaryNetworkSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SummaryNetworkSettings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SummaryNetworkSettings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SummaryNetworkSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SummaryNetworkSettings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SystemCheckReport provides a report of what a storage consistency check found, and if we removed anything that was damaged, what we removed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SystemCheckReport {
    #[serde(rename = "Containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<std::collections::HashMap<String, Vec<String>>>,

    #[serde(rename = "Errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<bool>,

    #[serde(rename = "Images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<std::collections::HashMap<String, Vec<String>>>,

    #[serde(rename = "Layers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub layers: Option<std::collections::HashMap<String, Vec<String>>>,

    #[serde(rename = "ROImages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ro_images: Option<std::collections::HashMap<String, Vec<String>>>,

    #[serde(rename = "ROLayers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ro_layers: Option<std::collections::HashMap<String, Vec<String>>>,

    #[serde(rename = "RemovedContainers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub removed_containers: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "RemovedImages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub removed_images: Option<std::collections::HashMap<String, Vec<String>>>,

    #[serde(rename = "RemovedLayers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub removed_layers: Option<Vec<String>>,

}


impl SystemCheckReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SystemCheckReport {
        SystemCheckReport {
            containers: None,
            errors: None,
            images: None,
            layers: None,
            ro_images: None,
            ro_layers: None,
            removed_containers: None,
            removed_images: None,
            removed_layers: None,
        }
    }
}

/// Converts the SystemCheckReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SystemCheckReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Containers in query parameter serialization
            // Skipping Containers in query parameter serialization


            self.errors.as_ref().map(|errors| {
                [
                    "Errors".to_string(),
                    errors.to_string(),
                ].join(",")
            }),

            // Skipping Images in query parameter serialization
            // Skipping Images in query parameter serialization

            // Skipping Layers in query parameter serialization
            // Skipping Layers in query parameter serialization

            // Skipping ROImages in query parameter serialization
            // Skipping ROImages in query parameter serialization

            // Skipping ROLayers in query parameter serialization
            // Skipping ROLayers in query parameter serialization

            // Skipping RemovedContainers in query parameter serialization

            // Skipping RemovedImages in query parameter serialization
            // Skipping RemovedImages in query parameter serialization


            self.removed_layers.as_ref().map(|removed_layers| {
                [
                    "RemovedLayers".to_string(),
                    removed_layers.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SystemCheckReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SystemCheckReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub containers: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub errors: Vec<bool>,
            pub images: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub layers: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub ro_images: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub ro_layers: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub removed_containers: Vec<std::collections::HashMap<String, String>>,
            pub removed_images: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub removed_layers: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SystemCheckReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Containers" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemCheckReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Errors" => intermediate_rep.errors.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Images" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemCheckReport".to_string()),
                    "Layers" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemCheckReport".to_string()),
                    "ROImages" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemCheckReport".to_string()),
                    "ROLayers" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemCheckReport".to_string()),
                    "RemovedContainers" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemCheckReport".to_string()),
                    "RemovedImages" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemCheckReport".to_string()),
                    "RemovedLayers" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemCheckReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SystemCheckReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SystemCheckReport {
            containers: intermediate_rep.containers.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
            images: intermediate_rep.images.into_iter().next(),
            layers: intermediate_rep.layers.into_iter().next(),
            ro_images: intermediate_rep.ro_images.into_iter().next(),
            ro_layers: intermediate_rep.ro_layers.into_iter().next(),
            removed_containers: intermediate_rep.removed_containers.into_iter().next(),
            removed_images: intermediate_rep.removed_images.into_iter().next(),
            removed_layers: intermediate_rep.removed_layers.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SystemCheckReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SystemCheckReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SystemCheckReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SystemCheckReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SystemCheckReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SystemCheckReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SystemCheckReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SystemComponentVersion is the type used by pkg/domain/entities



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SystemComponentVersion {
    #[serde(rename = "ApiVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_version: Option<String>,

    #[serde(rename = "Arch")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arch: Option<String>,

    #[serde(rename = "BuildTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub build_time: Option<String>,

    #[serde(rename = "Components")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub components: Option<Vec<models::ComponentVersion>>,

    #[serde(rename = "Experimental")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub experimental: Option<bool>,

    #[serde(rename = "GitCommit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commit: Option<String>,

    #[serde(rename = "GoVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub go_version: Option<String>,

    #[serde(rename = "KernelVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_version: Option<String>,

    #[serde(rename = "MinAPIVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_api_version: Option<String>,

    #[serde(rename = "Os")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,

    #[serde(rename = "Platform")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<models::SystemComponentVersionPlatform>,

    #[serde(rename = "Version")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,

}


impl SystemComponentVersion {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SystemComponentVersion {
        SystemComponentVersion {
            api_version: None,
            arch: None,
            build_time: None,
            components: None,
            experimental: None,
            git_commit: None,
            go_version: None,
            kernel_version: None,
            min_api_version: None,
            os: None,
            platform: None,
            version: None,
        }
    }
}

/// Converts the SystemComponentVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SystemComponentVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.api_version.as_ref().map(|api_version| {
                [
                    "ApiVersion".to_string(),
                    api_version.to_string(),
                ].join(",")
            }),


            self.arch.as_ref().map(|arch| {
                [
                    "Arch".to_string(),
                    arch.to_string(),
                ].join(",")
            }),


            self.build_time.as_ref().map(|build_time| {
                [
                    "BuildTime".to_string(),
                    build_time.to_string(),
                ].join(",")
            }),

            // Skipping Components in query parameter serialization


            self.experimental.as_ref().map(|experimental| {
                [
                    "Experimental".to_string(),
                    experimental.to_string(),
                ].join(",")
            }),


            self.git_commit.as_ref().map(|git_commit| {
                [
                    "GitCommit".to_string(),
                    git_commit.to_string(),
                ].join(",")
            }),


            self.go_version.as_ref().map(|go_version| {
                [
                    "GoVersion".to_string(),
                    go_version.to_string(),
                ].join(",")
            }),


            self.kernel_version.as_ref().map(|kernel_version| {
                [
                    "KernelVersion".to_string(),
                    kernel_version.to_string(),
                ].join(",")
            }),


            self.min_api_version.as_ref().map(|min_api_version| {
                [
                    "MinAPIVersion".to_string(),
                    min_api_version.to_string(),
                ].join(",")
            }),


            self.os.as_ref().map(|os| {
                [
                    "Os".to_string(),
                    os.to_string(),
                ].join(",")
            }),

            // Skipping Platform in query parameter serialization


            self.version.as_ref().map(|version| {
                [
                    "Version".to_string(),
                    version.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SystemComponentVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SystemComponentVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub api_version: Vec<String>,
            pub arch: Vec<String>,
            pub build_time: Vec<String>,
            pub components: Vec<Vec<models::ComponentVersion>>,
            pub experimental: Vec<bool>,
            pub git_commit: Vec<String>,
            pub go_version: Vec<String>,
            pub kernel_version: Vec<String>,
            pub min_api_version: Vec<String>,
            pub os: Vec<String>,
            pub platform: Vec<models::SystemComponentVersionPlatform>,
            pub version: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SystemComponentVersion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ApiVersion" => intermediate_rep.api_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Arch" => intermediate_rep.arch.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "BuildTime" => intermediate_rep.build_time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Components" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemComponentVersion".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Experimental" => intermediate_rep.experimental.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GitCommit" => intermediate_rep.git_commit.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GoVersion" => intermediate_rep.go_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelVersion" => intermediate_rep.kernel_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MinAPIVersion" => intermediate_rep.min_api_version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Os" => intermediate_rep.os.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Platform" => intermediate_rep.platform.push(<models::SystemComponentVersionPlatform as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Version" => intermediate_rep.version.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SystemComponentVersion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SystemComponentVersion {
            api_version: intermediate_rep.api_version.into_iter().next(),
            arch: intermediate_rep.arch.into_iter().next(),
            build_time: intermediate_rep.build_time.into_iter().next(),
            components: intermediate_rep.components.into_iter().next(),
            experimental: intermediate_rep.experimental.into_iter().next(),
            git_commit: intermediate_rep.git_commit.into_iter().next(),
            go_version: intermediate_rep.go_version.into_iter().next(),
            kernel_version: intermediate_rep.kernel_version.into_iter().next(),
            min_api_version: intermediate_rep.min_api_version.into_iter().next(),
            os: intermediate_rep.os.into_iter().next(),
            platform: intermediate_rep.platform.into_iter().next(),
            version: intermediate_rep.version.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SystemComponentVersion> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SystemComponentVersion>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SystemComponentVersion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SystemComponentVersion - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SystemComponentVersion> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SystemComponentVersion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SystemComponentVersion - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SystemComponentVersionPlatform {
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl SystemComponentVersionPlatform {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SystemComponentVersionPlatform {
        SystemComponentVersionPlatform {
            name: None,
        }
    }
}

/// Converts the SystemComponentVersionPlatform value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SystemComponentVersionPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SystemComponentVersionPlatform value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SystemComponentVersionPlatform {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SystemComponentVersionPlatform".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SystemComponentVersionPlatform".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SystemComponentVersionPlatform {
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SystemComponentVersionPlatform> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SystemComponentVersionPlatform>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SystemComponentVersionPlatform>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SystemComponentVersionPlatform - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SystemComponentVersionPlatform> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SystemComponentVersionPlatform as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SystemComponentVersionPlatform - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SystemDfContainerReport describes a container for use with df



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SystemDfContainerReport {
    #[serde(rename = "Command")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub command: Option<Vec<String>>,

    #[serde(rename = "ContainerID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_id: Option<String>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "Image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<String>,

    #[serde(rename = "LocalVolumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub local_volumes: Option<i64>,

    #[serde(rename = "Names")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub names: Option<String>,

    #[serde(rename = "RWSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rw_size: Option<i64>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

}


impl SystemDfContainerReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SystemDfContainerReport {
        SystemDfContainerReport {
            command: None,
            container_id: None,
            created: None,
            image: None,
            local_volumes: None,
            names: None,
            rw_size: None,
            size: None,
            status: None,
        }
    }
}

/// Converts the SystemDfContainerReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SystemDfContainerReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.command.as_ref().map(|command| {
                [
                    "Command".to_string(),
                    command.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.container_id.as_ref().map(|container_id| {
                [
                    "ContainerID".to_string(),
                    container_id.to_string(),
                ].join(",")
            }),

            // Skipping Created in query parameter serialization


            self.image.as_ref().map(|image| {
                [
                    "Image".to_string(),
                    image.to_string(),
                ].join(",")
            }),


            self.local_volumes.as_ref().map(|local_volumes| {
                [
                    "LocalVolumes".to_string(),
                    local_volumes.to_string(),
                ].join(",")
            }),


            self.names.as_ref().map(|names| {
                [
                    "Names".to_string(),
                    names.to_string(),
                ].join(",")
            }),


            self.rw_size.as_ref().map(|rw_size| {
                [
                    "RWSize".to_string(),
                    rw_size.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "Status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SystemDfContainerReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SystemDfContainerReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub command: Vec<Vec<String>>,
            pub container_id: Vec<String>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub image: Vec<String>,
            pub local_volumes: Vec<i64>,
            pub names: Vec<String>,
            pub rw_size: Vec<i64>,
            pub size: Vec<i64>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SystemDfContainerReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Command" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemDfContainerReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ContainerID" => intermediate_rep.container_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Image" => intermediate_rep.image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "LocalVolumes" => intermediate_rep.local_volumes.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Names" => intermediate_rep.names.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RWSize" => intermediate_rep.rw_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SystemDfContainerReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SystemDfContainerReport {
            command: intermediate_rep.command.into_iter().next(),
            container_id: intermediate_rep.container_id.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            image: intermediate_rep.image.into_iter().next(),
            local_volumes: intermediate_rep.local_volumes.into_iter().next(),
            names: intermediate_rep.names.into_iter().next(),
            rw_size: intermediate_rep.rw_size.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SystemDfContainerReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SystemDfContainerReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SystemDfContainerReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SystemDfContainerReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SystemDfContainerReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SystemDfContainerReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SystemDfContainerReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SystemDfImageReport describes an image for use with df



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SystemDfImageReport {
    #[serde(rename = "Containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<i64>,

    #[serde(rename = "Created")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "ImageID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_id: Option<String>,

    #[serde(rename = "Repository")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<String>,

    #[serde(rename = "SharedSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shared_size: Option<i64>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

    #[serde(rename = "Tag")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag: Option<String>,

    #[serde(rename = "UniqueSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unique_size: Option<i64>,

}


impl SystemDfImageReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SystemDfImageReport {
        SystemDfImageReport {
            containers: None,
            created: None,
            image_id: None,
            repository: None,
            shared_size: None,
            size: None,
            tag: None,
            unique_size: None,
        }
    }
}

/// Converts the SystemDfImageReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SystemDfImageReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.containers.as_ref().map(|containers| {
                [
                    "Containers".to_string(),
                    containers.to_string(),
                ].join(",")
            }),

            // Skipping Created in query parameter serialization


            self.image_id.as_ref().map(|image_id| {
                [
                    "ImageID".to_string(),
                    image_id.to_string(),
                ].join(",")
            }),


            self.repository.as_ref().map(|repository| {
                [
                    "Repository".to_string(),
                    repository.to_string(),
                ].join(",")
            }),


            self.shared_size.as_ref().map(|shared_size| {
                [
                    "SharedSize".to_string(),
                    shared_size.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.tag.as_ref().map(|tag| {
                [
                    "Tag".to_string(),
                    tag.to_string(),
                ].join(",")
            }),


            self.unique_size.as_ref().map(|unique_size| {
                [
                    "UniqueSize".to_string(),
                    unique_size.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SystemDfImageReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SystemDfImageReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub containers: Vec<i64>,
            pub created: Vec<chrono::DateTime::<chrono::Utc>>,
            pub image_id: Vec<String>,
            pub repository: Vec<String>,
            pub shared_size: Vec<i64>,
            pub size: Vec<i64>,
            pub tag: Vec<String>,
            pub unique_size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SystemDfImageReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Containers" => intermediate_rep.containers.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Created" => intermediate_rep.created.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ImageID" => intermediate_rep.image_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Repository" => intermediate_rep.repository.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SharedSize" => intermediate_rep.shared_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Tag" => intermediate_rep.tag.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UniqueSize" => intermediate_rep.unique_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SystemDfImageReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SystemDfImageReport {
            containers: intermediate_rep.containers.into_iter().next(),
            created: intermediate_rep.created.into_iter().next(),
            image_id: intermediate_rep.image_id.into_iter().next(),
            repository: intermediate_rep.repository.into_iter().next(),
            shared_size: intermediate_rep.shared_size.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            tag: intermediate_rep.tag.into_iter().next(),
            unique_size: intermediate_rep.unique_size.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SystemDfImageReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SystemDfImageReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SystemDfImageReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SystemDfImageReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SystemDfImageReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SystemDfImageReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SystemDfImageReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SystemDfReport describes the response for df information



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SystemDfReport {
    #[serde(rename = "Containers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub containers: Option<Vec<models::SystemDfContainerReport>>,

    #[serde(rename = "Images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<Vec<models::SystemDfImageReport>>,

    #[serde(rename = "ImagesSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images_size: Option<i64>,

    #[serde(rename = "Volumes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes: Option<Vec<models::SystemDfVolumeReport>>,

}


impl SystemDfReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SystemDfReport {
        SystemDfReport {
            containers: None,
            images: None,
            images_size: None,
            volumes: None,
        }
    }
}

/// Converts the SystemDfReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SystemDfReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Containers in query parameter serialization

            // Skipping Images in query parameter serialization


            self.images_size.as_ref().map(|images_size| {
                [
                    "ImagesSize".to_string(),
                    images_size.to_string(),
                ].join(",")
            }),

            // Skipping Volumes in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SystemDfReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SystemDfReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub containers: Vec<Vec<models::SystemDfContainerReport>>,
            pub images: Vec<Vec<models::SystemDfImageReport>>,
            pub images_size: Vec<i64>,
            pub volumes: Vec<Vec<models::SystemDfVolumeReport>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SystemDfReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Containers" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemDfReport".to_string()),
                    "Images" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemDfReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ImagesSize" => intermediate_rep.images_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Volumes" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemDfReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SystemDfReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SystemDfReport {
            containers: intermediate_rep.containers.into_iter().next(),
            images: intermediate_rep.images.into_iter().next(),
            images_size: intermediate_rep.images_size.into_iter().next(),
            volumes: intermediate_rep.volumes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SystemDfReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SystemDfReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SystemDfReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SystemDfReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SystemDfReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SystemDfReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SystemDfReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// SystemDfVolumeReport describes a volume and its size



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SystemDfVolumeReport {
    #[serde(rename = "Links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub links: Option<i64>,

    #[serde(rename = "ReclaimableSize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reclaimable_size: Option<i64>,

    #[serde(rename = "Size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,

    #[serde(rename = "VolumeName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_name: Option<String>,

}


impl SystemDfVolumeReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SystemDfVolumeReport {
        SystemDfVolumeReport {
            links: None,
            reclaimable_size: None,
            size: None,
            volume_name: None,
        }
    }
}

/// Converts the SystemDfVolumeReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SystemDfVolumeReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.links.as_ref().map(|links| {
                [
                    "Links".to_string(),
                    links.to_string(),
                ].join(",")
            }),


            self.reclaimable_size.as_ref().map(|reclaimable_size| {
                [
                    "ReclaimableSize".to_string(),
                    reclaimable_size.to_string(),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "Size".to_string(),
                    size.to_string(),
                ].join(",")
            }),


            self.volume_name.as_ref().map(|volume_name| {
                [
                    "VolumeName".to_string(),
                    volume_name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SystemDfVolumeReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SystemDfVolumeReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub links: Vec<i64>,
            pub reclaimable_size: Vec<i64>,
            pub size: Vec<i64>,
            pub volume_name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SystemDfVolumeReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Links" => intermediate_rep.links.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ReclaimableSize" => intermediate_rep.reclaimable_size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "VolumeName" => intermediate_rep.volume_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SystemDfVolumeReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SystemDfVolumeReport {
            links: intermediate_rep.links.into_iter().next(),
            reclaimable_size: intermediate_rep.reclaimable_size.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            volume_name: intermediate_rep.volume_name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SystemDfVolumeReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SystemDfVolumeReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SystemDfVolumeReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SystemDfVolumeReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SystemDfVolumeReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SystemDfVolumeReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SystemDfVolumeReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SystemPruneReport {
    #[serde(rename = "ContainerPruneReports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_prune_reports: Option<Vec<models::PruneReport>>,

    #[serde(rename = "ImagePruneReports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_prune_reports: Option<Vec<models::PruneReport>>,

    #[serde(rename = "NetworkPruneReports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_prune_reports: Option<Vec<models::NetworkPruneReport>>,

    #[serde(rename = "PodPruneReport")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pod_prune_report: Option<Vec<models::PodPruneReport>>,

    #[serde(rename = "ReclaimedSpace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reclaimed_space: Option<i32>,

    #[serde(rename = "VolumePruneReports")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volume_prune_reports: Option<Vec<models::PruneReport>>,

}


impl SystemPruneReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SystemPruneReport {
        SystemPruneReport {
            container_prune_reports: None,
            image_prune_reports: None,
            network_prune_reports: None,
            pod_prune_report: None,
            reclaimed_space: None,
            volume_prune_reports: None,
        }
    }
}

/// Converts the SystemPruneReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SystemPruneReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ContainerPruneReports in query parameter serialization

            // Skipping ImagePruneReports in query parameter serialization

            // Skipping NetworkPruneReports in query parameter serialization

            // Skipping PodPruneReport in query parameter serialization


            self.reclaimed_space.as_ref().map(|reclaimed_space| {
                [
                    "ReclaimedSpace".to_string(),
                    reclaimed_space.to_string(),
                ].join(",")
            }),

            // Skipping VolumePruneReports in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SystemPruneReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SystemPruneReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub container_prune_reports: Vec<Vec<models::PruneReport>>,
            pub image_prune_reports: Vec<Vec<models::PruneReport>>,
            pub network_prune_reports: Vec<Vec<models::NetworkPruneReport>>,
            pub pod_prune_report: Vec<Vec<models::PodPruneReport>>,
            pub reclaimed_space: Vec<i32>,
            pub volume_prune_reports: Vec<Vec<models::PruneReport>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SystemPruneReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "ContainerPruneReports" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemPruneReport".to_string()),
                    "ImagePruneReports" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemPruneReport".to_string()),
                    "NetworkPruneReports" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemPruneReport".to_string()),
                    "PodPruneReport" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemPruneReport".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "ReclaimedSpace" => intermediate_rep.reclaimed_space.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "VolumePruneReports" => return std::result::Result::Err("Parsing a container in this style is not supported in SystemPruneReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SystemPruneReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SystemPruneReport {
            container_prune_reports: intermediate_rep.container_prune_reports.into_iter().next(),
            image_prune_reports: intermediate_rep.image_prune_reports.into_iter().next(),
            network_prune_reports: intermediate_rep.network_prune_reports.into_iter().next(),
            pod_prune_report: intermediate_rep.pod_prune_report.into_iter().next(),
            reclaimed_space: intermediate_rep.reclaimed_space.into_iter().next(),
            volume_prune_reports: intermediate_rep.volume_prune_reports.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SystemPruneReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SystemPruneReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SystemPruneReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SystemPruneReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SystemPruneReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SystemPruneReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SystemPruneReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Task carries the information about one backend task



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Task {
    #[serde(rename = "EndpointID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_id: Option<String>,

    #[serde(rename = "EndpointIP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub endpoint_ip: Option<String>,

    #[serde(rename = "Info")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub info: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl Task {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Task {
        Task {
            endpoint_id: None,
            endpoint_ip: None,
            info: None,
            name: None,
        }
    }
}

/// Converts the Task value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Task {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.endpoint_id.as_ref().map(|endpoint_id| {
                [
                    "EndpointID".to_string(),
                    endpoint_id.to_string(),
                ].join(",")
            }),


            self.endpoint_ip.as_ref().map(|endpoint_ip| {
                [
                    "EndpointIP".to_string(),
                    endpoint_ip.to_string(),
                ].join(",")
            }),

            // Skipping Info in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Task value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Task {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub endpoint_id: Vec<String>,
            pub endpoint_ip: Vec<String>,
            pub info: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Task".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "EndpointID" => intermediate_rep.endpoint_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "EndpointIP" => intermediate_rep.endpoint_ip.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Info" => return std::result::Result::Err("Parsing a container in this style is not supported in Task".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Task".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Task {
            endpoint_id: intermediate_rep.endpoint_id.into_iter().next(),
            endpoint_ip: intermediate_rep.endpoint_ip.into_iter().next(),
            info: intermediate_rep.info.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Task> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Task>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Task>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Task - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Task> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Task as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Task - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ThrottleDevice is a structure that holds device:rate_per_second pair



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ThrottleDevice {
    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "Rate")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate: Option<i32>,

}


impl ThrottleDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ThrottleDevice {
        ThrottleDevice {
            path: None,
            rate: None,
        }
    }
}

/// Converts the ThrottleDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ThrottleDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.rate.as_ref().map(|rate| {
                [
                    "Rate".to_string(),
                    rate.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ThrottleDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ThrottleDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub rate: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ThrottleDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Rate" => intermediate_rep.rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ThrottleDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ThrottleDevice {
            path: intermediate_rep.path.into_iter().next(),
            rate: intermediate_rep.rate.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ThrottleDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ThrottleDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ThrottleDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ThrottleDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ThrottleDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ThrottleDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ThrottleDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TmpfsOptions {
/// The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is [ModeDir] for directories.
    #[serde(rename = "Mode")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<i32>,

/// Size sets the size of the tmpfs, in bytes.  This will be converted to an operating system specific value depending on the host. For example, on linux, it will be converted to use a 'k', 'm' or 'g' syntax. BSD, though not widely supported with docker, uses a straight byte value.  Percentages are not supported.
    #[serde(rename = "SizeBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_bytes: Option<i64>,

}


impl TmpfsOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TmpfsOptions {
        TmpfsOptions {
            mode: None,
            size_bytes: None,
        }
    }
}

/// Converts the TmpfsOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TmpfsOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.mode.as_ref().map(|mode| {
                [
                    "Mode".to_string(),
                    mode.to_string(),
                ].join(",")
            }),


            self.size_bytes.as_ref().map(|size_bytes| {
                [
                    "SizeBytes".to_string(),
                    size_bytes.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TmpfsOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TmpfsOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub mode: Vec<i32>,
            pub size_bytes: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TmpfsOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Mode" => intermediate_rep.mode.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "SizeBytes" => intermediate_rep.size_bytes.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TmpfsOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TmpfsOptions {
            mode: intermediate_rep.mode.into_iter().next(),
            size_bytes: intermediate_rep.size_bytes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TmpfsOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TmpfsOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TmpfsOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TmpfsOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TmpfsOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TmpfsOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TmpfsOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// This description is taken verbatim from the CSI Spec:  A topological domain is a sub-division of a cluster, like \"region\", \"zone\", \"rack\", etc. A topological segment is a specific instance of a topological domain, like \"zone3\", \"rack3\", etc. For example {\"com.company/zone\": \"Z1\", \"com.company/rack\": \"R3\"} Valid keys have two segments: an OPTIONAL prefix and name, separated by a slash (/), for example: \"com.company.example/zone\". The key name segment is REQUIRED. The prefix is OPTIONAL. The key name MUST be 63 characters or less, begin and end with an alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-), underscores (_), dots (.), or alphanumerics in between, for example \"zone\". The key prefix MUST be 63 characters or less, begin and end with a lower-case alphanumeric character ([a-z0-9]), contain only dashes (-), dots (.), or lower-case alphanumerics in between, and follow domain name notation format (https://tools.ietf.org/html/rfc1035#section-2.3.1). The key prefix SHOULD include the plugin's host company name and/or the plugin name, to minimize the possibility of collisions with keys from other plugins. If a key prefix is specified, it MUST be identical across all topology keys returned by the SP (across all RPCs). Keys MUST be case-insensitive. Meaning the keys \"Zone\" and \"zone\" MUST not both exist. Each value (topological segment) MUST contain 1 or more strings. Each string MUST be 63 characters or less and begin and end with an alphanumeric character with '-', '_', '.', or alphanumerics in between.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Topology {
    #[serde(rename = "Segments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub segments: Option<std::collections::HashMap<String, String>>,

}


impl Topology {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Topology {
        Topology {
            segments: None,
        }
    }
}

/// Converts the Topology value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Topology {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Segments in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Topology value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Topology {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub segments: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Topology".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Segments" => return std::result::Result::Err("Parsing a container in this style is not supported in Topology".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Topology".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Topology {
            segments: intermediate_rep.segments.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Topology> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Topology>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Topology>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Topology - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Topology> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Topology as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Topology - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// TopologyRequirement expresses the user's requirements for a volume's accessible topology.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TopologyRequirement {
/// Preferred is a list of Topologies that the volume should attempt to be provisioned in.  Taken from the CSI spec:  Specifies the list of topologies the CO would prefer the volume to be provisioned in.  This field is OPTIONAL. If TopologyRequirement is specified either requisite or preferred or both MUST be specified.  An SP MUST attempt to make the provisioned volume available using the preferred topologies in order from first to last.  If requisite is specified, all topologies in preferred list MUST also be present in the list of requisite topologies.  If the SP is unable to make the provisioned volume available from any of the preferred topologies, the SP MAY choose a topology from the list of requisite topologies. If the list of requisite topologies is not specified, then the SP MAY choose from the list of all possible topologies. If the list of requisite topologies is specified and the SP is unable to make the provisioned volume available from any of the requisite topologies it MUST fail the CreateVolume call.  Example 1: Given a volume should be accessible from a single zone, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"} preferred = {\"region\": \"R1\", \"zone\": \"Z3\"} then the SP SHOULD first attempt to make the provisioned volume available from \"zone\" \"Z3\" in the \"region\" \"R1\" and fall back to \"zone\" \"Z2\" in the \"region\" \"R1\" if that is not possible.  Example 2: Given a volume should be accessible from a single zone, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"}, {\"region\": \"R1\", \"zone\": \"Z4\"}, {\"region\": \"R1\", \"zone\": \"Z5\"} preferred = {\"region\": \"R1\", \"zone\": \"Z4\"}, {\"region\": \"R1\", \"zone\": \"Z2\"} then the SP SHOULD first attempt to make the provisioned volume accessible from \"zone\" \"Z4\" in the \"region\" \"R1\" and fall back to \"zone\" \"Z2\" in the \"region\" \"R1\" if that is not possible. If that is not possible, the SP may choose between either the \"zone\" \"Z3\" or \"Z5\" in the \"region\" \"R1\".  Example 3: Given a volume should be accessible from TWO zones (because an opaque parameter in CreateVolumeRequest, for example, specifies the volume is accessible from two zones, aka synchronously replicated), and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"}, {\"region\": \"R1\", \"zone\": \"Z4\"}, {\"region\": \"R1\", \"zone\": \"Z5\"} preferred = {\"region\": \"R1\", \"zone\": \"Z5\"}, {\"region\": \"R1\", \"zone\": \"Z3\"} then the SP SHOULD first attempt to make the provisioned volume accessible from the combination of the two \"zones\" \"Z5\" and \"Z3\" in the \"region\" \"R1\". If that's not possible, it should fall back to a combination of \"Z5\" and other possibilities from the list of requisite. If that's not possible, it should fall back  to a combination of \"Z3\" and other possibilities from the list of requisite. If that's not possible, it should fall back  to a combination of other possibilities from the list of requisite.
    #[serde(rename = "Preferred")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred: Option<Vec<models::Topology>>,

/// Requisite specifies a list of Topologies, at least one of which the volume must be accessible from.  Taken verbatim from the CSI Spec:  Specifies the list of topologies the provisioned volume MUST be accessible from. This field is OPTIONAL. If TopologyRequirement is specified either requisite or preferred or both MUST be specified.  If requisite is specified, the provisioned volume MUST be accessible from at least one of the requisite topologies.  Given x = number of topologies provisioned volume is accessible from n = number of requisite topologies The CO MUST ensure n >= 1. The SP MUST ensure x >= 1 If x==n, then the SP MUST make the provisioned volume available to all topologies from the list of requisite topologies. If it is unable to do so, the SP MUST fail the CreateVolume call. For example, if a volume should be accessible from a single zone, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"} then the provisioned volume MUST be accessible from the \"region\" \"R1\" and the \"zone\" \"Z2\". Similarly, if a volume should be accessible from two zones, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"} then the provisioned volume MUST be accessible from the \"region\" \"R1\" and both \"zone\" \"Z2\" and \"zone\" \"Z3\".  If x<n, then the SP SHALL choose x unique topologies from the list of requisite topologies. If it is unable to do so, the SP MUST fail the CreateVolume call. For example, if a volume should be accessible from a single zone, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"} then the SP may choose to make the provisioned volume available in either the \"zone\" \"Z2\" or the \"zone\" \"Z3\" in the \"region\" \"R1\". Similarly, if a volume should be accessible from two zones, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"}, {\"region\": \"R1\", \"zone\": \"Z3\"}, {\"region\": \"R1\", \"zone\": \"Z4\"} then the provisioned volume MUST be accessible from any combination of two unique topologies: e.g. \"R1/Z2\" and \"R1/Z3\", or \"R1/Z2\" and \"R1/Z4\", or \"R1/Z3\" and \"R1/Z4\".  If x>n, then the SP MUST make the provisioned volume available from all topologies from the list of requisite topologies and MAY choose the remaining x-n unique topologies from the list of all possible topologies. If it is unable to do so, the SP MUST fail the CreateVolume call. For example, if a volume should be accessible from two zones, and requisite = {\"region\": \"R1\", \"zone\": \"Z2\"} then the provisioned volume MUST be accessible from the \"region\" \"R1\" and the \"zone\" \"Z2\" and the SP may select the second zone independently, e.g. \"R1/Z4\".
    #[serde(rename = "Requisite")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub requisite: Option<Vec<models::Topology>>,

}


impl TopologyRequirement {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TopologyRequirement {
        TopologyRequirement {
            preferred: None,
            requisite: None,
        }
    }
}

/// Converts the TopologyRequirement value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TopologyRequirement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Preferred in query parameter serialization

            // Skipping Requisite in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TopologyRequirement value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TopologyRequirement {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub preferred: Vec<Vec<models::Topology>>,
            pub requisite: Vec<Vec<models::Topology>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TopologyRequirement".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "Preferred" => return std::result::Result::Err("Parsing a container in this style is not supported in TopologyRequirement".to_string()),
                    "Requisite" => return std::result::Result::Err("Parsing a container in this style is not supported in TopologyRequirement".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TopologyRequirement".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TopologyRequirement {
            preferred: intermediate_rep.preferred.into_iter().next(),
            requisite: intermediate_rep.requisite.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TopologyRequirement> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TopologyRequirement>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TopologyRequirement>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TopologyRequirement - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TopologyRequirement> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TopologyRequirement as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TopologyRequirement - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Type(String);

impl validator::Validate for Type {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for Type {
    fn from(x: String) -> Self {
        Type(x)
    }
}

impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for Type {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(Type(x.to_string()))
    }
}

impl std::convert::From<Type> for String {
    fn from(x: Type) -> Self {
        x.0
    }
}

impl std::ops::Deref for Type {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for Type {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



/// TypeMount contains options for using a volume as a Mount-type volume.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeMount {
/// FsType specifies the filesystem type for the mount volume. Optional.
    #[serde(rename = "FsType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fs_type: Option<String>,

/// MountFlags defines flags to pass when mounting the volume. Optional.
    #[serde(rename = "MountFlags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mount_flags: Option<Vec<String>>,

}


impl TypeMount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TypeMount {
        TypeMount {
            fs_type: None,
            mount_flags: None,
        }
    }
}

/// Converts the TypeMount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeMount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.fs_type.as_ref().map(|fs_type| {
                [
                    "FsType".to_string(),
                    fs_type.to_string(),
                ].join(",")
            }),


            self.mount_flags.as_ref().map(|mount_flags| {
                [
                    "MountFlags".to_string(),
                    mount_flags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeMount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeMount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub fs_type: Vec<String>,
            pub mount_flags: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeMount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "FsType" => intermediate_rep.fs_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "MountFlags" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeMount".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeMount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeMount {
            fs_type: intermediate_rep.fs_type.into_iter().next(),
            mount_flags: intermediate_rep.mount_flags.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeMount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeMount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeMount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TypeMount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeMount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeMount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TypeMount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Ulimit {
    #[serde(rename = "Hard")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hard: Option<i64>,

    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "Soft")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub soft: Option<i64>,

}


impl Ulimit {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Ulimit {
        Ulimit {
            hard: None,
            name: None,
            soft: None,
        }
    }
}

/// Converts the Ulimit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Ulimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.hard.as_ref().map(|hard| {
                [
                    "Hard".to_string(),
                    hard.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.soft.as_ref().map(|soft| {
                [
                    "Soft".to_string(),
                    soft.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Ulimit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Ulimit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hard: Vec<i64>,
            pub name: Vec<String>,
            pub soft: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Ulimit".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Hard" => intermediate_rep.hard.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Soft" => intermediate_rep.soft.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Ulimit".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Ulimit {
            hard: intermediate_rep.hard.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            soft: intermediate_rep.soft.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Ulimit> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Ulimit>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Ulimit>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Ulimit - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Ulimit> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Ulimit as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Ulimit - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Those attributes can be updated at runtime.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateConfig {
    #[serde(rename = "BlkioDeviceReadBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceReadIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_read_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteBps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_bps: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioDeviceWriteIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_device_write_i_ops: Option<Vec<models::ThrottleDevice>>,

    #[serde(rename = "BlkioWeight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight: Option<i32>,

    #[serde(rename = "BlkioWeightDevice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blkio_weight_device: Option<Vec<models::WeightDevice>>,

/// Applicable to UNIX platforms
    #[serde(rename = "CgroupParent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cgroup_parent: Option<String>,

/// Applicable to Windows
    #[serde(rename = "CpuCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_count: Option<i64>,

    #[serde(rename = "CpuPercent")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_percent: Option<i64>,

    #[serde(rename = "CpuPeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_period: Option<i64>,

    #[serde(rename = "CpuQuota")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_quota: Option<i64>,

    #[serde(rename = "CpuRealtimePeriod")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_period: Option<i64>,

    #[serde(rename = "CpuRealtimeRuntime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_realtime_runtime: Option<i64>,

/// Applicable to all platforms
    #[serde(rename = "CpuShares")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_shares: Option<i64>,

    #[serde(rename = "CpusetCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_cpus: Option<String>,

    #[serde(rename = "CpusetMems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpuset_mems: Option<String>,

    #[serde(rename = "DeviceCgroupRules")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_cgroup_rules: Option<Vec<String>>,

    #[serde(rename = "DeviceRequests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub device_requests: Option<Vec<models::DeviceRequest>>,

    #[serde(rename = "Devices")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub devices: Option<Vec<models::DeviceMapping>>,

    #[serde(rename = "IOMaximumBandwidth")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_bandwidth: Option<i32>,

    #[serde(rename = "IOMaximumIOps")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub io_maximum_i_ops: Option<i32>,

/// KernelMemory specifies the kernel memory limit (in bytes) for the container. Deprecated: kernel 5.4 deprecated kmem.limit_in_bytes.
    #[serde(rename = "KernelMemory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory: Option<i64>,

    #[serde(rename = "KernelMemoryTCP")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kernel_memory_tcp: Option<i64>,

    #[serde(rename = "Memory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory: Option<i64>,

    #[serde(rename = "MemoryReservation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_reservation: Option<i64>,

    #[serde(rename = "MemorySwap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swap: Option<i64>,

    #[serde(rename = "MemorySwappiness")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_swappiness: Option<i64>,

    #[serde(rename = "NanoCpus")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub nano_cpus: Option<i64>,

    #[serde(rename = "OomKillDisable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub oom_kill_disable: Option<bool>,

    #[serde(rename = "PidsLimit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pids_limit: Option<i64>,

    #[serde(rename = "RestartPolicy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub restart_policy: Option<models::RestartPolicy>,

    #[serde(rename = "Ulimits")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ulimits: Option<Vec<models::Ulimit>>,

}


impl UpdateConfig {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> UpdateConfig {
        UpdateConfig {
            blkio_device_read_bps: None,
            blkio_device_read_i_ops: None,
            blkio_device_write_bps: None,
            blkio_device_write_i_ops: None,
            blkio_weight: None,
            blkio_weight_device: None,
            cgroup_parent: None,
            cpu_count: None,
            cpu_percent: None,
            cpu_period: None,
            cpu_quota: None,
            cpu_realtime_period: None,
            cpu_realtime_runtime: None,
            cpu_shares: None,
            cpuset_cpus: None,
            cpuset_mems: None,
            device_cgroup_rules: None,
            device_requests: None,
            devices: None,
            io_maximum_bandwidth: None,
            io_maximum_i_ops: None,
            kernel_memory: None,
            kernel_memory_tcp: None,
            memory: None,
            memory_reservation: None,
            memory_swap: None,
            memory_swappiness: None,
            nano_cpus: None,
            oom_kill_disable: None,
            pids_limit: None,
            restart_policy: None,
            ulimits: None,
        }
    }
}

/// Converts the UpdateConfig value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UpdateConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping BlkioDeviceReadBps in query parameter serialization

            // Skipping BlkioDeviceReadIOps in query parameter serialization

            // Skipping BlkioDeviceWriteBps in query parameter serialization

            // Skipping BlkioDeviceWriteIOps in query parameter serialization


            self.blkio_weight.as_ref().map(|blkio_weight| {
                [
                    "BlkioWeight".to_string(),
                    blkio_weight.to_string(),
                ].join(",")
            }),

            // Skipping BlkioWeightDevice in query parameter serialization


            self.cgroup_parent.as_ref().map(|cgroup_parent| {
                [
                    "CgroupParent".to_string(),
                    cgroup_parent.to_string(),
                ].join(",")
            }),


            self.cpu_count.as_ref().map(|cpu_count| {
                [
                    "CpuCount".to_string(),
                    cpu_count.to_string(),
                ].join(",")
            }),


            self.cpu_percent.as_ref().map(|cpu_percent| {
                [
                    "CpuPercent".to_string(),
                    cpu_percent.to_string(),
                ].join(",")
            }),


            self.cpu_period.as_ref().map(|cpu_period| {
                [
                    "CpuPeriod".to_string(),
                    cpu_period.to_string(),
                ].join(",")
            }),


            self.cpu_quota.as_ref().map(|cpu_quota| {
                [
                    "CpuQuota".to_string(),
                    cpu_quota.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_period.as_ref().map(|cpu_realtime_period| {
                [
                    "CpuRealtimePeriod".to_string(),
                    cpu_realtime_period.to_string(),
                ].join(",")
            }),


            self.cpu_realtime_runtime.as_ref().map(|cpu_realtime_runtime| {
                [
                    "CpuRealtimeRuntime".to_string(),
                    cpu_realtime_runtime.to_string(),
                ].join(",")
            }),


            self.cpu_shares.as_ref().map(|cpu_shares| {
                [
                    "CpuShares".to_string(),
                    cpu_shares.to_string(),
                ].join(",")
            }),


            self.cpuset_cpus.as_ref().map(|cpuset_cpus| {
                [
                    "CpusetCpus".to_string(),
                    cpuset_cpus.to_string(),
                ].join(",")
            }),


            self.cpuset_mems.as_ref().map(|cpuset_mems| {
                [
                    "CpusetMems".to_string(),
                    cpuset_mems.to_string(),
                ].join(",")
            }),


            self.device_cgroup_rules.as_ref().map(|device_cgroup_rules| {
                [
                    "DeviceCgroupRules".to_string(),
                    device_cgroup_rules.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping DeviceRequests in query parameter serialization

            // Skipping Devices in query parameter serialization


            self.io_maximum_bandwidth.as_ref().map(|io_maximum_bandwidth| {
                [
                    "IOMaximumBandwidth".to_string(),
                    io_maximum_bandwidth.to_string(),
                ].join(",")
            }),


            self.io_maximum_i_ops.as_ref().map(|io_maximum_i_ops| {
                [
                    "IOMaximumIOps".to_string(),
                    io_maximum_i_ops.to_string(),
                ].join(",")
            }),


            self.kernel_memory.as_ref().map(|kernel_memory| {
                [
                    "KernelMemory".to_string(),
                    kernel_memory.to_string(),
                ].join(",")
            }),


            self.kernel_memory_tcp.as_ref().map(|kernel_memory_tcp| {
                [
                    "KernelMemoryTCP".to_string(),
                    kernel_memory_tcp.to_string(),
                ].join(",")
            }),


            self.memory.as_ref().map(|memory| {
                [
                    "Memory".to_string(),
                    memory.to_string(),
                ].join(",")
            }),


            self.memory_reservation.as_ref().map(|memory_reservation| {
                [
                    "MemoryReservation".to_string(),
                    memory_reservation.to_string(),
                ].join(",")
            }),


            self.memory_swap.as_ref().map(|memory_swap| {
                [
                    "MemorySwap".to_string(),
                    memory_swap.to_string(),
                ].join(",")
            }),


            self.memory_swappiness.as_ref().map(|memory_swappiness| {
                [
                    "MemorySwappiness".to_string(),
                    memory_swappiness.to_string(),
                ].join(",")
            }),


            self.nano_cpus.as_ref().map(|nano_cpus| {
                [
                    "NanoCpus".to_string(),
                    nano_cpus.to_string(),
                ].join(",")
            }),


            self.oom_kill_disable.as_ref().map(|oom_kill_disable| {
                [
                    "OomKillDisable".to_string(),
                    oom_kill_disable.to_string(),
                ].join(",")
            }),


            self.pids_limit.as_ref().map(|pids_limit| {
                [
                    "PidsLimit".to_string(),
                    pids_limit.to_string(),
                ].join(",")
            }),

            // Skipping RestartPolicy in query parameter serialization

            // Skipping Ulimits in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateConfig value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateConfig {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub blkio_device_read_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_read_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_bps: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_device_write_i_ops: Vec<Vec<models::ThrottleDevice>>,
            pub blkio_weight: Vec<i32>,
            pub blkio_weight_device: Vec<Vec<models::WeightDevice>>,
            pub cgroup_parent: Vec<String>,
            pub cpu_count: Vec<i64>,
            pub cpu_percent: Vec<i64>,
            pub cpu_period: Vec<i64>,
            pub cpu_quota: Vec<i64>,
            pub cpu_realtime_period: Vec<i64>,
            pub cpu_realtime_runtime: Vec<i64>,
            pub cpu_shares: Vec<i64>,
            pub cpuset_cpus: Vec<String>,
            pub cpuset_mems: Vec<String>,
            pub device_cgroup_rules: Vec<Vec<String>>,
            pub device_requests: Vec<Vec<models::DeviceRequest>>,
            pub devices: Vec<Vec<models::DeviceMapping>>,
            pub io_maximum_bandwidth: Vec<i32>,
            pub io_maximum_i_ops: Vec<i32>,
            pub kernel_memory: Vec<i64>,
            pub kernel_memory_tcp: Vec<i64>,
            pub memory: Vec<i64>,
            pub memory_reservation: Vec<i64>,
            pub memory_swap: Vec<i64>,
            pub memory_swappiness: Vec<i64>,
            pub nano_cpus: Vec<i64>,
            pub oom_kill_disable: Vec<bool>,
            pub pids_limit: Vec<i64>,
            pub restart_policy: Vec<models::RestartPolicy>,
            pub ulimits: Vec<Vec<models::Ulimit>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateConfig".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "BlkioDeviceReadBps" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    "BlkioDeviceReadIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    "BlkioDeviceWriteBps" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    "BlkioDeviceWriteIOps" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "BlkioWeight" => intermediate_rep.blkio_weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "BlkioWeightDevice" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "CgroupParent" => intermediate_rep.cgroup_parent.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuCount" => intermediate_rep.cpu_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPercent" => intermediate_rep.cpu_percent.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuPeriod" => intermediate_rep.cpu_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuQuota" => intermediate_rep.cpu_quota.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimePeriod" => intermediate_rep.cpu_realtime_period.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuRealtimeRuntime" => intermediate_rep.cpu_realtime_runtime.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpuShares" => intermediate_rep.cpu_shares.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetCpus" => intermediate_rep.cpuset_cpus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CpusetMems" => intermediate_rep.cpuset_mems.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DeviceCgroupRules" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    "DeviceRequests" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    "Devices" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumBandwidth" => intermediate_rep.io_maximum_bandwidth.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IOMaximumIOps" => intermediate_rep.io_maximum_i_ops.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemory" => intermediate_rep.kernel_memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "KernelMemoryTCP" => intermediate_rep.kernel_memory_tcp.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Memory" => intermediate_rep.memory.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemoryReservation" => intermediate_rep.memory_reservation.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwap" => intermediate_rep.memory_swap.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MemorySwappiness" => intermediate_rep.memory_swappiness.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NanoCpus" => intermediate_rep.nano_cpus.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "OomKillDisable" => intermediate_rep.oom_kill_disable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "PidsLimit" => intermediate_rep.pids_limit.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "RestartPolicy" => intermediate_rep.restart_policy.push(<models::RestartPolicy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Ulimits" => return std::result::Result::Err("Parsing a container in this style is not supported in UpdateConfig".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateConfig".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateConfig {
            blkio_device_read_bps: intermediate_rep.blkio_device_read_bps.into_iter().next(),
            blkio_device_read_i_ops: intermediate_rep.blkio_device_read_i_ops.into_iter().next(),
            blkio_device_write_bps: intermediate_rep.blkio_device_write_bps.into_iter().next(),
            blkio_device_write_i_ops: intermediate_rep.blkio_device_write_i_ops.into_iter().next(),
            blkio_weight: intermediate_rep.blkio_weight.into_iter().next(),
            blkio_weight_device: intermediate_rep.blkio_weight_device.into_iter().next(),
            cgroup_parent: intermediate_rep.cgroup_parent.into_iter().next(),
            cpu_count: intermediate_rep.cpu_count.into_iter().next(),
            cpu_percent: intermediate_rep.cpu_percent.into_iter().next(),
            cpu_period: intermediate_rep.cpu_period.into_iter().next(),
            cpu_quota: intermediate_rep.cpu_quota.into_iter().next(),
            cpu_realtime_period: intermediate_rep.cpu_realtime_period.into_iter().next(),
            cpu_realtime_runtime: intermediate_rep.cpu_realtime_runtime.into_iter().next(),
            cpu_shares: intermediate_rep.cpu_shares.into_iter().next(),
            cpuset_cpus: intermediate_rep.cpuset_cpus.into_iter().next(),
            cpuset_mems: intermediate_rep.cpuset_mems.into_iter().next(),
            device_cgroup_rules: intermediate_rep.device_cgroup_rules.into_iter().next(),
            device_requests: intermediate_rep.device_requests.into_iter().next(),
            devices: intermediate_rep.devices.into_iter().next(),
            io_maximum_bandwidth: intermediate_rep.io_maximum_bandwidth.into_iter().next(),
            io_maximum_i_ops: intermediate_rep.io_maximum_i_ops.into_iter().next(),
            kernel_memory: intermediate_rep.kernel_memory.into_iter().next(),
            kernel_memory_tcp: intermediate_rep.kernel_memory_tcp.into_iter().next(),
            memory: intermediate_rep.memory.into_iter().next(),
            memory_reservation: intermediate_rep.memory_reservation.into_iter().next(),
            memory_swap: intermediate_rep.memory_swap.into_iter().next(),
            memory_swappiness: intermediate_rep.memory_swappiness.into_iter().next(),
            nano_cpus: intermediate_rep.nano_cpus.into_iter().next(),
            oom_kill_disable: intermediate_rep.oom_kill_disable.into_iter().next(),
            pids_limit: intermediate_rep.pids_limit.into_iter().next(),
            restart_policy: intermediate_rep.restart_policy.into_iter().next(),
            ulimits: intermediate_rep.ulimits.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateConfig> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateConfig>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateConfig>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateConfig - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UpdateConfig> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateConfig as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateConfig - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// UpdateEntities used to wrap the oci resource spec in a swagger model



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateEntities {
    #[serde(rename = "Resources")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub resources: Option<models::LinuxResources>,

}


impl UpdateEntities {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> UpdateEntities {
        UpdateEntities {
            resources: None,
        }
    }
}

/// Converts the UpdateEntities value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UpdateEntities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Resources in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateEntities value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateEntities {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub resources: Vec<models::LinuxResources>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateEntities".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Resources" => intermediate_rep.resources.push(<models::LinuxResources as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateEntities".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateEntities {
            resources: intermediate_rep.resources.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateEntities> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateEntities>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateEntities>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UpdateEntities - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UpdateEntities> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateEntities as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UpdateEntities - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// UsageData Usage details about the volume. This information is used by the `GET /system/df` endpoint, and omitted in other endpoints.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageData {
/// The number of containers referencing this volume. This field is set to `-1` if the reference-count is not available.
    #[serde(rename = "RefCount")]
    pub ref_count: i64,

/// Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the `\"local\"` volume driver. For volumes created with other volume drivers, this field is set to `-1` (\"not available\")
    #[serde(rename = "Size")]
    pub size: i64,

}


impl UsageData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ref_count: i64, size: i64, ) -> UsageData {
        UsageData {
            ref_count,
            size,
        }
    }
}

/// Converts the UsageData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("RefCount".to_string()),
            Some(self.ref_count.to_string()),


            Some("Size".to_string()),
            Some(self.size.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ref_count: Vec<i64>,
            pub size: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "RefCount" => intermediate_rep.ref_count.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Size" => intermediate_rep.size.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageData {
            ref_count: intermediate_rep.ref_count.into_iter().next().ok_or_else(|| "RefCount missing in UsageData".to_string())?,
            size: intermediate_rep.size.into_iter().next().ok_or_else(|| "Size missing in UsageData".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for UsageData - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into UsageData - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsernsMode(String);

impl validator::Validate for UsernsMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for UsernsMode {
    fn from(x: String) -> Self {
        UsernsMode(x)
    }
}

impl std::fmt::Display for UsernsMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for UsernsMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(UsernsMode(x.to_string()))
    }
}

impl std::convert::From<UsernsMode> for String {
    fn from(x: UsernsMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for UsernsMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for UsernsMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}



#[derive(Debug, Clone, PartialEq, PartialOrd, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UtsMode(String);

impl validator::Validate for UtsMode {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::convert::From<String> for UtsMode {
    fn from(x: String) -> Self {
        UtsMode(x)
    }
}

impl std::fmt::Display for UtsMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       write!(f, "{:?}", self.0)
    }
}

impl std::str::FromStr for UtsMode {
    type Err = std::string::ParseError;
    fn from_str(x: &str) -> std::result::Result<Self, Self::Err> {
        std::result::Result::Ok(UtsMode(x.to_string()))
    }
}

impl std::convert::From<UtsMode> for String {
    fn from(x: UtsMode) -> Self {
        x.0
    }
}

impl std::ops::Deref for UtsMode {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}

impl std::ops::DerefMut for UtsMode {
    fn deref_mut(&mut self) -> &mut String {
        &mut self.0
    }
}






#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Version {
    #[serde(rename = "Index")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<i32>,

}


impl Version {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Version {
        Version {
            index: None,
        }
    }
}

/// Converts the Version value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.index.as_ref().map(|index| {
                [
                    "Index".to_string(),
                    index.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Version value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Version {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Version".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Version".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Version {
            index: intermediate_rep.index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Version> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Version>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Version>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Version - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Version> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Version as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Version - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Volume volume



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Volume {
    #[serde(rename = "ClusterVolume")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cluster_volume: Option<models::ClusterVolume>,

/// Date/Time the volume was created.
    #[serde(rename = "CreatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,

/// Name of the volume driver used by the volume.
    #[serde(rename = "Driver")]
    pub driver: String,

/// User-defined key/value metadata.
    #[serde(rename = "Labels")]
    pub labels: std::collections::HashMap<String, String>,

/// Mount path of the volume on the host.
    #[serde(rename = "Mountpoint")]
    pub mountpoint: String,

/// Name of the volume.
    #[serde(rename = "Name")]
    pub name: String,

/// The driver specific options used when creating the volume.
    #[serde(rename = "Options")]
    pub options: std::collections::HashMap<String, String>,

/// The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
    #[serde(rename = "Scope")]
    pub scope: String,

/// Low-level details about the volume, provided by the volume driver. Details are returned as a map with key/value pairs: `{\"key\":\"value\",\"key2\":\"value2\"}`.  The `Status` field is optional, and is omitted if the volume driver does not support this feature.
    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<std::collections::HashMap<String, crate::types::Object>>,

    #[serde(rename = "UsageData")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage_data: Option<models::UsageData>,

}


impl Volume {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(driver: String, labels: std::collections::HashMap<String, String>, mountpoint: String, name: String, options: std::collections::HashMap<String, String>, scope: String, ) -> Volume {
        Volume {
            cluster_volume: None,
            created_at: None,
            driver,
            labels,
            mountpoint,
            name,
            options,
            scope,
            status: None,
            usage_data: None,
        }
    }
}

/// Converts the Volume value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Volume {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ClusterVolume in query parameter serialization


            self.created_at.as_ref().map(|created_at| {
                [
                    "CreatedAt".to_string(),
                    created_at.to_string(),
                ].join(",")
            }),


            Some("Driver".to_string()),
            Some(self.driver.to_string()),

            // Skipping Labels in query parameter serialization


            Some("Mountpoint".to_string()),
            Some(self.mountpoint.to_string()),


            Some("Name".to_string()),
            Some(self.name.to_string()),

            // Skipping Options in query parameter serialization


            Some("Scope".to_string()),
            Some(self.scope.to_string()),

            // Skipping Status in query parameter serialization
            // Skipping Status in query parameter serialization

            // Skipping UsageData in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Volume value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Volume {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cluster_volume: Vec<models::ClusterVolume>,
            pub created_at: Vec<String>,
            pub driver: Vec<String>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub mountpoint: Vec<String>,
            pub name: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub scope: Vec<String>,
            pub status: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub usage_data: Vec<models::UsageData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Volume".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ClusterVolume" => intermediate_rep.cluster_volume.push(<models::ClusterVolume as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CreatedAt" => intermediate_rep.created_at.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in Volume".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Mountpoint" => intermediate_rep.mountpoint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in Volume".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Status" => return std::result::Result::Err("Parsing a container in this style is not supported in Volume".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "UsageData" => intermediate_rep.usage_data.push(<models::UsageData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Volume".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Volume {
            cluster_volume: intermediate_rep.cluster_volume.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next().ok_or_else(|| "Driver missing in Volume".to_string())?,
            labels: intermediate_rep.labels.into_iter().next().ok_or_else(|| "Labels missing in Volume".to_string())?,
            mountpoint: intermediate_rep.mountpoint.into_iter().next().ok_or_else(|| "Mountpoint missing in Volume".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in Volume".to_string())?,
            options: intermediate_rep.options.into_iter().next().ok_or_else(|| "Options missing in Volume".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or_else(|| "Scope missing in Volume".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
            usage_data: intermediate_rep.usage_data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Volume> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Volume>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Volume>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Volume - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Volume> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Volume as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Volume - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeConfigResponse {
/// Anonymous indicates that the volume was created as an anonymous volume for a specific container, and will be removed when any container using it is removed.
    #[serde(rename = "Anonymous")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub anonymous: Option<bool>,

/// CreatedAt is the date and time the volume was created at. This is not stored for older Libpod volumes; if so, it will be omitted.
    #[serde(rename = "CreatedAt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

/// Driver is the driver used to create the volume. If set to \"local\" or \"\", the Local driver (Podman built-in code) is used to service the volume; otherwise, a volume plugin with the given name is used to mount and manage the volume.
    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// GID is the GID that the volume was created with.
    #[serde(rename = "GID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gid: Option<i64>,

/// Labels includes the volume's configured labels, key:value pairs that can be passed during volume creation to provide information for third party tools.
    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// LockNumber is the number of the volume's Libpod lock.
    #[serde(rename = "LockNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_number: Option<i32>,

/// MountCount is the number of times this volume has been mounted.
    #[serde(rename = "MountCount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mount_count: Option<i32>,

/// Mountpoint is the path on the host where the volume is mounted.
    #[serde(rename = "Mountpoint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mountpoint: Option<String>,

/// Name is the name of the volume.
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// NeedsChown indicates that the next time the volume is mounted into a container, the container will chown the volume to the container process UID/GID.
    #[serde(rename = "NeedsChown")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub needs_chown: Option<bool>,

/// NeedsCopyUp indicates that the next time the volume is mounted into
    #[serde(rename = "NeedsCopyUp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub needs_copy_up: Option<bool>,

/// Options is a set of options that were used when creating the volume. For the Local driver, these are mount options that will be used to determine how a local filesystem is mounted; they are handled as parameters to Mount in a manner described in the volume create manpage. For non-local drivers, these are passed as-is to the volume plugin.
    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

/// Scope is unused and provided solely for Docker compatibility. It is unconditionally set to \"local\".
    #[serde(rename = "Scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

/// Status is used to return information on the volume's current state, if the volume was created using a volume plugin (uses a Driver that is not the local driver). Status is provided to us by an external program, so no guarantees are made about its format or contents. Further, it is an optional field, so it may not be set even in cases where a volume plugin is in use.
    #[serde(rename = "Status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<std::collections::HashMap<String, crate::types::Object>>,

/// StorageID is the ID of the container backing the volume in c/storage. Only used with Image Volumes.
    #[serde(rename = "StorageID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_id: Option<String>,

/// Timeout is the specified driver timeout if given
    #[serde(rename = "Timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeout: Option<i32>,

/// UID is the UID that the volume was created with.
    #[serde(rename = "UID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub uid: Option<i64>,

}


impl VolumeConfigResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeConfigResponse {
        VolumeConfigResponse {
            anonymous: None,
            created_at: None,
            driver: None,
            gid: None,
            labels: None,
            lock_number: None,
            mount_count: None,
            mountpoint: None,
            name: None,
            needs_chown: None,
            needs_copy_up: None,
            options: None,
            scope: None,
            status: None,
            storage_id: None,
            timeout: None,
            uid: None,
        }
    }
}

/// Converts the VolumeConfigResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VolumeConfigResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.anonymous.as_ref().map(|anonymous| {
                [
                    "Anonymous".to_string(),
                    anonymous.to_string(),
                ].join(",")
            }),

            // Skipping CreatedAt in query parameter serialization


            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.gid.as_ref().map(|gid| {
                [
                    "GID".to_string(),
                    gid.to_string(),
                ].join(",")
            }),

            // Skipping Labels in query parameter serialization


            self.lock_number.as_ref().map(|lock_number| {
                [
                    "LockNumber".to_string(),
                    lock_number.to_string(),
                ].join(",")
            }),


            self.mount_count.as_ref().map(|mount_count| {
                [
                    "MountCount".to_string(),
                    mount_count.to_string(),
                ].join(",")
            }),


            self.mountpoint.as_ref().map(|mountpoint| {
                [
                    "Mountpoint".to_string(),
                    mountpoint.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.needs_chown.as_ref().map(|needs_chown| {
                [
                    "NeedsChown".to_string(),
                    needs_chown.to_string(),
                ].join(",")
            }),


            self.needs_copy_up.as_ref().map(|needs_copy_up| {
                [
                    "NeedsCopyUp".to_string(),
                    needs_copy_up.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization


            self.scope.as_ref().map(|scope| {
                [
                    "Scope".to_string(),
                    scope.to_string(),
                ].join(",")
            }),

            // Skipping Status in query parameter serialization
            // Skipping Status in query parameter serialization


            self.storage_id.as_ref().map(|storage_id| {
                [
                    "StorageID".to_string(),
                    storage_id.to_string(),
                ].join(",")
            }),


            self.timeout.as_ref().map(|timeout| {
                [
                    "Timeout".to_string(),
                    timeout.to_string(),
                ].join(",")
            }),


            self.uid.as_ref().map(|uid| {
                [
                    "UID".to_string(),
                    uid.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeConfigResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeConfigResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub anonymous: Vec<bool>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub driver: Vec<String>,
            pub gid: Vec<i64>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub lock_number: Vec<i32>,
            pub mount_count: Vec<i32>,
            pub mountpoint: Vec<String>,
            pub name: Vec<String>,
            pub needs_chown: Vec<bool>,
            pub needs_copy_up: Vec<bool>,
            pub options: Vec<std::collections::HashMap<String, String>>,
            pub scope: Vec<String>,
            pub status: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub storage_id: Vec<String>,
            pub timeout: Vec<i32>,
            pub uid: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeConfigResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Anonymous" => intermediate_rep.anonymous.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "CreatedAt" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "GID" => intermediate_rep.gid.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeConfigResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "LockNumber" => intermediate_rep.lock_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "MountCount" => intermediate_rep.mount_count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Mountpoint" => intermediate_rep.mountpoint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NeedsChown" => intermediate_rep.needs_chown.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "NeedsCopyUp" => intermediate_rep.needs_copy_up.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeConfigResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Status" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeConfigResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "StorageID" => intermediate_rep.storage_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Timeout" => intermediate_rep.timeout.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "UID" => intermediate_rep.uid.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeConfigResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeConfigResponse {
            anonymous: intermediate_rep.anonymous.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            driver: intermediate_rep.driver.into_iter().next(),
            gid: intermediate_rep.gid.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            lock_number: intermediate_rep.lock_number.into_iter().next(),
            mount_count: intermediate_rep.mount_count.into_iter().next(),
            mountpoint: intermediate_rep.mountpoint.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            needs_chown: intermediate_rep.needs_chown.into_iter().next(),
            needs_copy_up: intermediate_rep.needs_copy_up.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
            scope: intermediate_rep.scope.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            storage_id: intermediate_rep.storage_id.into_iter().next(),
            timeout: intermediate_rep.timeout.into_iter().next(),
            uid: intermediate_rep.uid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeConfigResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeConfigResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeConfigResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeConfigResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeConfigResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeConfigResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeConfigResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details for creating a volume



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeCreate {
/// Name of the volume driver to use.
    #[serde(rename = "Driver")]
    pub driver: String,

/// A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
    #[serde(rename = "DriverOpts")]
    pub driver_opts: std::collections::HashMap<String, String>,

/// User-defined key/value metadata.
    #[serde(rename = "Labels")]
    pub labels: std::collections::HashMap<String, String>,

/// The new volume's name. If not specified, Docker generates a name.
    #[serde(rename = "Name")]
    pub name: String,

}


impl VolumeCreate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(driver: String, driver_opts: std::collections::HashMap<String, String>, labels: std::collections::HashMap<String, String>, name: String, ) -> VolumeCreate {
        VolumeCreate {
            driver,
            driver_opts,
            labels,
            name,
        }
    }
}

/// Converts the VolumeCreate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VolumeCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("Driver".to_string()),
            Some(self.driver.to_string()),

            // Skipping DriverOpts in query parameter serialization

            // Skipping Labels in query parameter serialization


            Some("Name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeCreate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeCreate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver: Vec<String>,
            pub driver_opts: Vec<std::collections::HashMap<String, String>>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeCreate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "DriverOpts" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeCreate".to_string()),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeCreate".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeCreate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeCreate {
            driver: intermediate_rep.driver.into_iter().next().ok_or_else(|| "Driver missing in VolumeCreate".to_string())?,
            driver_opts: intermediate_rep.driver_opts.into_iter().next().ok_or_else(|| "DriverOpts missing in VolumeCreate".to_string())?,
            labels: intermediate_rep.labels.into_iter().next().ok_or_else(|| "Labels missing in VolumeCreate".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "Name missing in VolumeCreate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeCreate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeCreate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeCreate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeCreate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeCreate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeCreate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeCreate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeCreateOptions {
/// Volume driver to use
    #[serde(rename = "Driver")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver: Option<String>,

/// Ignore existing volumes
    #[serde(rename = "IgnoreIfExists")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ignore_if_exists: Option<bool>,

/// User-defined key/value metadata. Provided for compatibility
    #[serde(rename = "Label")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<std::collections::HashMap<String, String>>,

/// User-defined key/value metadata. Preferred field, will override Label
    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

/// New volume's name. Can be left blank
    #[serde(rename = "Name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// Mapping of driver options and values.
    #[serde(rename = "Options")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub options: Option<std::collections::HashMap<String, String>>,

}


impl VolumeCreateOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeCreateOptions {
        VolumeCreateOptions {
            driver: None,
            ignore_if_exists: None,
            label: None,
            labels: None,
            name: None,
            options: None,
        }
    }
}

/// Converts the VolumeCreateOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VolumeCreateOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.driver.as_ref().map(|driver| {
                [
                    "Driver".to_string(),
                    driver.to_string(),
                ].join(",")
            }),


            self.ignore_if_exists.as_ref().map(|ignore_if_exists| {
                [
                    "IgnoreIfExists".to_string(),
                    ignore_if_exists.to_string(),
                ].join(",")
            }),

            // Skipping Label in query parameter serialization

            // Skipping Labels in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "Name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping Options in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeCreateOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeCreateOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver: Vec<String>,
            pub ignore_if_exists: Vec<bool>,
            pub label: Vec<std::collections::HashMap<String, String>>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub name: Vec<String>,
            pub options: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeCreateOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Driver" => intermediate_rep.driver.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "IgnoreIfExists" => intermediate_rep.ignore_if_exists.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Label" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeCreateOptions".to_string()),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeCreateOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "Name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Options" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeCreateOptions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeCreateOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeCreateOptions {
            driver: intermediate_rep.driver.into_iter().next(),
            ignore_if_exists: intermediate_rep.ignore_if_exists.into_iter().next(),
            label: intermediate_rep.label.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            options: intermediate_rep.options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeCreateOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeCreateOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeCreateOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeCreateOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeCreateOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeCreateOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeCreateOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeOptions {
    #[serde(rename = "DriverConfig")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub driver_config: Option<models::Driver>,

    #[serde(rename = "Labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<std::collections::HashMap<String, String>>,

    #[serde(rename = "NoCopy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_copy: Option<bool>,

    #[serde(rename = "Subpath")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub subpath: Option<String>,

}


impl VolumeOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeOptions {
        VolumeOptions {
            driver_config: None,
            labels: None,
            no_copy: None,
            subpath: None,
        }
    }
}

/// Converts the VolumeOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VolumeOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping DriverConfig in query parameter serialization

            // Skipping Labels in query parameter serialization


            self.no_copy.as_ref().map(|no_copy| {
                [
                    "NoCopy".to_string(),
                    no_copy.to_string(),
                ].join(",")
            }),


            self.subpath.as_ref().map(|subpath| {
                [
                    "Subpath".to_string(),
                    subpath.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub driver_config: Vec<models::Driver>,
            pub labels: Vec<std::collections::HashMap<String, String>>,
            pub no_copy: Vec<bool>,
            pub subpath: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "DriverConfig" => intermediate_rep.driver_config.push(<models::Driver as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "Labels" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumeOptions".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "NoCopy" => intermediate_rep.no_copy.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Subpath" => intermediate_rep.subpath.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeOptions {
            driver_config: intermediate_rep.driver_config.into_iter().next(),
            labels: intermediate_rep.labels.into_iter().next(),
            no_copy: intermediate_rep.no_copy.into_iter().next(),
            subpath: intermediate_rep.subpath.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeOptions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeOptions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumeRmReport {
    #[serde(rename = "Err")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub err: Option<String>,

    #[serde(rename = "Id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}


impl VolumeRmReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumeRmReport {
        VolumeRmReport {
            err: None,
            id: None,
        }
    }
}

/// Converts the VolumeRmReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VolumeRmReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.err.as_ref().map(|err| {
                [
                    "Err".to_string(),
                    err.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "Id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumeRmReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumeRmReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub err: Vec<String>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumeRmReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Err" => intermediate_rep.err.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumeRmReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumeRmReport {
            err: intermediate_rep.err.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumeRmReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumeRmReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumeRmReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumeRmReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumeRmReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumeRmReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumeRmReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// POST \"/volumes/prune\"



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VolumesPruneReport {
    #[serde(rename = "SpaceReclaimed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub space_reclaimed: Option<i32>,

    #[serde(rename = "VolumesDeleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub volumes_deleted: Option<Vec<String>>,

}


impl VolumesPruneReport {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> VolumesPruneReport {
        VolumesPruneReport {
            space_reclaimed: None,
            volumes_deleted: None,
        }
    }
}

/// Converts the VolumesPruneReport value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VolumesPruneReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.space_reclaimed.as_ref().map(|space_reclaimed| {
                [
                    "SpaceReclaimed".to_string(),
                    space_reclaimed.to_string(),
                ].join(",")
            }),


            self.volumes_deleted.as_ref().map(|volumes_deleted| {
                [
                    "VolumesDeleted".to_string(),
                    volumes_deleted.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VolumesPruneReport value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VolumesPruneReport {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub space_reclaimed: Vec<i32>,
            pub volumes_deleted: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VolumesPruneReport".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "SpaceReclaimed" => intermediate_rep.space_reclaimed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "VolumesDeleted" => return std::result::Result::Err("Parsing a container in this style is not supported in VolumesPruneReport".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing VolumesPruneReport".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VolumesPruneReport {
            space_reclaimed: intermediate_rep.space_reclaimed.into_iter().next(),
            volumes_deleted: intermediate_rep.volumes_deleted.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VolumesPruneReport> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VolumesPruneReport>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VolumesPruneReport>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for VolumesPruneReport - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VolumesPruneReport> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VolumesPruneReport as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into VolumesPruneReport - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// WaitExitError container waiting error, if any



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WaitExitError {
/// Details of an error
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}


impl WaitExitError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> WaitExitError {
        WaitExitError {
            message: None,
        }
    }
}

/// Converts the WaitExitError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for WaitExitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.message.as_ref().map(|message| {
                [
                    "Message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WaitExitError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WaitExitError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WaitExitError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WaitExitError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WaitExitError {
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WaitExitError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<WaitExitError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WaitExitError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WaitExitError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<WaitExitError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WaitExitError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WaitExitError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// OK response to ContainerWait operation



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WaitResponse {
    #[serde(rename = "Error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<models::WaitExitError>,

/// Exit code of the container
    #[serde(rename = "StatusCode")]
    pub status_code: i64,

}


impl WaitResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(status_code: i64, ) -> WaitResponse {
        WaitResponse {
            error: None,
            status_code,
        }
    }
}

/// Converts the WaitResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for WaitResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping Error in query parameter serialization


            Some("StatusCode".to_string()),
            Some(self.status_code.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WaitResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WaitResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::WaitExitError>,
            pub status_code: Vec<i64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WaitResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Error" => intermediate_rep.error.push(<models::WaitExitError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "StatusCode" => intermediate_rep.status_code.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WaitResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WaitResponse {
            error: intermediate_rep.error.into_iter().next(),
            status_code: intermediate_rep.status_code.into_iter().next().ok_or_else(|| "StatusCode missing in WaitResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WaitResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<WaitResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WaitResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WaitResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<WaitResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WaitResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WaitResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// WeightDevice is a structure that holds device:weight pair



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct WeightDevice {
    #[serde(rename = "Path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,

    #[serde(rename = "Weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<i32>,

}


impl WeightDevice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> WeightDevice {
        WeightDevice {
            path: None,
            weight: None,
        }
    }
}

/// Converts the WeightDevice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for WeightDevice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.path.as_ref().map(|path| {
                [
                    "Path".to_string(),
                    path.to_string(),
                ].join(",")
            }),


            self.weight.as_ref().map(|weight| {
                [
                    "Weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a WeightDevice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for WeightDevice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub path: Vec<String>,
            pub weight: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing WeightDevice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "Path" => intermediate_rep.path.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "Weight" => intermediate_rep.weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing WeightDevice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(WeightDevice {
            path: intermediate_rep.path.into_iter().next(),
            weight: intermediate_rep.weight.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<WeightDevice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<WeightDevice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<WeightDevice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for WeightDevice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<WeightDevice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <WeightDevice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into WeightDevice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}
